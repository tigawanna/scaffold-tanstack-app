{"version":3,"file":"index.js","sources":["../src/utils/shallowEqual.ts","../src/utils/deprecationWarning.ts","../src/validators/generated/index.ts","../src/validators/matchesPattern.ts","../src/validators/buildMatchMemberExpression.ts","../src/validators/react/isReactComponent.ts","../src/validators/react/isCompatTag.ts","../src/validators/isType.ts","../src/validators/isPlaceholderType.ts","../src/validators/is.ts","../src/validators/isValidIdentifier.ts","../src/constants/index.ts","../src/definitions/utils.ts","../src/definitions/core.ts","../src/definitions/flow.ts","../src/definitions/jsx.ts","../src/definitions/placeholders.ts","../src/definitions/misc.ts","../src/definitions/experimental.ts","../src/definitions/typescript.ts","../src/definitions/deprecated-aliases.ts","../src/definitions/index.ts","../src/validators/validate.ts","../src/builders/generated/lowercase.ts","../src/builders/generated/uppercase.ts","../src/utils/react/cleanJSXElementLiteralChild.ts","../src/builders/react/buildChildren.ts","../src/validators/isNode.ts","../src/asserts/assertNode.ts","../src/asserts/generated/index.ts","../src/builders/flow/createTypeAnnotationBasedOnTypeof.ts","../src/modifications/flow/removeTypeDuplicates.ts","../src/builders/flow/createFlowUnionType.ts","../src/modifications/typescript/removeTypeDuplicates.ts","../src/builders/typescript/createTSUnionType.ts","../src/builders/productions.ts","../src/clone/cloneNode.ts","../src/clone/clone.ts","../src/clone/cloneDeep.ts","../src/clone/cloneDeepWithoutLoc.ts","../src/clone/cloneWithoutLoc.ts","../src/comments/addComments.ts","../src/comments/addComment.ts","../src/utils/inherit.ts","../src/comments/inheritInnerComments.ts","../src/comments/inheritLeadingComments.ts","../src/comments/inheritTrailingComments.ts","../src/comments/inheritsComments.ts","../src/comments/removeComments.ts","../src/constants/generated/index.ts","../src/converters/toBlock.ts","../src/converters/ensureBlock.ts","../src/converters/toIdentifier.ts","../src/converters/toBindingIdentifierName.ts","../src/converters/toComputedKey.ts","../src/converters/toExpression.ts","../src/traverse/traverseFast.ts","../src/modifications/removeProperties.ts","../src/modifications/removePropertiesDeep.ts","../src/converters/toKeyAlias.ts","../src/converters/toStatement.ts","../src/converters/valueToNode.ts","../src/modifications/appendToMemberExpression.ts","../src/modifications/inherits.ts","../src/modifications/prependToMemberExpression.ts","../src/retrievers/getAssignmentIdentifiers.ts","../src/retrievers/getBindingIdentifiers.ts","../src/retrievers/getOuterBindingIdentifiers.ts","../src/retrievers/getFunctionName.ts","../src/traverse/traverse.ts","../src/validators/isBinding.ts","../src/validators/isLet.ts","../src/validators/isBlockScoped.ts","../src/validators/isImmutable.ts","../src/validators/isNodesEquivalent.ts","../src/validators/isReferenced.ts","../src/validators/isScope.ts","../src/validators/isSpecifierDefault.ts","../src/validators/isValidES3Identifier.ts","../src/validators/isVar.ts","../src/index.ts"],"sourcesContent":["export default function shallowEqual<T extends object>(\n  actual: object,\n  expected: T,\n): actual is T {\n  const keys = Object.keys(expected) as (keyof T)[];\n\n  for (const key of keys) {\n    if (\n      // @ts-expect-error maybe we should check whether key exists first\n      actual[key] !== expected[key]\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","const warnings = new Set();\n\nexport default function deprecationWarning(\n  oldName: string,\n  newName: string,\n  prefix: string = \"\",\n  cacheKey: string = oldName,\n) {\n  if (warnings.has(cacheKey)) return;\n  warnings.add(cacheKey);\n\n  const { internal, trace } = captureShortStackTrace(1, 2);\n  if (internal) {\n    // If usage comes from an internal package, there is no point in warning because\n    // 1. The new version of the package will already use the new API\n    // 2. When the deprecation will become an error (in a future major version), users\n    //    will have to update every package anyway.\n    return;\n  }\n  console.warn(\n    `${prefix}\\`${oldName}\\` has been deprecated, please migrate to \\`${newName}\\`\\n${trace}`,\n  );\n}\n\nfunction captureShortStackTrace(skip: number, length: number) {\n  const { stackTraceLimit, prepareStackTrace } = Error;\n  let stackTrace: NodeJS.CallSite[];\n  // We add 1 to also take into account this function.\n  Error.stackTraceLimit = 1 + skip + length;\n  Error.prepareStackTrace = function (err, stack) {\n    stackTrace = stack;\n  };\n  // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n  new Error().stack;\n  Error.stackTraceLimit = stackTraceLimit;\n  Error.prepareStackTrace = prepareStackTrace;\n\n  if (!stackTrace) return { internal: false, trace: \"\" };\n\n  const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);\n  return {\n    internal: /[\\\\/]@babel[\\\\/]/.test(shortStackTrace[1].getFileName()),\n    trace: shortStackTrace.map(frame => `    at ${frame}`).join(\"\\n\"),\n  };\n}\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/* eslint-disable no-fallthrough */\n\nimport shallowEqual from \"../../utils/shallowEqual.ts\";\nimport type * as t from \"../../index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\ntype Options<Obj> = Partial<{\n  [Prop in Exclude<keyof Obj, \"type\">]: Obj[Prop] extends t.Node\n    ? t.Node\n    : Obj[Prop] extends t.Node[]\n      ? t.Node[]\n      : Obj[Prop];\n}>;\n\nexport function isArrayExpression(\n  node: t.Node | null | undefined,\n): node is t.ArrayExpression;\nexport function isArrayExpression<Opts extends Options<t.ArrayExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayExpression & Opts;\nexport function isArrayExpression<Opts extends Options<t.ArrayExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAssignmentExpression(\n  node: t.Node | null | undefined,\n): node is t.AssignmentExpression;\nexport function isAssignmentExpression<\n  Opts extends Options<t.AssignmentExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AssignmentExpression & Opts;\nexport function isAssignmentExpression<\n  Opts extends Options<t.AssignmentExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AssignmentExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBinaryExpression(\n  node: t.Node | null | undefined,\n): node is t.BinaryExpression;\nexport function isBinaryExpression<Opts extends Options<t.BinaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BinaryExpression & Opts;\nexport function isBinaryExpression<Opts extends Options<t.BinaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BinaryExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterpreterDirective(\n  node: t.Node | null | undefined,\n): node is t.InterpreterDirective;\nexport function isInterpreterDirective<\n  Opts extends Options<t.InterpreterDirective>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterpreterDirective & Opts;\nexport function isInterpreterDirective<\n  Opts extends Options<t.InterpreterDirective>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterpreterDirective\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDirective(\n  node: t.Node | null | undefined,\n): node is t.Directive;\nexport function isDirective<Opts extends Options<t.Directive>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Directive & Opts;\nexport function isDirective<Opts extends Options<t.Directive>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Directive\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDirectiveLiteral(\n  node: t.Node | null | undefined,\n): node is t.DirectiveLiteral;\nexport function isDirectiveLiteral<Opts extends Options<t.DirectiveLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DirectiveLiteral & Opts;\nexport function isDirectiveLiteral<Opts extends Options<t.DirectiveLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DirectiveLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlockStatement(\n  node: t.Node | null | undefined,\n): node is t.BlockStatement;\nexport function isBlockStatement<Opts extends Options<t.BlockStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BlockStatement & Opts;\nexport function isBlockStatement<Opts extends Options<t.BlockStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BlockStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBreakStatement(\n  node: t.Node | null | undefined,\n): node is t.BreakStatement;\nexport function isBreakStatement<Opts extends Options<t.BreakStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BreakStatement & Opts;\nexport function isBreakStatement<Opts extends Options<t.BreakStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BreakStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCallExpression(\n  node: t.Node | null | undefined,\n): node is t.CallExpression;\nexport function isCallExpression<Opts extends Options<t.CallExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CallExpression & Opts;\nexport function isCallExpression<Opts extends Options<t.CallExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"CallExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCatchClause(\n  node: t.Node | null | undefined,\n): node is t.CatchClause;\nexport function isCatchClause<Opts extends Options<t.CatchClause>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CatchClause & Opts;\nexport function isCatchClause<Opts extends Options<t.CatchClause>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"CatchClause\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isConditionalExpression(\n  node: t.Node | null | undefined,\n): node is t.ConditionalExpression;\nexport function isConditionalExpression<\n  Opts extends Options<t.ConditionalExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ConditionalExpression & Opts;\nexport function isConditionalExpression<\n  Opts extends Options<t.ConditionalExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ConditionalExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isContinueStatement(\n  node: t.Node | null | undefined,\n): node is t.ContinueStatement;\nexport function isContinueStatement<Opts extends Options<t.ContinueStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ContinueStatement & Opts;\nexport function isContinueStatement<Opts extends Options<t.ContinueStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ContinueStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDebuggerStatement(\n  node: t.Node | null | undefined,\n): node is t.DebuggerStatement;\nexport function isDebuggerStatement<Opts extends Options<t.DebuggerStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DebuggerStatement & Opts;\nexport function isDebuggerStatement<Opts extends Options<t.DebuggerStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DebuggerStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDoWhileStatement(\n  node: t.Node | null | undefined,\n): node is t.DoWhileStatement;\nexport function isDoWhileStatement<Opts extends Options<t.DoWhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DoWhileStatement & Opts;\nexport function isDoWhileStatement<Opts extends Options<t.DoWhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DoWhileStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEmptyStatement(\n  node: t.Node | null | undefined,\n): node is t.EmptyStatement;\nexport function isEmptyStatement<Opts extends Options<t.EmptyStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EmptyStatement & Opts;\nexport function isEmptyStatement<Opts extends Options<t.EmptyStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EmptyStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpressionStatement(\n  node: t.Node | null | undefined,\n): node is t.ExpressionStatement;\nexport function isExpressionStatement<\n  Opts extends Options<t.ExpressionStatement>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExpressionStatement & Opts;\nexport function isExpressionStatement<\n  Opts extends Options<t.ExpressionStatement>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExpressionStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFile(node: t.Node | null | undefined): node is t.File;\nexport function isFile<Opts extends Options<t.File>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.File & Opts;\nexport function isFile<Opts extends Options<t.File>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"File\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForInStatement(\n  node: t.Node | null | undefined,\n): node is t.ForInStatement;\nexport function isForInStatement<Opts extends Options<t.ForInStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForInStatement & Opts;\nexport function isForInStatement<Opts extends Options<t.ForInStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForInStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForStatement(\n  node: t.Node | null | undefined,\n): node is t.ForStatement;\nexport function isForStatement<Opts extends Options<t.ForStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForStatement & Opts;\nexport function isForStatement<Opts extends Options<t.ForStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionDeclaration(\n  node: t.Node | null | undefined,\n): node is t.FunctionDeclaration;\nexport function isFunctionDeclaration<\n  Opts extends Options<t.FunctionDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionDeclaration & Opts;\nexport function isFunctionDeclaration<\n  Opts extends Options<t.FunctionDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionExpression(\n  node: t.Node | null | undefined,\n): node is t.FunctionExpression;\nexport function isFunctionExpression<\n  Opts extends Options<t.FunctionExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionExpression & Opts;\nexport function isFunctionExpression<\n  Opts extends Options<t.FunctionExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIdentifier(\n  node: t.Node | null | undefined,\n): node is t.Identifier;\nexport function isIdentifier<Opts extends Options<t.Identifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Identifier & Opts;\nexport function isIdentifier<Opts extends Options<t.Identifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Identifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIfStatement(\n  node: t.Node | null | undefined,\n): node is t.IfStatement;\nexport function isIfStatement<Opts extends Options<t.IfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IfStatement & Opts;\nexport function isIfStatement<Opts extends Options<t.IfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IfStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLabeledStatement(\n  node: t.Node | null | undefined,\n): node is t.LabeledStatement;\nexport function isLabeledStatement<Opts extends Options<t.LabeledStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LabeledStatement & Opts;\nexport function isLabeledStatement<Opts extends Options<t.LabeledStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"LabeledStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringLiteral(\n  node: t.Node | null | undefined,\n): node is t.StringLiteral;\nexport function isStringLiteral<Opts extends Options<t.StringLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringLiteral & Opts;\nexport function isStringLiteral<Opts extends Options<t.StringLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumericLiteral(\n  node: t.Node | null | undefined,\n): node is t.NumericLiteral;\nexport function isNumericLiteral<Opts extends Options<t.NumericLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumericLiteral & Opts;\nexport function isNumericLiteral<Opts extends Options<t.NumericLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumericLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullLiteral(\n  node: t.Node | null | undefined,\n): node is t.NullLiteral;\nexport function isNullLiteral<Opts extends Options<t.NullLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullLiteral & Opts;\nexport function isNullLiteral<Opts extends Options<t.NullLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanLiteral(\n  node: t.Node | null | undefined,\n): node is t.BooleanLiteral;\nexport function isBooleanLiteral<Opts extends Options<t.BooleanLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanLiteral & Opts;\nexport function isBooleanLiteral<Opts extends Options<t.BooleanLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRegExpLiteral(\n  node: t.Node | null | undefined,\n): node is t.RegExpLiteral;\nexport function isRegExpLiteral<Opts extends Options<t.RegExpLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.RegExpLiteral & Opts;\nexport function isRegExpLiteral<Opts extends Options<t.RegExpLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"RegExpLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLogicalExpression(\n  node: t.Node | null | undefined,\n): node is t.LogicalExpression;\nexport function isLogicalExpression<Opts extends Options<t.LogicalExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LogicalExpression & Opts;\nexport function isLogicalExpression<Opts extends Options<t.LogicalExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"LogicalExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.MemberExpression;\nexport function isMemberExpression<Opts extends Options<t.MemberExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MemberExpression & Opts;\nexport function isMemberExpression<Opts extends Options<t.MemberExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNewExpression(\n  node: t.Node | null | undefined,\n): node is t.NewExpression;\nexport function isNewExpression<Opts extends Options<t.NewExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NewExpression & Opts;\nexport function isNewExpression<Opts extends Options<t.NewExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NewExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isProgram(node: t.Node | null | undefined): node is t.Program;\nexport function isProgram<Opts extends Options<t.Program>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Program & Opts;\nexport function isProgram<Opts extends Options<t.Program>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Program\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectExpression(\n  node: t.Node | null | undefined,\n): node is t.ObjectExpression;\nexport function isObjectExpression<Opts extends Options<t.ObjectExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectExpression & Opts;\nexport function isObjectExpression<Opts extends Options<t.ObjectExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectMethod(\n  node: t.Node | null | undefined,\n): node is t.ObjectMethod;\nexport function isObjectMethod<Opts extends Options<t.ObjectMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectMethod & Opts;\nexport function isObjectMethod<Opts extends Options<t.ObjectMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectProperty;\nexport function isObjectProperty<Opts extends Options<t.ObjectProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectProperty & Opts;\nexport function isObjectProperty<Opts extends Options<t.ObjectProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRestElement(\n  node: t.Node | null | undefined,\n): node is t.RestElement;\nexport function isRestElement<Opts extends Options<t.RestElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.RestElement & Opts;\nexport function isRestElement<Opts extends Options<t.RestElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"RestElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isReturnStatement(\n  node: t.Node | null | undefined,\n): node is t.ReturnStatement;\nexport function isReturnStatement<Opts extends Options<t.ReturnStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ReturnStatement & Opts;\nexport function isReturnStatement<Opts extends Options<t.ReturnStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ReturnStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSequenceExpression(\n  node: t.Node | null | undefined,\n): node is t.SequenceExpression;\nexport function isSequenceExpression<\n  Opts extends Options<t.SequenceExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SequenceExpression & Opts;\nexport function isSequenceExpression<\n  Opts extends Options<t.SequenceExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SequenceExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isParenthesizedExpression(\n  node: t.Node | null | undefined,\n): node is t.ParenthesizedExpression;\nexport function isParenthesizedExpression<\n  Opts extends Options<t.ParenthesizedExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ParenthesizedExpression & Opts;\nexport function isParenthesizedExpression<\n  Opts extends Options<t.ParenthesizedExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ParenthesizedExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSwitchCase(\n  node: t.Node | null | undefined,\n): node is t.SwitchCase;\nexport function isSwitchCase<Opts extends Options<t.SwitchCase>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SwitchCase & Opts;\nexport function isSwitchCase<Opts extends Options<t.SwitchCase>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SwitchCase\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSwitchStatement(\n  node: t.Node | null | undefined,\n): node is t.SwitchStatement;\nexport function isSwitchStatement<Opts extends Options<t.SwitchStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SwitchStatement & Opts;\nexport function isSwitchStatement<Opts extends Options<t.SwitchStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SwitchStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThisExpression(\n  node: t.Node | null | undefined,\n): node is t.ThisExpression;\nexport function isThisExpression<Opts extends Options<t.ThisExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThisExpression & Opts;\nexport function isThisExpression<Opts extends Options<t.ThisExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThisExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThrowStatement(\n  node: t.Node | null | undefined,\n): node is t.ThrowStatement;\nexport function isThrowStatement<Opts extends Options<t.ThrowStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThrowStatement & Opts;\nexport function isThrowStatement<Opts extends Options<t.ThrowStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThrowStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTryStatement(\n  node: t.Node | null | undefined,\n): node is t.TryStatement;\nexport function isTryStatement<Opts extends Options<t.TryStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TryStatement & Opts;\nexport function isTryStatement<Opts extends Options<t.TryStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TryStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnaryExpression(\n  node: t.Node | null | undefined,\n): node is t.UnaryExpression;\nexport function isUnaryExpression<Opts extends Options<t.UnaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnaryExpression & Opts;\nexport function isUnaryExpression<Opts extends Options<t.UnaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UnaryExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUpdateExpression(\n  node: t.Node | null | undefined,\n): node is t.UpdateExpression;\nexport function isUpdateExpression<Opts extends Options<t.UpdateExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UpdateExpression & Opts;\nexport function isUpdateExpression<Opts extends Options<t.UpdateExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UpdateExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariableDeclaration(\n  node: t.Node | null | undefined,\n): node is t.VariableDeclaration;\nexport function isVariableDeclaration<\n  Opts extends Options<t.VariableDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VariableDeclaration & Opts;\nexport function isVariableDeclaration<\n  Opts extends Options<t.VariableDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VariableDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariableDeclarator(\n  node: t.Node | null | undefined,\n): node is t.VariableDeclarator;\nexport function isVariableDeclarator<\n  Opts extends Options<t.VariableDeclarator>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VariableDeclarator & Opts;\nexport function isVariableDeclarator<\n  Opts extends Options<t.VariableDeclarator>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VariableDeclarator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWhileStatement(\n  node: t.Node | null | undefined,\n): node is t.WhileStatement;\nexport function isWhileStatement<Opts extends Options<t.WhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.WhileStatement & Opts;\nexport function isWhileStatement<Opts extends Options<t.WhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"WhileStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWithStatement(\n  node: t.Node | null | undefined,\n): node is t.WithStatement;\nexport function isWithStatement<Opts extends Options<t.WithStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.WithStatement & Opts;\nexport function isWithStatement<Opts extends Options<t.WithStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"WithStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAssignmentPattern(\n  node: t.Node | null | undefined,\n): node is t.AssignmentPattern;\nexport function isAssignmentPattern<Opts extends Options<t.AssignmentPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AssignmentPattern & Opts;\nexport function isAssignmentPattern<Opts extends Options<t.AssignmentPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AssignmentPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrayPattern(\n  node: t.Node | null | undefined,\n): node is t.ArrayPattern;\nexport function isArrayPattern<Opts extends Options<t.ArrayPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayPattern & Opts;\nexport function isArrayPattern<Opts extends Options<t.ArrayPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrowFunctionExpression(\n  node: t.Node | null | undefined,\n): node is t.ArrowFunctionExpression;\nexport function isArrowFunctionExpression<\n  Opts extends Options<t.ArrowFunctionExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrowFunctionExpression & Opts;\nexport function isArrowFunctionExpression<\n  Opts extends Options<t.ArrowFunctionExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrowFunctionExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassBody(\n  node: t.Node | null | undefined,\n): node is t.ClassBody;\nexport function isClassBody<Opts extends Options<t.ClassBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassBody & Opts;\nexport function isClassBody<Opts extends Options<t.ClassBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassExpression(\n  node: t.Node | null | undefined,\n): node is t.ClassExpression;\nexport function isClassExpression<Opts extends Options<t.ClassExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassExpression & Opts;\nexport function isClassExpression<Opts extends Options<t.ClassExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ClassDeclaration;\nexport function isClassDeclaration<Opts extends Options<t.ClassDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassDeclaration & Opts;\nexport function isClassDeclaration<Opts extends Options<t.ClassDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportAllDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportAllDeclaration;\nexport function isExportAllDeclaration<\n  Opts extends Options<t.ExportAllDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportAllDeclaration & Opts;\nexport function isExportAllDeclaration<\n  Opts extends Options<t.ExportAllDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportAllDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDefaultDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportDefaultDeclaration;\nexport function isExportDefaultDeclaration<\n  Opts extends Options<t.ExportDefaultDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDefaultDeclaration & Opts;\nexport function isExportDefaultDeclaration<\n  Opts extends Options<t.ExportDefaultDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportDefaultDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportNamedDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportNamedDeclaration;\nexport function isExportNamedDeclaration<\n  Opts extends Options<t.ExportNamedDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportNamedDeclaration & Opts;\nexport function isExportNamedDeclaration<\n  Opts extends Options<t.ExportNamedDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportNamedDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportSpecifier;\nexport function isExportSpecifier<Opts extends Options<t.ExportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportSpecifier & Opts;\nexport function isExportSpecifier<Opts extends Options<t.ExportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForOfStatement(\n  node: t.Node | null | undefined,\n): node is t.ForOfStatement;\nexport function isForOfStatement<Opts extends Options<t.ForOfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForOfStatement & Opts;\nexport function isForOfStatement<Opts extends Options<t.ForOfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForOfStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ImportDeclaration;\nexport function isImportDeclaration<Opts extends Options<t.ImportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportDeclaration & Opts;\nexport function isImportDeclaration<Opts extends Options<t.ImportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportDefaultSpecifier;\nexport function isImportDefaultSpecifier<\n  Opts extends Options<t.ImportDefaultSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportDefaultSpecifier & Opts;\nexport function isImportDefaultSpecifier<\n  Opts extends Options<t.ImportDefaultSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportDefaultSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportNamespaceSpecifier;\nexport function isImportNamespaceSpecifier<\n  Opts extends Options<t.ImportNamespaceSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportNamespaceSpecifier & Opts;\nexport function isImportNamespaceSpecifier<\n  Opts extends Options<t.ImportNamespaceSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportNamespaceSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportSpecifier;\nexport function isImportSpecifier<Opts extends Options<t.ImportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportSpecifier & Opts;\nexport function isImportSpecifier<Opts extends Options<t.ImportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportExpression(\n  node: t.Node | null | undefined,\n): node is t.ImportExpression;\nexport function isImportExpression<Opts extends Options<t.ImportExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportExpression & Opts;\nexport function isImportExpression<Opts extends Options<t.ImportExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMetaProperty(\n  node: t.Node | null | undefined,\n): node is t.MetaProperty;\nexport function isMetaProperty<Opts extends Options<t.MetaProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MetaProperty & Opts;\nexport function isMetaProperty<Opts extends Options<t.MetaProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MetaProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassMethod(\n  node: t.Node | null | undefined,\n): node is t.ClassMethod;\nexport function isClassMethod<Opts extends Options<t.ClassMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassMethod & Opts;\nexport function isClassMethod<Opts extends Options<t.ClassMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectPattern(\n  node: t.Node | null | undefined,\n): node is t.ObjectPattern;\nexport function isObjectPattern<Opts extends Options<t.ObjectPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectPattern & Opts;\nexport function isObjectPattern<Opts extends Options<t.ObjectPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSpreadElement(\n  node: t.Node | null | undefined,\n): node is t.SpreadElement;\nexport function isSpreadElement<Opts extends Options<t.SpreadElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SpreadElement & Opts;\nexport function isSpreadElement<Opts extends Options<t.SpreadElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SpreadElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSuper(node: t.Node | null | undefined): node is t.Super;\nexport function isSuper<Opts extends Options<t.Super>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Super & Opts;\nexport function isSuper<Opts extends Options<t.Super>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Super\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTaggedTemplateExpression(\n  node: t.Node | null | undefined,\n): node is t.TaggedTemplateExpression;\nexport function isTaggedTemplateExpression<\n  Opts extends Options<t.TaggedTemplateExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TaggedTemplateExpression & Opts;\nexport function isTaggedTemplateExpression<\n  Opts extends Options<t.TaggedTemplateExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TaggedTemplateExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTemplateElement(\n  node: t.Node | null | undefined,\n): node is t.TemplateElement;\nexport function isTemplateElement<Opts extends Options<t.TemplateElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TemplateElement & Opts;\nexport function isTemplateElement<Opts extends Options<t.TemplateElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TemplateElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTemplateLiteral(\n  node: t.Node | null | undefined,\n): node is t.TemplateLiteral;\nexport function isTemplateLiteral<Opts extends Options<t.TemplateLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TemplateLiteral & Opts;\nexport function isTemplateLiteral<Opts extends Options<t.TemplateLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TemplateLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isYieldExpression(\n  node: t.Node | null | undefined,\n): node is t.YieldExpression;\nexport function isYieldExpression<Opts extends Options<t.YieldExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.YieldExpression & Opts;\nexport function isYieldExpression<Opts extends Options<t.YieldExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"YieldExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAwaitExpression(\n  node: t.Node | null | undefined,\n): node is t.AwaitExpression;\nexport function isAwaitExpression<Opts extends Options<t.AwaitExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AwaitExpression & Opts;\nexport function isAwaitExpression<Opts extends Options<t.AwaitExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AwaitExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImport(node: t.Node | null | undefined): node is t.Import;\nexport function isImport<Opts extends Options<t.Import>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Import & Opts;\nexport function isImport<Opts extends Options<t.Import>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Import\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBigIntLiteral(\n  node: t.Node | null | undefined,\n): node is t.BigIntLiteral;\nexport function isBigIntLiteral<Opts extends Options<t.BigIntLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BigIntLiteral & Opts;\nexport function isBigIntLiteral<Opts extends Options<t.BigIntLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BigIntLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportNamespaceSpecifier;\nexport function isExportNamespaceSpecifier<\n  Opts extends Options<t.ExportNamespaceSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportNamespaceSpecifier & Opts;\nexport function isExportNamespaceSpecifier<\n  Opts extends Options<t.ExportNamespaceSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportNamespaceSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.OptionalMemberExpression;\nexport function isOptionalMemberExpression<\n  Opts extends Options<t.OptionalMemberExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalMemberExpression & Opts;\nexport function isOptionalMemberExpression<\n  Opts extends Options<t.OptionalMemberExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalMemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalCallExpression(\n  node: t.Node | null | undefined,\n): node is t.OptionalCallExpression;\nexport function isOptionalCallExpression<\n  Opts extends Options<t.OptionalCallExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalCallExpression & Opts;\nexport function isOptionalCallExpression<\n  Opts extends Options<t.OptionalCallExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalCallExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassProperty;\nexport function isClassProperty<Opts extends Options<t.ClassProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassProperty & Opts;\nexport function isClassProperty<Opts extends Options<t.ClassProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassAccessorProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassAccessorProperty;\nexport function isClassAccessorProperty<\n  Opts extends Options<t.ClassAccessorProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassAccessorProperty & Opts;\nexport function isClassAccessorProperty<\n  Opts extends Options<t.ClassAccessorProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassAccessorProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassPrivateProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassPrivateProperty;\nexport function isClassPrivateProperty<\n  Opts extends Options<t.ClassPrivateProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassPrivateProperty & Opts;\nexport function isClassPrivateProperty<\n  Opts extends Options<t.ClassPrivateProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassPrivateProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassPrivateMethod(\n  node: t.Node | null | undefined,\n): node is t.ClassPrivateMethod;\nexport function isClassPrivateMethod<\n  Opts extends Options<t.ClassPrivateMethod>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassPrivateMethod & Opts;\nexport function isClassPrivateMethod<\n  Opts extends Options<t.ClassPrivateMethod>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassPrivateMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPrivateName(\n  node: t.Node | null | undefined,\n): node is t.PrivateName;\nexport function isPrivateName<Opts extends Options<t.PrivateName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PrivateName & Opts;\nexport function isPrivateName<Opts extends Options<t.PrivateName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PrivateName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStaticBlock(\n  node: t.Node | null | undefined,\n): node is t.StaticBlock;\nexport function isStaticBlock<Opts extends Options<t.StaticBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StaticBlock & Opts;\nexport function isStaticBlock<Opts extends Options<t.StaticBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StaticBlock\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportAttribute(\n  node: t.Node | null | undefined,\n): node is t.ImportAttribute;\nexport function isImportAttribute<Opts extends Options<t.ImportAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportAttribute & Opts;\nexport function isImportAttribute<Opts extends Options<t.ImportAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAnyTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.AnyTypeAnnotation;\nexport function isAnyTypeAnnotation<Opts extends Options<t.AnyTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AnyTypeAnnotation & Opts;\nexport function isAnyTypeAnnotation<Opts extends Options<t.AnyTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AnyTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrayTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ArrayTypeAnnotation;\nexport function isArrayTypeAnnotation<\n  Opts extends Options<t.ArrayTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayTypeAnnotation & Opts;\nexport function isArrayTypeAnnotation<\n  Opts extends Options<t.ArrayTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.BooleanTypeAnnotation;\nexport function isBooleanTypeAnnotation<\n  Opts extends Options<t.BooleanTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanTypeAnnotation & Opts;\nexport function isBooleanTypeAnnotation<\n  Opts extends Options<t.BooleanTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.BooleanLiteralTypeAnnotation;\nexport function isBooleanLiteralTypeAnnotation<\n  Opts extends Options<t.BooleanLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanLiteralTypeAnnotation & Opts;\nexport function isBooleanLiteralTypeAnnotation<\n  Opts extends Options<t.BooleanLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NullLiteralTypeAnnotation;\nexport function isNullLiteralTypeAnnotation<\n  Opts extends Options<t.NullLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullLiteralTypeAnnotation & Opts;\nexport function isNullLiteralTypeAnnotation<\n  Opts extends Options<t.NullLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassImplements(\n  node: t.Node | null | undefined,\n): node is t.ClassImplements;\nexport function isClassImplements<Opts extends Options<t.ClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassImplements & Opts;\nexport function isClassImplements<Opts extends Options<t.ClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassImplements\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareClass(\n  node: t.Node | null | undefined,\n): node is t.DeclareClass;\nexport function isDeclareClass<Opts extends Options<t.DeclareClass>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareClass & Opts;\nexport function isDeclareClass<Opts extends Options<t.DeclareClass>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareClass\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareFunction(\n  node: t.Node | null | undefined,\n): node is t.DeclareFunction;\nexport function isDeclareFunction<Opts extends Options<t.DeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareFunction & Opts;\nexport function isDeclareFunction<Opts extends Options<t.DeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareInterface(\n  node: t.Node | null | undefined,\n): node is t.DeclareInterface;\nexport function isDeclareInterface<Opts extends Options<t.DeclareInterface>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareInterface & Opts;\nexport function isDeclareInterface<Opts extends Options<t.DeclareInterface>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareInterface\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareModule(\n  node: t.Node | null | undefined,\n): node is t.DeclareModule;\nexport function isDeclareModule<Opts extends Options<t.DeclareModule>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareModule & Opts;\nexport function isDeclareModule<Opts extends Options<t.DeclareModule>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareModule\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareModuleExports(\n  node: t.Node | null | undefined,\n): node is t.DeclareModuleExports;\nexport function isDeclareModuleExports<\n  Opts extends Options<t.DeclareModuleExports>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareModuleExports & Opts;\nexport function isDeclareModuleExports<\n  Opts extends Options<t.DeclareModuleExports>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareModuleExports\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareTypeAlias(\n  node: t.Node | null | undefined,\n): node is t.DeclareTypeAlias;\nexport function isDeclareTypeAlias<Opts extends Options<t.DeclareTypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareTypeAlias & Opts;\nexport function isDeclareTypeAlias<Opts extends Options<t.DeclareTypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareTypeAlias\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareOpaqueType(\n  node: t.Node | null | undefined,\n): node is t.DeclareOpaqueType;\nexport function isDeclareOpaqueType<Opts extends Options<t.DeclareOpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareOpaqueType & Opts;\nexport function isDeclareOpaqueType<Opts extends Options<t.DeclareOpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareOpaqueType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareVariable(\n  node: t.Node | null | undefined,\n): node is t.DeclareVariable;\nexport function isDeclareVariable<Opts extends Options<t.DeclareVariable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareVariable & Opts;\nexport function isDeclareVariable<Opts extends Options<t.DeclareVariable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareVariable\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.DeclareExportDeclaration;\nexport function isDeclareExportDeclaration<\n  Opts extends Options<t.DeclareExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareExportDeclaration & Opts;\nexport function isDeclareExportDeclaration<\n  Opts extends Options<t.DeclareExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareExportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareExportAllDeclaration(\n  node: t.Node | null | undefined,\n): node is t.DeclareExportAllDeclaration;\nexport function isDeclareExportAllDeclaration<\n  Opts extends Options<t.DeclareExportAllDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareExportAllDeclaration & Opts;\nexport function isDeclareExportAllDeclaration<\n  Opts extends Options<t.DeclareExportAllDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareExportAllDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclaredPredicate(\n  node: t.Node | null | undefined,\n): node is t.DeclaredPredicate;\nexport function isDeclaredPredicate<Opts extends Options<t.DeclaredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclaredPredicate & Opts;\nexport function isDeclaredPredicate<Opts extends Options<t.DeclaredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclaredPredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExistsTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ExistsTypeAnnotation;\nexport function isExistsTypeAnnotation<\n  Opts extends Options<t.ExistsTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExistsTypeAnnotation & Opts;\nexport function isExistsTypeAnnotation<\n  Opts extends Options<t.ExistsTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExistsTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.FunctionTypeAnnotation;\nexport function isFunctionTypeAnnotation<\n  Opts extends Options<t.FunctionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionTypeAnnotation & Opts;\nexport function isFunctionTypeAnnotation<\n  Opts extends Options<t.FunctionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionTypeParam(\n  node: t.Node | null | undefined,\n): node is t.FunctionTypeParam;\nexport function isFunctionTypeParam<Opts extends Options<t.FunctionTypeParam>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionTypeParam & Opts;\nexport function isFunctionTypeParam<Opts extends Options<t.FunctionTypeParam>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionTypeParam\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isGenericTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.GenericTypeAnnotation;\nexport function isGenericTypeAnnotation<\n  Opts extends Options<t.GenericTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.GenericTypeAnnotation & Opts;\nexport function isGenericTypeAnnotation<\n  Opts extends Options<t.GenericTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"GenericTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInferredPredicate(\n  node: t.Node | null | undefined,\n): node is t.InferredPredicate;\nexport function isInferredPredicate<Opts extends Options<t.InferredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InferredPredicate & Opts;\nexport function isInferredPredicate<Opts extends Options<t.InferredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InferredPredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceExtends(\n  node: t.Node | null | undefined,\n): node is t.InterfaceExtends;\nexport function isInterfaceExtends<Opts extends Options<t.InterfaceExtends>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceExtends & Opts;\nexport function isInterfaceExtends<Opts extends Options<t.InterfaceExtends>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceExtends\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): node is t.InterfaceDeclaration;\nexport function isInterfaceDeclaration<\n  Opts extends Options<t.InterfaceDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceDeclaration & Opts;\nexport function isInterfaceDeclaration<\n  Opts extends Options<t.InterfaceDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.InterfaceTypeAnnotation;\nexport function isInterfaceTypeAnnotation<\n  Opts extends Options<t.InterfaceTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceTypeAnnotation & Opts;\nexport function isInterfaceTypeAnnotation<\n  Opts extends Options<t.InterfaceTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIntersectionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.IntersectionTypeAnnotation;\nexport function isIntersectionTypeAnnotation<\n  Opts extends Options<t.IntersectionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IntersectionTypeAnnotation & Opts;\nexport function isIntersectionTypeAnnotation<\n  Opts extends Options<t.IntersectionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IntersectionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMixedTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.MixedTypeAnnotation;\nexport function isMixedTypeAnnotation<\n  Opts extends Options<t.MixedTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MixedTypeAnnotation & Opts;\nexport function isMixedTypeAnnotation<\n  Opts extends Options<t.MixedTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MixedTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEmptyTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.EmptyTypeAnnotation;\nexport function isEmptyTypeAnnotation<\n  Opts extends Options<t.EmptyTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EmptyTypeAnnotation & Opts;\nexport function isEmptyTypeAnnotation<\n  Opts extends Options<t.EmptyTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EmptyTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullableTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NullableTypeAnnotation;\nexport function isNullableTypeAnnotation<\n  Opts extends Options<t.NullableTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullableTypeAnnotation & Opts;\nexport function isNullableTypeAnnotation<\n  Opts extends Options<t.NullableTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullableTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumberLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NumberLiteralTypeAnnotation;\nexport function isNumberLiteralTypeAnnotation<\n  Opts extends Options<t.NumberLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumberLiteralTypeAnnotation & Opts;\nexport function isNumberLiteralTypeAnnotation<\n  Opts extends Options<t.NumberLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumberLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumberTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NumberTypeAnnotation;\nexport function isNumberTypeAnnotation<\n  Opts extends Options<t.NumberTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumberTypeAnnotation & Opts;\nexport function isNumberTypeAnnotation<\n  Opts extends Options<t.NumberTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumberTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeAnnotation;\nexport function isObjectTypeAnnotation<\n  Opts extends Options<t.ObjectTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeAnnotation & Opts;\nexport function isObjectTypeAnnotation<\n  Opts extends Options<t.ObjectTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeInternalSlot(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeInternalSlot;\nexport function isObjectTypeInternalSlot<\n  Opts extends Options<t.ObjectTypeInternalSlot>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeInternalSlot & Opts;\nexport function isObjectTypeInternalSlot<\n  Opts extends Options<t.ObjectTypeInternalSlot>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeInternalSlot\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeCallProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeCallProperty;\nexport function isObjectTypeCallProperty<\n  Opts extends Options<t.ObjectTypeCallProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeCallProperty & Opts;\nexport function isObjectTypeCallProperty<\n  Opts extends Options<t.ObjectTypeCallProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeCallProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeIndexer(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeIndexer;\nexport function isObjectTypeIndexer<Opts extends Options<t.ObjectTypeIndexer>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeIndexer & Opts;\nexport function isObjectTypeIndexer<Opts extends Options<t.ObjectTypeIndexer>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeIndexer\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeProperty;\nexport function isObjectTypeProperty<\n  Opts extends Options<t.ObjectTypeProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeProperty & Opts;\nexport function isObjectTypeProperty<\n  Opts extends Options<t.ObjectTypeProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeSpreadProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeSpreadProperty;\nexport function isObjectTypeSpreadProperty<\n  Opts extends Options<t.ObjectTypeSpreadProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeSpreadProperty & Opts;\nexport function isObjectTypeSpreadProperty<\n  Opts extends Options<t.ObjectTypeSpreadProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeSpreadProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOpaqueType(\n  node: t.Node | null | undefined,\n): node is t.OpaqueType;\nexport function isOpaqueType<Opts extends Options<t.OpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OpaqueType & Opts;\nexport function isOpaqueType<Opts extends Options<t.OpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OpaqueType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isQualifiedTypeIdentifier(\n  node: t.Node | null | undefined,\n): node is t.QualifiedTypeIdentifier;\nexport function isQualifiedTypeIdentifier<\n  Opts extends Options<t.QualifiedTypeIdentifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.QualifiedTypeIdentifier & Opts;\nexport function isQualifiedTypeIdentifier<\n  Opts extends Options<t.QualifiedTypeIdentifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"QualifiedTypeIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.StringLiteralTypeAnnotation;\nexport function isStringLiteralTypeAnnotation<\n  Opts extends Options<t.StringLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringLiteralTypeAnnotation & Opts;\nexport function isStringLiteralTypeAnnotation<\n  Opts extends Options<t.StringLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.StringTypeAnnotation;\nexport function isStringTypeAnnotation<\n  Opts extends Options<t.StringTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringTypeAnnotation & Opts;\nexport function isStringTypeAnnotation<\n  Opts extends Options<t.StringTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSymbolTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.SymbolTypeAnnotation;\nexport function isSymbolTypeAnnotation<\n  Opts extends Options<t.SymbolTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SymbolTypeAnnotation & Opts;\nexport function isSymbolTypeAnnotation<\n  Opts extends Options<t.SymbolTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SymbolTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThisTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ThisTypeAnnotation;\nexport function isThisTypeAnnotation<\n  Opts extends Options<t.ThisTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThisTypeAnnotation & Opts;\nexport function isThisTypeAnnotation<\n  Opts extends Options<t.ThisTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThisTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTupleTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TupleTypeAnnotation;\nexport function isTupleTypeAnnotation<\n  Opts extends Options<t.TupleTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TupleTypeAnnotation & Opts;\nexport function isTupleTypeAnnotation<\n  Opts extends Options<t.TupleTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TupleTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeofTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TypeofTypeAnnotation;\nexport function isTypeofTypeAnnotation<\n  Opts extends Options<t.TypeofTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeofTypeAnnotation & Opts;\nexport function isTypeofTypeAnnotation<\n  Opts extends Options<t.TypeofTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeofTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeAlias(\n  node: t.Node | null | undefined,\n): node is t.TypeAlias;\nexport function isTypeAlias<Opts extends Options<t.TypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeAlias & Opts;\nexport function isTypeAlias<Opts extends Options<t.TypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeAlias\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TypeAnnotation;\nexport function isTypeAnnotation<Opts extends Options<t.TypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeAnnotation & Opts;\nexport function isTypeAnnotation<Opts extends Options<t.TypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeCastExpression(\n  node: t.Node | null | undefined,\n): node is t.TypeCastExpression;\nexport function isTypeCastExpression<\n  Opts extends Options<t.TypeCastExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeCastExpression & Opts;\nexport function isTypeCastExpression<\n  Opts extends Options<t.TypeCastExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeCastExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameter(\n  node: t.Node | null | undefined,\n): node is t.TypeParameter;\nexport function isTypeParameter<Opts extends Options<t.TypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameter & Opts;\nexport function isTypeParameter<Opts extends Options<t.TypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameter\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TypeParameterDeclaration;\nexport function isTypeParameterDeclaration<\n  Opts extends Options<t.TypeParameterDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameterDeclaration & Opts;\nexport function isTypeParameterDeclaration<\n  Opts extends Options<t.TypeParameterDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameterDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n): node is t.TypeParameterInstantiation;\nexport function isTypeParameterInstantiation<\n  Opts extends Options<t.TypeParameterInstantiation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameterInstantiation & Opts;\nexport function isTypeParameterInstantiation<\n  Opts extends Options<t.TypeParameterInstantiation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameterInstantiation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.UnionTypeAnnotation;\nexport function isUnionTypeAnnotation<\n  Opts extends Options<t.UnionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnionTypeAnnotation & Opts;\nexport function isUnionTypeAnnotation<\n  Opts extends Options<t.UnionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UnionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariance(node: t.Node | null | undefined): node is t.Variance;\nexport function isVariance<Opts extends Options<t.Variance>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Variance & Opts;\nexport function isVariance<Opts extends Options<t.Variance>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Variance\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVoidTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.VoidTypeAnnotation;\nexport function isVoidTypeAnnotation<\n  Opts extends Options<t.VoidTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VoidTypeAnnotation & Opts;\nexport function isVoidTypeAnnotation<\n  Opts extends Options<t.VoidTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VoidTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumDeclaration(\n  node: t.Node | null | undefined,\n): node is t.EnumDeclaration;\nexport function isEnumDeclaration<Opts extends Options<t.EnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumDeclaration & Opts;\nexport function isEnumDeclaration<Opts extends Options<t.EnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBooleanBody(\n  node: t.Node | null | undefined,\n): node is t.EnumBooleanBody;\nexport function isEnumBooleanBody<Opts extends Options<t.EnumBooleanBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBooleanBody & Opts;\nexport function isEnumBooleanBody<Opts extends Options<t.EnumBooleanBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumBooleanBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumNumberBody(\n  node: t.Node | null | undefined,\n): node is t.EnumNumberBody;\nexport function isEnumNumberBody<Opts extends Options<t.EnumNumberBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumNumberBody & Opts;\nexport function isEnumNumberBody<Opts extends Options<t.EnumNumberBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumNumberBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumStringBody(\n  node: t.Node | null | undefined,\n): node is t.EnumStringBody;\nexport function isEnumStringBody<Opts extends Options<t.EnumStringBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumStringBody & Opts;\nexport function isEnumStringBody<Opts extends Options<t.EnumStringBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumStringBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumSymbolBody(\n  node: t.Node | null | undefined,\n): node is t.EnumSymbolBody;\nexport function isEnumSymbolBody<Opts extends Options<t.EnumSymbolBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumSymbolBody & Opts;\nexport function isEnumSymbolBody<Opts extends Options<t.EnumSymbolBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumSymbolBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBooleanMember(\n  node: t.Node | null | undefined,\n): node is t.EnumBooleanMember;\nexport function isEnumBooleanMember<Opts extends Options<t.EnumBooleanMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBooleanMember & Opts;\nexport function isEnumBooleanMember<Opts extends Options<t.EnumBooleanMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumBooleanMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumNumberMember(\n  node: t.Node | null | undefined,\n): node is t.EnumNumberMember;\nexport function isEnumNumberMember<Opts extends Options<t.EnumNumberMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumNumberMember & Opts;\nexport function isEnumNumberMember<Opts extends Options<t.EnumNumberMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumNumberMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumStringMember(\n  node: t.Node | null | undefined,\n): node is t.EnumStringMember;\nexport function isEnumStringMember<Opts extends Options<t.EnumStringMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumStringMember & Opts;\nexport function isEnumStringMember<Opts extends Options<t.EnumStringMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumStringMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumDefaultedMember(\n  node: t.Node | null | undefined,\n): node is t.EnumDefaultedMember;\nexport function isEnumDefaultedMember<\n  Opts extends Options<t.EnumDefaultedMember>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumDefaultedMember & Opts;\nexport function isEnumDefaultedMember<\n  Opts extends Options<t.EnumDefaultedMember>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumDefaultedMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.IndexedAccessType;\nexport function isIndexedAccessType<Opts extends Options<t.IndexedAccessType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IndexedAccessType & Opts;\nexport function isIndexedAccessType<Opts extends Options<t.IndexedAccessType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.OptionalIndexedAccessType;\nexport function isOptionalIndexedAccessType<\n  Opts extends Options<t.OptionalIndexedAccessType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalIndexedAccessType & Opts;\nexport function isOptionalIndexedAccessType<\n  Opts extends Options<t.OptionalIndexedAccessType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalIndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXAttribute(\n  node: t.Node | null | undefined,\n): node is t.JSXAttribute;\nexport function isJSXAttribute<Opts extends Options<t.JSXAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXAttribute & Opts;\nexport function isJSXAttribute<Opts extends Options<t.JSXAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXClosingElement(\n  node: t.Node | null | undefined,\n): node is t.JSXClosingElement;\nexport function isJSXClosingElement<Opts extends Options<t.JSXClosingElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXClosingElement & Opts;\nexport function isJSXClosingElement<Opts extends Options<t.JSXClosingElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXClosingElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXElement(\n  node: t.Node | null | undefined,\n): node is t.JSXElement;\nexport function isJSXElement<Opts extends Options<t.JSXElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXElement & Opts;\nexport function isJSXElement<Opts extends Options<t.JSXElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXEmptyExpression(\n  node: t.Node | null | undefined,\n): node is t.JSXEmptyExpression;\nexport function isJSXEmptyExpression<\n  Opts extends Options<t.JSXEmptyExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXEmptyExpression & Opts;\nexport function isJSXEmptyExpression<\n  Opts extends Options<t.JSXEmptyExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXEmptyExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXExpressionContainer(\n  node: t.Node | null | undefined,\n): node is t.JSXExpressionContainer;\nexport function isJSXExpressionContainer<\n  Opts extends Options<t.JSXExpressionContainer>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXExpressionContainer & Opts;\nexport function isJSXExpressionContainer<\n  Opts extends Options<t.JSXExpressionContainer>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXExpressionContainer\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXSpreadChild(\n  node: t.Node | null | undefined,\n): node is t.JSXSpreadChild;\nexport function isJSXSpreadChild<Opts extends Options<t.JSXSpreadChild>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXSpreadChild & Opts;\nexport function isJSXSpreadChild<Opts extends Options<t.JSXSpreadChild>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXSpreadChild\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXIdentifier(\n  node: t.Node | null | undefined,\n): node is t.JSXIdentifier;\nexport function isJSXIdentifier<Opts extends Options<t.JSXIdentifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXIdentifier & Opts;\nexport function isJSXIdentifier<Opts extends Options<t.JSXIdentifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.JSXMemberExpression;\nexport function isJSXMemberExpression<\n  Opts extends Options<t.JSXMemberExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXMemberExpression & Opts;\nexport function isJSXMemberExpression<\n  Opts extends Options<t.JSXMemberExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXMemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXNamespacedName(\n  node: t.Node | null | undefined,\n): node is t.JSXNamespacedName;\nexport function isJSXNamespacedName<Opts extends Options<t.JSXNamespacedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXNamespacedName & Opts;\nexport function isJSXNamespacedName<Opts extends Options<t.JSXNamespacedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXNamespacedName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXOpeningElement(\n  node: t.Node | null | undefined,\n): node is t.JSXOpeningElement;\nexport function isJSXOpeningElement<Opts extends Options<t.JSXOpeningElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXOpeningElement & Opts;\nexport function isJSXOpeningElement<Opts extends Options<t.JSXOpeningElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXOpeningElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXSpreadAttribute(\n  node: t.Node | null | undefined,\n): node is t.JSXSpreadAttribute;\nexport function isJSXSpreadAttribute<\n  Opts extends Options<t.JSXSpreadAttribute>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXSpreadAttribute & Opts;\nexport function isJSXSpreadAttribute<\n  Opts extends Options<t.JSXSpreadAttribute>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXSpreadAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXText(node: t.Node | null | undefined): node is t.JSXText;\nexport function isJSXText<Opts extends Options<t.JSXText>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXText & Opts;\nexport function isJSXText<Opts extends Options<t.JSXText>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXText\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXFragment;\nexport function isJSXFragment<Opts extends Options<t.JSXFragment>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXFragment & Opts;\nexport function isJSXFragment<Opts extends Options<t.JSXFragment>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXOpeningFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXOpeningFragment;\nexport function isJSXOpeningFragment<\n  Opts extends Options<t.JSXOpeningFragment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXOpeningFragment & Opts;\nexport function isJSXOpeningFragment<\n  Opts extends Options<t.JSXOpeningFragment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXOpeningFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXClosingFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXClosingFragment;\nexport function isJSXClosingFragment<\n  Opts extends Options<t.JSXClosingFragment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXClosingFragment & Opts;\nexport function isJSXClosingFragment<\n  Opts extends Options<t.JSXClosingFragment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXClosingFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPlaceholder(\n  node: t.Node | null | undefined,\n): node is t.Placeholder;\nexport function isPlaceholder<Opts extends Options<t.Placeholder>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Placeholder & Opts;\nexport function isPlaceholder<Opts extends Options<t.Placeholder>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Placeholder\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isV8IntrinsicIdentifier(\n  node: t.Node | null | undefined,\n): node is t.V8IntrinsicIdentifier;\nexport function isV8IntrinsicIdentifier<\n  Opts extends Options<t.V8IntrinsicIdentifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.V8IntrinsicIdentifier & Opts;\nexport function isV8IntrinsicIdentifier<\n  Opts extends Options<t.V8IntrinsicIdentifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"V8IntrinsicIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArgumentPlaceholder(\n  node: t.Node | null | undefined,\n): node is t.ArgumentPlaceholder;\nexport function isArgumentPlaceholder<\n  Opts extends Options<t.ArgumentPlaceholder>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArgumentPlaceholder & Opts;\nexport function isArgumentPlaceholder<\n  Opts extends Options<t.ArgumentPlaceholder>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArgumentPlaceholder\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBindExpression(\n  node: t.Node | null | undefined,\n): node is t.BindExpression;\nexport function isBindExpression<Opts extends Options<t.BindExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BindExpression & Opts;\nexport function isBindExpression<Opts extends Options<t.BindExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BindExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDecorator(\n  node: t.Node | null | undefined,\n): node is t.Decorator;\nexport function isDecorator<Opts extends Options<t.Decorator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Decorator & Opts;\nexport function isDecorator<Opts extends Options<t.Decorator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Decorator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDoExpression(\n  node: t.Node | null | undefined,\n): node is t.DoExpression;\nexport function isDoExpression<Opts extends Options<t.DoExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DoExpression & Opts;\nexport function isDoExpression<Opts extends Options<t.DoExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DoExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportDefaultSpecifier;\nexport function isExportDefaultSpecifier<\n  Opts extends Options<t.ExportDefaultSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDefaultSpecifier & Opts;\nexport function isExportDefaultSpecifier<\n  Opts extends Options<t.ExportDefaultSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportDefaultSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isModuleExpression(\n  node: t.Node | null | undefined,\n): node is t.ModuleExpression;\nexport function isModuleExpression<Opts extends Options<t.ModuleExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ModuleExpression & Opts;\nexport function isModuleExpression<Opts extends Options<t.ModuleExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ModuleExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTopicReference(\n  node: t.Node | null | undefined,\n): node is t.TopicReference;\nexport function isTopicReference<Opts extends Options<t.TopicReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TopicReference & Opts;\nexport function isTopicReference<Opts extends Options<t.TopicReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TopicReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelineTopicExpression(\n  node: t.Node | null | undefined,\n): node is t.PipelineTopicExpression;\nexport function isPipelineTopicExpression<\n  Opts extends Options<t.PipelineTopicExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PipelineTopicExpression & Opts;\nexport function isPipelineTopicExpression<\n  Opts extends Options<t.PipelineTopicExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PipelineTopicExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelineBareFunction(\n  node: t.Node | null | undefined,\n): node is t.PipelineBareFunction;\nexport function isPipelineBareFunction<\n  Opts extends Options<t.PipelineBareFunction>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PipelineBareFunction & Opts;\nexport function isPipelineBareFunction<\n  Opts extends Options<t.PipelineBareFunction>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PipelineBareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelinePrimaryTopicReference(\n  node: t.Node | null | undefined,\n): node is t.PipelinePrimaryTopicReference;\nexport function isPipelinePrimaryTopicReference<\n  Opts extends Options<t.PipelinePrimaryTopicReference>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PipelinePrimaryTopicReference & Opts;\nexport function isPipelinePrimaryTopicReference<\n  Opts extends Options<t.PipelinePrimaryTopicReference>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PipelinePrimaryTopicReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVoidPattern(\n  node: t.Node | null | undefined,\n): node is t.VoidPattern;\nexport function isVoidPattern<Opts extends Options<t.VoidPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VoidPattern & Opts;\nexport function isVoidPattern<Opts extends Options<t.VoidPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VoidPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSParameterProperty(\n  node: t.Node | null | undefined,\n): node is t.TSParameterProperty;\nexport function isTSParameterProperty<\n  Opts extends Options<t.TSParameterProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSParameterProperty & Opts;\nexport function isTSParameterProperty<\n  Opts extends Options<t.TSParameterProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSParameterProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSDeclareFunction(\n  node: t.Node | null | undefined,\n): node is t.TSDeclareFunction;\nexport function isTSDeclareFunction<Opts extends Options<t.TSDeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSDeclareFunction & Opts;\nexport function isTSDeclareFunction<Opts extends Options<t.TSDeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSDeclareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSDeclareMethod(\n  node: t.Node | null | undefined,\n): node is t.TSDeclareMethod;\nexport function isTSDeclareMethod<Opts extends Options<t.TSDeclareMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSDeclareMethod & Opts;\nexport function isTSDeclareMethod<Opts extends Options<t.TSDeclareMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSDeclareMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSQualifiedName(\n  node: t.Node | null | undefined,\n): node is t.TSQualifiedName;\nexport function isTSQualifiedName<Opts extends Options<t.TSQualifiedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSQualifiedName & Opts;\nexport function isTSQualifiedName<Opts extends Options<t.TSQualifiedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSQualifiedName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSCallSignatureDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSCallSignatureDeclaration;\nexport function isTSCallSignatureDeclaration<\n  Opts extends Options<t.TSCallSignatureDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSCallSignatureDeclaration & Opts;\nexport function isTSCallSignatureDeclaration<\n  Opts extends Options<t.TSCallSignatureDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSCallSignatureDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConstructSignatureDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSConstructSignatureDeclaration;\nexport function isTSConstructSignatureDeclaration<\n  Opts extends Options<t.TSConstructSignatureDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConstructSignatureDeclaration & Opts;\nexport function isTSConstructSignatureDeclaration<\n  Opts extends Options<t.TSConstructSignatureDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConstructSignatureDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSPropertySignature(\n  node: t.Node | null | undefined,\n): node is t.TSPropertySignature;\nexport function isTSPropertySignature<\n  Opts extends Options<t.TSPropertySignature>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSPropertySignature & Opts;\nexport function isTSPropertySignature<\n  Opts extends Options<t.TSPropertySignature>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSPropertySignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSMethodSignature(\n  node: t.Node | null | undefined,\n): node is t.TSMethodSignature;\nexport function isTSMethodSignature<Opts extends Options<t.TSMethodSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSMethodSignature & Opts;\nexport function isTSMethodSignature<Opts extends Options<t.TSMethodSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSMethodSignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIndexSignature(\n  node: t.Node | null | undefined,\n): node is t.TSIndexSignature;\nexport function isTSIndexSignature<Opts extends Options<t.TSIndexSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIndexSignature & Opts;\nexport function isTSIndexSignature<Opts extends Options<t.TSIndexSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIndexSignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSAnyKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSAnyKeyword;\nexport function isTSAnyKeyword<Opts extends Options<t.TSAnyKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSAnyKeyword & Opts;\nexport function isTSAnyKeyword<Opts extends Options<t.TSAnyKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSAnyKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBooleanKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSBooleanKeyword;\nexport function isTSBooleanKeyword<Opts extends Options<t.TSBooleanKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBooleanKeyword & Opts;\nexport function isTSBooleanKeyword<Opts extends Options<t.TSBooleanKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSBooleanKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBigIntKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSBigIntKeyword;\nexport function isTSBigIntKeyword<Opts extends Options<t.TSBigIntKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBigIntKeyword & Opts;\nexport function isTSBigIntKeyword<Opts extends Options<t.TSBigIntKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSBigIntKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIntrinsicKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSIntrinsicKeyword;\nexport function isTSIntrinsicKeyword<\n  Opts extends Options<t.TSIntrinsicKeyword>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIntrinsicKeyword & Opts;\nexport function isTSIntrinsicKeyword<\n  Opts extends Options<t.TSIntrinsicKeyword>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIntrinsicKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNeverKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNeverKeyword;\nexport function isTSNeverKeyword<Opts extends Options<t.TSNeverKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNeverKeyword & Opts;\nexport function isTSNeverKeyword<Opts extends Options<t.TSNeverKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNeverKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNullKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNullKeyword;\nexport function isTSNullKeyword<Opts extends Options<t.TSNullKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNullKeyword & Opts;\nexport function isTSNullKeyword<Opts extends Options<t.TSNullKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNullKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNumberKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNumberKeyword;\nexport function isTSNumberKeyword<Opts extends Options<t.TSNumberKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNumberKeyword & Opts;\nexport function isTSNumberKeyword<Opts extends Options<t.TSNumberKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNumberKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSObjectKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSObjectKeyword;\nexport function isTSObjectKeyword<Opts extends Options<t.TSObjectKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSObjectKeyword & Opts;\nexport function isTSObjectKeyword<Opts extends Options<t.TSObjectKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSObjectKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSStringKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSStringKeyword;\nexport function isTSStringKeyword<Opts extends Options<t.TSStringKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSStringKeyword & Opts;\nexport function isTSStringKeyword<Opts extends Options<t.TSStringKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSStringKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSSymbolKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSSymbolKeyword;\nexport function isTSSymbolKeyword<Opts extends Options<t.TSSymbolKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSSymbolKeyword & Opts;\nexport function isTSSymbolKeyword<Opts extends Options<t.TSSymbolKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSSymbolKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUndefinedKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSUndefinedKeyword;\nexport function isTSUndefinedKeyword<\n  Opts extends Options<t.TSUndefinedKeyword>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUndefinedKeyword & Opts;\nexport function isTSUndefinedKeyword<\n  Opts extends Options<t.TSUndefinedKeyword>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUndefinedKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUnknownKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSUnknownKeyword;\nexport function isTSUnknownKeyword<Opts extends Options<t.TSUnknownKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUnknownKeyword & Opts;\nexport function isTSUnknownKeyword<Opts extends Options<t.TSUnknownKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUnknownKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSVoidKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSVoidKeyword;\nexport function isTSVoidKeyword<Opts extends Options<t.TSVoidKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSVoidKeyword & Opts;\nexport function isTSVoidKeyword<Opts extends Options<t.TSVoidKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSVoidKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSThisType(\n  node: t.Node | null | undefined,\n): node is t.TSThisType;\nexport function isTSThisType<Opts extends Options<t.TSThisType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSThisType & Opts;\nexport function isTSThisType<Opts extends Options<t.TSThisType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSThisType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSFunctionType(\n  node: t.Node | null | undefined,\n): node is t.TSFunctionType;\nexport function isTSFunctionType<Opts extends Options<t.TSFunctionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSFunctionType & Opts;\nexport function isTSFunctionType<Opts extends Options<t.TSFunctionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSFunctionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConstructorType(\n  node: t.Node | null | undefined,\n): node is t.TSConstructorType;\nexport function isTSConstructorType<Opts extends Options<t.TSConstructorType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConstructorType & Opts;\nexport function isTSConstructorType<Opts extends Options<t.TSConstructorType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConstructorType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeReference(\n  node: t.Node | null | undefined,\n): node is t.TSTypeReference;\nexport function isTSTypeReference<Opts extends Options<t.TSTypeReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeReference & Opts;\nexport function isTSTypeReference<Opts extends Options<t.TSTypeReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypePredicate(\n  node: t.Node | null | undefined,\n): node is t.TSTypePredicate;\nexport function isTSTypePredicate<Opts extends Options<t.TSTypePredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypePredicate & Opts;\nexport function isTSTypePredicate<Opts extends Options<t.TSTypePredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypePredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeQuery(\n  node: t.Node | null | undefined,\n): node is t.TSTypeQuery;\nexport function isTSTypeQuery<Opts extends Options<t.TSTypeQuery>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeQuery & Opts;\nexport function isTSTypeQuery<Opts extends Options<t.TSTypeQuery>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeQuery\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeLiteral(\n  node: t.Node | null | undefined,\n): node is t.TSTypeLiteral;\nexport function isTSTypeLiteral<Opts extends Options<t.TSTypeLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeLiteral & Opts;\nexport function isTSTypeLiteral<Opts extends Options<t.TSTypeLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSArrayType(\n  node: t.Node | null | undefined,\n): node is t.TSArrayType;\nexport function isTSArrayType<Opts extends Options<t.TSArrayType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSArrayType & Opts;\nexport function isTSArrayType<Opts extends Options<t.TSArrayType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSArrayType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTupleType(\n  node: t.Node | null | undefined,\n): node is t.TSTupleType;\nexport function isTSTupleType<Opts extends Options<t.TSTupleType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTupleType & Opts;\nexport function isTSTupleType<Opts extends Options<t.TSTupleType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTupleType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSOptionalType(\n  node: t.Node | null | undefined,\n): node is t.TSOptionalType;\nexport function isTSOptionalType<Opts extends Options<t.TSOptionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSOptionalType & Opts;\nexport function isTSOptionalType<Opts extends Options<t.TSOptionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSOptionalType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSRestType(\n  node: t.Node | null | undefined,\n): node is t.TSRestType;\nexport function isTSRestType<Opts extends Options<t.TSRestType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSRestType & Opts;\nexport function isTSRestType<Opts extends Options<t.TSRestType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSRestType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNamedTupleMember(\n  node: t.Node | null | undefined,\n): node is t.TSNamedTupleMember;\nexport function isTSNamedTupleMember<\n  Opts extends Options<t.TSNamedTupleMember>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNamedTupleMember & Opts;\nexport function isTSNamedTupleMember<\n  Opts extends Options<t.TSNamedTupleMember>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNamedTupleMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUnionType(\n  node: t.Node | null | undefined,\n): node is t.TSUnionType;\nexport function isTSUnionType<Opts extends Options<t.TSUnionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUnionType & Opts;\nexport function isTSUnionType<Opts extends Options<t.TSUnionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUnionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIntersectionType(\n  node: t.Node | null | undefined,\n): node is t.TSIntersectionType;\nexport function isTSIntersectionType<\n  Opts extends Options<t.TSIntersectionType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIntersectionType & Opts;\nexport function isTSIntersectionType<\n  Opts extends Options<t.TSIntersectionType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIntersectionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConditionalType(\n  node: t.Node | null | undefined,\n): node is t.TSConditionalType;\nexport function isTSConditionalType<Opts extends Options<t.TSConditionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConditionalType & Opts;\nexport function isTSConditionalType<Opts extends Options<t.TSConditionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConditionalType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInferType(\n  node: t.Node | null | undefined,\n): node is t.TSInferType;\nexport function isTSInferType<Opts extends Options<t.TSInferType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInferType & Opts;\nexport function isTSInferType<Opts extends Options<t.TSInferType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInferType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSParenthesizedType(\n  node: t.Node | null | undefined,\n): node is t.TSParenthesizedType;\nexport function isTSParenthesizedType<\n  Opts extends Options<t.TSParenthesizedType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSParenthesizedType & Opts;\nexport function isTSParenthesizedType<\n  Opts extends Options<t.TSParenthesizedType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSParenthesizedType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeOperator(\n  node: t.Node | null | undefined,\n): node is t.TSTypeOperator;\nexport function isTSTypeOperator<Opts extends Options<t.TSTypeOperator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeOperator & Opts;\nexport function isTSTypeOperator<Opts extends Options<t.TSTypeOperator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeOperator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.TSIndexedAccessType;\nexport function isTSIndexedAccessType<\n  Opts extends Options<t.TSIndexedAccessType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIndexedAccessType & Opts;\nexport function isTSIndexedAccessType<\n  Opts extends Options<t.TSIndexedAccessType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSMappedType(\n  node: t.Node | null | undefined,\n): node is t.TSMappedType;\nexport function isTSMappedType<Opts extends Options<t.TSMappedType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSMappedType & Opts;\nexport function isTSMappedType<Opts extends Options<t.TSMappedType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSMappedType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTemplateLiteralType(\n  node: t.Node | null | undefined,\n): node is t.TSTemplateLiteralType;\nexport function isTSTemplateLiteralType<\n  Opts extends Options<t.TSTemplateLiteralType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTemplateLiteralType & Opts;\nexport function isTSTemplateLiteralType<\n  Opts extends Options<t.TSTemplateLiteralType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTemplateLiteralType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSLiteralType(\n  node: t.Node | null | undefined,\n): node is t.TSLiteralType;\nexport function isTSLiteralType<Opts extends Options<t.TSLiteralType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSLiteralType & Opts;\nexport function isTSLiteralType<Opts extends Options<t.TSLiteralType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSLiteralType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSClassImplements(\n  node: t.Node | null | undefined,\n): node is t.TSClassImplements;\nexport function isTSClassImplements<Opts extends Options<t.TSClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSClassImplements & Opts;\nexport function isTSClassImplements<Opts extends Options<t.TSClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSClassImplements\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceHeritage(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceHeritage;\nexport function isTSInterfaceHeritage<\n  Opts extends Options<t.TSInterfaceHeritage>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInterfaceHeritage & Opts;\nexport function isTSInterfaceHeritage<\n  Opts extends Options<t.TSInterfaceHeritage>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceHeritage\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceDeclaration;\nexport function isTSInterfaceDeclaration<\n  Opts extends Options<t.TSInterfaceDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInterfaceDeclaration & Opts;\nexport function isTSInterfaceDeclaration<\n  Opts extends Options<t.TSInterfaceDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceBody(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceBody;\nexport function isTSInterfaceBody<Opts extends Options<t.TSInterfaceBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInterfaceBody & Opts;\nexport function isTSInterfaceBody<Opts extends Options<t.TSInterfaceBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAliasDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAliasDeclaration;\nexport function isTSTypeAliasDeclaration<\n  Opts extends Options<t.TSTypeAliasDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAliasDeclaration & Opts;\nexport function isTSTypeAliasDeclaration<\n  Opts extends Options<t.TSTypeAliasDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAliasDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInstantiationExpression(\n  node: t.Node | null | undefined,\n): node is t.TSInstantiationExpression;\nexport function isTSInstantiationExpression<\n  Opts extends Options<t.TSInstantiationExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInstantiationExpression & Opts;\nexport function isTSInstantiationExpression<\n  Opts extends Options<t.TSInstantiationExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInstantiationExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSAsExpression(\n  node: t.Node | null | undefined,\n): node is t.TSAsExpression;\nexport function isTSAsExpression<Opts extends Options<t.TSAsExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSAsExpression & Opts;\nexport function isTSAsExpression<Opts extends Options<t.TSAsExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSAsExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSSatisfiesExpression(\n  node: t.Node | null | undefined,\n): node is t.TSSatisfiesExpression;\nexport function isTSSatisfiesExpression<\n  Opts extends Options<t.TSSatisfiesExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSSatisfiesExpression & Opts;\nexport function isTSSatisfiesExpression<\n  Opts extends Options<t.TSSatisfiesExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSSatisfiesExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAssertion(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAssertion;\nexport function isTSTypeAssertion<Opts extends Options<t.TSTypeAssertion>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAssertion & Opts;\nexport function isTSTypeAssertion<Opts extends Options<t.TSTypeAssertion>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAssertion\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumBody(\n  node: t.Node | null | undefined,\n): node is t.TSEnumBody;\nexport function isTSEnumBody<Opts extends Options<t.TSEnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumBody & Opts;\nexport function isTSEnumBody<Opts extends Options<t.TSEnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSEnumDeclaration;\nexport function isTSEnumDeclaration<Opts extends Options<t.TSEnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumDeclaration & Opts;\nexport function isTSEnumDeclaration<Opts extends Options<t.TSEnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumMember(\n  node: t.Node | null | undefined,\n): node is t.TSEnumMember;\nexport function isTSEnumMember<Opts extends Options<t.TSEnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumMember & Opts;\nexport function isTSEnumMember<Opts extends Options<t.TSEnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSModuleDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSModuleDeclaration;\nexport function isTSModuleDeclaration<\n  Opts extends Options<t.TSModuleDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSModuleDeclaration & Opts;\nexport function isTSModuleDeclaration<\n  Opts extends Options<t.TSModuleDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSModuleDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSModuleBlock(\n  node: t.Node | null | undefined,\n): node is t.TSModuleBlock;\nexport function isTSModuleBlock<Opts extends Options<t.TSModuleBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSModuleBlock & Opts;\nexport function isTSModuleBlock<Opts extends Options<t.TSModuleBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSModuleBlock\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSImportType(\n  node: t.Node | null | undefined,\n): node is t.TSImportType;\nexport function isTSImportType<Opts extends Options<t.TSImportType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSImportType & Opts;\nexport function isTSImportType<Opts extends Options<t.TSImportType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSImportType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSImportEqualsDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSImportEqualsDeclaration;\nexport function isTSImportEqualsDeclaration<\n  Opts extends Options<t.TSImportEqualsDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSImportEqualsDeclaration & Opts;\nexport function isTSImportEqualsDeclaration<\n  Opts extends Options<t.TSImportEqualsDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSImportEqualsDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExternalModuleReference(\n  node: t.Node | null | undefined,\n): node is t.TSExternalModuleReference;\nexport function isTSExternalModuleReference<\n  Opts extends Options<t.TSExternalModuleReference>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSExternalModuleReference & Opts;\nexport function isTSExternalModuleReference<\n  Opts extends Options<t.TSExternalModuleReference>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSExternalModuleReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNonNullExpression(\n  node: t.Node | null | undefined,\n): node is t.TSNonNullExpression;\nexport function isTSNonNullExpression<\n  Opts extends Options<t.TSNonNullExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNonNullExpression & Opts;\nexport function isTSNonNullExpression<\n  Opts extends Options<t.TSNonNullExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNonNullExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExportAssignment(\n  node: t.Node | null | undefined,\n): node is t.TSExportAssignment;\nexport function isTSExportAssignment<\n  Opts extends Options<t.TSExportAssignment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSExportAssignment & Opts;\nexport function isTSExportAssignment<\n  Opts extends Options<t.TSExportAssignment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSExportAssignment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNamespaceExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSNamespaceExportDeclaration;\nexport function isTSNamespaceExportDeclaration<\n  Opts extends Options<t.TSNamespaceExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNamespaceExportDeclaration & Opts;\nexport function isTSNamespaceExportDeclaration<\n  Opts extends Options<t.TSNamespaceExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNamespaceExportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAnnotation;\nexport function isTSTypeAnnotation<Opts extends Options<t.TSTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAnnotation & Opts;\nexport function isTSTypeAnnotation<Opts extends Options<t.TSTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameterInstantiation;\nexport function isTSTypeParameterInstantiation<\n  Opts extends Options<t.TSTypeParameterInstantiation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameterInstantiation & Opts;\nexport function isTSTypeParameterInstantiation<\n  Opts extends Options<t.TSTypeParameterInstantiation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameterInstantiation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameterDeclaration;\nexport function isTSTypeParameterDeclaration<\n  Opts extends Options<t.TSTypeParameterDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameterDeclaration & Opts;\nexport function isTSTypeParameterDeclaration<\n  Opts extends Options<t.TSTypeParameterDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameterDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameter(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameter;\nexport function isTSTypeParameter<Opts extends Options<t.TSTypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameter & Opts;\nexport function isTSTypeParameter<Opts extends Options<t.TSTypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameter\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStandardized(\n  node: t.Node | null | undefined,\n): node is t.Standardized;\nexport function isStandardized<Opts extends Options<t.Standardized>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Standardized & Opts;\nexport function isStandardized<Opts extends Options<t.Standardized>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"InterpreterDirective\":\n    case \"Directive\":\n    case \"DirectiveLiteral\":\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"CallExpression\":\n    case \"CatchClause\":\n    case \"ConditionalExpression\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"File\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"Program\":\n    case \"ObjectExpression\":\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"RestElement\":\n    case \"ReturnStatement\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"SwitchCase\":\n    case \"SwitchStatement\":\n    case \"ThisExpression\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"VariableDeclaration\":\n    case \"VariableDeclarator\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassBody\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ExportSpecifier\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"ClassMethod\":\n    case \"ObjectPattern\":\n    case \"SpreadElement\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateElement\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"ExportNamespaceSpecifier\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n    case \"StaticBlock\":\n    case \"ImportAttribute\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Identifier\":\n        case \"StringLiteral\":\n        case \"BlockStatement\":\n        case \"ClassBody\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpression(\n  node: t.Node | null | undefined,\n): node is t.Expression;\nexport function isExpression<Opts extends Options<t.Expression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Expression & Opts;\nexport function isExpression<Opts extends Options<t.Expression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"CallExpression\":\n    case \"ConditionalExpression\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"ObjectExpression\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"ThisExpression\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"TypeCastExpression\":\n    case \"JSXElement\":\n    case \"JSXFragment\":\n    case \"BindExpression\":\n    case \"DoExpression\":\n    case \"ModuleExpression\":\n    case \"TopicReference\":\n    case \"PipelineTopicExpression\":\n    case \"PipelineBareFunction\":\n    case \"PipelinePrimaryTopicReference\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Expression\":\n        case \"Identifier\":\n        case \"StringLiteral\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBinary(node: t.Node | null | undefined): node is t.Binary;\nexport function isBinary<Opts extends Options<t.Binary>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Binary & Opts;\nexport function isBinary<Opts extends Options<t.Binary>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isScopable(node: t.Node | null | undefined): node is t.Scopable;\nexport function isScopable<Opts extends Options<t.Scopable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Scopable & Opts;\nexport function isScopable<Opts extends Options<t.Scopable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlockParent(\n  node: t.Node | null | undefined,\n): node is t.BlockParent;\nexport function isBlockParent<Opts extends Options<t.BlockParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BlockParent & Opts;\nexport function isBlockParent<Opts extends Options<t.BlockParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlock(node: t.Node | null | undefined): node is t.Block;\nexport function isBlock<Opts extends Options<t.Block>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Block & Opts;\nexport function isBlock<Opts extends Options<t.Block>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"Program\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStatement(\n  node: t.Node | null | undefined,\n): node is t.Statement;\nexport function isStatement<Opts extends Options<t.Statement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Statement & Opts;\nexport function isStatement<Opts extends Options<t.Statement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"ReturnStatement\":\n    case \"SwitchStatement\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"VariableDeclaration\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Statement\":\n        case \"Declaration\":\n        case \"BlockStatement\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTerminatorless(\n  node: t.Node | null | undefined,\n): node is t.Terminatorless;\nexport function isTerminatorless<Opts extends Options<t.Terminatorless>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Terminatorless & Opts;\nexport function isTerminatorless<Opts extends Options<t.Terminatorless>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCompletionStatement(\n  node: t.Node | null | undefined,\n): node is t.CompletionStatement;\nexport function isCompletionStatement<\n  Opts extends Options<t.CompletionStatement>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CompletionStatement & Opts;\nexport function isCompletionStatement<\n  Opts extends Options<t.CompletionStatement>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isConditional(\n  node: t.Node | null | undefined,\n): node is t.Conditional;\nexport function isConditional<Opts extends Options<t.Conditional>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Conditional & Opts;\nexport function isConditional<Opts extends Options<t.Conditional>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLoop(node: t.Node | null | undefined): node is t.Loop;\nexport function isLoop<Opts extends Options<t.Loop>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Loop & Opts;\nexport function isLoop<Opts extends Options<t.Loop>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"WhileStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWhile(node: t.Node | null | undefined): node is t.While;\nexport function isWhile<Opts extends Options<t.While>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.While & Opts;\nexport function isWhile<Opts extends Options<t.While>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"WhileStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpressionWrapper(\n  node: t.Node | null | undefined,\n): node is t.ExpressionWrapper;\nexport function isExpressionWrapper<Opts extends Options<t.ExpressionWrapper>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExpressionWrapper & Opts;\nexport function isExpressionWrapper<Opts extends Options<t.ExpressionWrapper>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExpressionStatement\":\n    case \"ParenthesizedExpression\":\n    case \"TypeCastExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFor(node: t.Node | null | undefined): node is t.For;\nexport function isFor<Opts extends Options<t.For>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.For & Opts;\nexport function isFor<Opts extends Options<t.For>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForXStatement(\n  node: t.Node | null | undefined,\n): node is t.ForXStatement;\nexport function isForXStatement<Opts extends Options<t.ForXStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForXStatement & Opts;\nexport function isForXStatement<Opts extends Options<t.ForXStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunction(node: t.Node | null | undefined): node is t.Function;\nexport function isFunction<Opts extends Options<t.Function>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Function & Opts;\nexport function isFunction<Opts extends Options<t.Function>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionParent(\n  node: t.Node | null | undefined,\n): node is t.FunctionParent;\nexport function isFunctionParent<Opts extends Options<t.FunctionParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionParent & Opts;\nexport function isFunctionParent<Opts extends Options<t.FunctionParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPureish(node: t.Node | null | undefined): node is t.Pureish;\nexport function isPureish<Opts extends Options<t.Pureish>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Pureish & Opts;\nexport function isPureish<Opts extends Options<t.Pureish>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"ArrowFunctionExpression\":\n    case \"BigIntLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclaration(\n  node: t.Node | null | undefined,\n): node is t.Declaration;\nexport function isDeclaration<Opts extends Options<t.Declaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Declaration & Opts;\nexport function isDeclaration<Opts extends Options<t.Declaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"VariableDeclaration\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Declaration\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionParameter(\n  node: t.Node | null | undefined,\n): node is t.FunctionParameter;\nexport function isFunctionParameter<Opts extends Options<t.FunctionParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionParameter & Opts;\nexport function isFunctionParameter<Opts extends Options<t.FunctionParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPatternLike(\n  node: t.Node | null | undefined,\n): node is t.PatternLike;\nexport function isPatternLike<Opts extends Options<t.PatternLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PatternLike & Opts;\nexport function isPatternLike<Opts extends Options<t.PatternLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLVal(node: t.Node | null | undefined): node is t.LVal;\nexport function isLVal<Opts extends Options<t.LVal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LVal & Opts;\nexport function isLVal<Opts extends Options<t.LVal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEntityName(\n  node: t.Node | null | undefined,\n): node is t.TSEntityName;\nexport function isTSEntityName<Opts extends Options<t.TSEntityName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEntityName & Opts;\nexport function isTSEntityName<Opts extends Options<t.TSEntityName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"ThisExpression\":\n    case \"TSQualifiedName\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLiteral(node: t.Node | null | undefined): node is t.Literal;\nexport function isLiteral<Opts extends Options<t.Literal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Literal & Opts;\nexport function isLiteral<Opts extends Options<t.Literal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"TemplateLiteral\":\n    case \"BigIntLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImmutable(\n  node: t.Node | null | undefined,\n): node is t.Immutable;\nexport function isImmutable<Opts extends Options<t.Immutable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Immutable & Opts;\nexport function isImmutable<Opts extends Options<t.Immutable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"BigIntLiteral\":\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXOpeningElement\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUserWhitespacable(\n  node: t.Node | null | undefined,\n): node is t.UserWhitespacable;\nexport function isUserWhitespacable<Opts extends Options<t.UserWhitespacable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UserWhitespacable & Opts;\nexport function isUserWhitespacable<Opts extends Options<t.UserWhitespacable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMethod(node: t.Node | null | undefined): node is t.Method;\nexport function isMethod<Opts extends Options<t.Method>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Method & Opts;\nexport function isMethod<Opts extends Options<t.Method>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectMember(\n  node: t.Node | null | undefined,\n): node is t.ObjectMember;\nexport function isObjectMember<Opts extends Options<t.ObjectMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectMember & Opts;\nexport function isObjectMember<Opts extends Options<t.ObjectMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isProperty(node: t.Node | null | undefined): node is t.Property;\nexport function isProperty<Opts extends Options<t.Property>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Property & Opts;\nexport function isProperty<Opts extends Options<t.Property>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectProperty\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnaryLike(\n  node: t.Node | null | undefined,\n): node is t.UnaryLike;\nexport function isUnaryLike<Opts extends Options<t.UnaryLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnaryLike & Opts;\nexport function isUnaryLike<Opts extends Options<t.UnaryLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPattern(node: t.Node | null | undefined): node is t.Pattern;\nexport function isPattern<Opts extends Options<t.Pattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Pattern & Opts;\nexport function isPattern<Opts extends Options<t.Pattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Pattern\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClass(node: t.Node | null | undefined): node is t.Class;\nexport function isClass<Opts extends Options<t.Class>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Class & Opts;\nexport function isClass<Opts extends Options<t.Class>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportOrExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ImportOrExportDeclaration;\nexport function isImportOrExportDeclaration<\n  Opts extends Options<t.ImportOrExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportOrExportDeclaration & Opts;\nexport function isImportOrExportDeclaration<\n  Opts extends Options<t.ImportOrExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportDeclaration;\nexport function isExportDeclaration<Opts extends Options<t.ExportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDeclaration & Opts;\nexport function isExportDeclaration<Opts extends Options<t.ExportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isModuleSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ModuleSpecifier;\nexport function isModuleSpecifier<Opts extends Options<t.ModuleSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ModuleSpecifier & Opts;\nexport function isModuleSpecifier<Opts extends Options<t.ModuleSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAccessor(node: t.Node | null | undefined): node is t.Accessor;\nexport function isAccessor<Opts extends Options<t.Accessor>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Accessor & Opts;\nexport function isAccessor<Opts extends Options<t.Accessor>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPrivate(node: t.Node | null | undefined): node is t.Private;\nexport function isPrivate<Opts extends Options<t.Private>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Private & Opts;\nexport function isPrivate<Opts extends Options<t.Private>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlow(node: t.Node | null | undefined): node is t.Flow;\nexport function isFlow<Opts extends Options<t.Flow>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Flow & Opts;\nexport function isFlow<Opts extends Options<t.Flow>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ClassImplements\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclaredPredicate\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"FunctionTypeParam\":\n    case \"GenericTypeAnnotation\":\n    case \"InferredPredicate\":\n    case \"InterfaceExtends\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"OpaqueType\":\n    case \"QualifiedTypeIdentifier\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"TypeAlias\":\n    case \"TypeAnnotation\":\n    case \"TypeCastExpression\":\n    case \"TypeParameter\":\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n    case \"UnionTypeAnnotation\":\n    case \"Variance\":\n    case \"VoidTypeAnnotation\":\n    case \"EnumDeclaration\":\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowType(node: t.Node | null | undefined): node is t.FlowType;\nexport function isFlowType<Opts extends Options<t.FlowType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowType & Opts;\nexport function isFlowType<Opts extends Options<t.FlowType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"GenericTypeAnnotation\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowBaseAnnotation(\n  node: t.Node | null | undefined,\n): node is t.FlowBaseAnnotation;\nexport function isFlowBaseAnnotation<\n  Opts extends Options<t.FlowBaseAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowBaseAnnotation & Opts;\nexport function isFlowBaseAnnotation<\n  Opts extends Options<t.FlowBaseAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowDeclaration(\n  node: t.Node | null | undefined,\n): node is t.FlowDeclaration;\nexport function isFlowDeclaration<Opts extends Options<t.FlowDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowDeclaration & Opts;\nexport function isFlowDeclaration<Opts extends Options<t.FlowDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowPredicate(\n  node: t.Node | null | undefined,\n): node is t.FlowPredicate;\nexport function isFlowPredicate<Opts extends Options<t.FlowPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowPredicate & Opts;\nexport function isFlowPredicate<Opts extends Options<t.FlowPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DeclaredPredicate\":\n    case \"InferredPredicate\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBody(node: t.Node | null | undefined): node is t.EnumBody;\nexport function isEnumBody<Opts extends Options<t.EnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBody & Opts;\nexport function isEnumBody<Opts extends Options<t.EnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumMember(\n  node: t.Node | null | undefined,\n): node is t.EnumMember;\nexport function isEnumMember<Opts extends Options<t.EnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumMember & Opts;\nexport function isEnumMember<Opts extends Options<t.EnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSX(node: t.Node | null | undefined): node is t.JSX;\nexport function isJSX<Opts extends Options<t.JSX>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSX & Opts;\nexport function isJSX<Opts extends Options<t.JSX>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXEmptyExpression\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXIdentifier\":\n    case \"JSXMemberExpression\":\n    case \"JSXNamespacedName\":\n    case \"JSXOpeningElement\":\n    case \"JSXSpreadAttribute\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMiscellaneous(\n  node: t.Node | null | undefined,\n): node is t.Miscellaneous;\nexport function isMiscellaneous<Opts extends Options<t.Miscellaneous>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Miscellaneous & Opts;\nexport function isMiscellaneous<Opts extends Options<t.Miscellaneous>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Placeholder\":\n    case \"V8IntrinsicIdentifier\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeScript(\n  node: t.Node | null | undefined,\n): node is t.TypeScript;\nexport function isTypeScript<Opts extends Options<t.TypeScript>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeScript & Opts;\nexport function isTypeScript<Opts extends Options<t.TypeScript>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSParameterProperty\":\n    case \"TSDeclareFunction\":\n    case \"TSDeclareMethod\":\n    case \"TSQualifiedName\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSNamedTupleMember\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSClassImplements\":\n    case \"TSInterfaceHeritage\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSEnumBody\":\n    case \"TSEnumDeclaration\":\n    case \"TSEnumMember\":\n    case \"TSModuleDeclaration\":\n    case \"TSModuleBlock\":\n    case \"TSImportType\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExternalModuleReference\":\n    case \"TSNonNullExpression\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n    case \"TSTypeAnnotation\":\n    case \"TSTypeParameterInstantiation\":\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameter\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeElement(\n  node: t.Node | null | undefined,\n): node is t.TSTypeElement;\nexport function isTSTypeElement<Opts extends Options<t.TSTypeElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeElement & Opts;\nexport function isTSTypeElement<Opts extends Options<t.TSTypeElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSType(node: t.Node | null | undefined): node is t.TSType;\nexport function isTSType<Opts extends Options<t.TSType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSType & Opts;\nexport function isTSType<Opts extends Options<t.TSType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSClassImplements\":\n    case \"TSInterfaceHeritage\":\n    case \"TSImportType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBaseType(\n  node: t.Node | null | undefined,\n): node is t.TSBaseType;\nexport function isTSBaseType<Opts extends Options<t.TSBaseType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBaseType & Opts;\nexport function isTSBaseType<Opts extends Options<t.TSBaseType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isNumericLiteral`\n */\nexport function isNumberLiteral(node: t.Node | null | undefined): boolean;\nexport function isNumberLiteral<Opts extends Options<t.NumberLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isNumberLiteral<Opts extends Options<t.NumberLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isNumberLiteral\", \"isNumericLiteral\");\n  if (!node) return false;\n\n  if (node.type !== \"NumberLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isRegExpLiteral`\n */\nexport function isRegexLiteral(node: t.Node | null | undefined): boolean;\nexport function isRegexLiteral<Opts extends Options<t.RegexLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isRegexLiteral<Opts extends Options<t.RegexLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isRegexLiteral\", \"isRegExpLiteral\");\n  if (!node) return false;\n\n  if (node.type !== \"RegexLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isRestElement`\n */\nexport function isRestProperty(node: t.Node | null | undefined): boolean;\nexport function isRestProperty<Opts extends Options<t.RestProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isRestProperty<Opts extends Options<t.RestProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isRestProperty\", \"isRestElement\");\n  if (!node) return false;\n\n  if (node.type !== \"RestProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isSpreadElement`\n */\nexport function isSpreadProperty(node: t.Node | null | undefined): boolean;\nexport function isSpreadProperty<Opts extends Options<t.SpreadProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isSpreadProperty<Opts extends Options<t.SpreadProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isSpreadProperty\", \"isSpreadElement\");\n  if (!node) return false;\n\n  if (node.type !== \"SpreadProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isImportOrExportDeclaration`\n */\nexport function isModuleDeclaration<Opts extends Options<t.ModuleDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportOrExportDeclaration & Opts {\n  deprecationWarning(\"isModuleDeclaration\", \"isImportOrExportDeclaration\");\n  return isImportOrExportDeclaration(node, opts);\n}\n","import {\n  isIdentifier,\n  isMetaProperty,\n  isMemberExpression,\n  isPrivateName,\n  isStringLiteral,\n  isSuper,\n  isThisExpression,\n} from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nfunction isMemberExpressionLike(\n  node: t.Node,\n): node is t.MemberExpression | t.MetaProperty {\n  return isMemberExpression(node) || isMetaProperty(node);\n}\n\n/**\n * Determines whether or not the input node `member` matches the\n * input `match`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\nexport default function matchesPattern(\n  member: t.Node | null | undefined,\n  match: string | string[],\n  allowPartial?: boolean,\n): boolean {\n  // not a member expression\n  if (!isMemberExpressionLike(member)) return false;\n\n  const parts = Array.isArray(match) ? match : match.split(\".\");\n  const nodes = [];\n\n  let node;\n  for (\n    node = member;\n    isMemberExpressionLike(node);\n    node = (node as t.MemberExpression).object ?? (node as t.MetaProperty).meta\n  ) {\n    nodes.push(node.property);\n  }\n  nodes.push(node);\n\n  if (nodes.length < parts.length) return false;\n  if (!allowPartial && nodes.length > parts.length) return false;\n\n  for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {\n    const node = nodes[j];\n    let value;\n    if (isIdentifier(node)) {\n      value = node.name;\n    } else if (isStringLiteral(node)) {\n      value = node.value;\n    } else if (isThisExpression(node)) {\n      value = \"this\";\n    } else if (isSuper(node)) {\n      value = \"super\";\n    } else if (isPrivateName(node)) {\n      value = \"#\" + node.id.name;\n    } else {\n      return false;\n    }\n\n    if (parts[i] !== value) return false;\n  }\n\n  return true;\n}\n","import matchesPattern from \"./matchesPattern.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Build a function that when called will return whether or not the\n * input `node` `MemberExpression` matches the input `match`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\nexport default function buildMatchMemberExpression(\n  match: string,\n  allowPartial?: boolean,\n) {\n  const parts = match.split(\".\");\n\n  return (member: t.Node) => matchesPattern(member, parts, allowPartial);\n}\n","import buildMatchMemberExpression from \"../buildMatchMemberExpression.ts\";\n\nconst isReactComponent = buildMatchMemberExpression(\"React.Component\");\n\nexport default isReactComponent;\n","export default function isCompatTag(tagName?: string): boolean {\n  // Must start with a lowercase ASCII letter\n  return !!tagName && /^[a-z]/.test(tagName);\n}\n","import { FLIPPED_ALIAS_KEYS, ALIAS_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function isType<T extends t.Node[\"type\"]>(\n  nodeType: string,\n  targetType: T,\n): nodeType is T;\n\nexport default function isType(\n  nodeType: string | null | undefined,\n  targetType: string,\n): boolean;\n\n/**\n * Test if a `nodeType` is a `targetType` or if `targetType` is an alias of `nodeType`.\n */\nexport default function isType(nodeType: string, targetType: string): boolean {\n  if (nodeType === targetType) return true;\n\n  // If nodeType is nullish, it can't be an alias of targetType.\n  if (nodeType == null) return false;\n\n  // This is a fast-path. If the test above failed, but an alias key is found, then the\n  // targetType was a primary node type, so there's no need to check the aliases.\n  // @ts-expect-error targetType may not index ALIAS_KEYS\n  if (ALIAS_KEYS[targetType]) return false;\n\n  const aliases: string[] | undefined = FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases?.includes(nodeType)) return true;\n\n  return false;\n}\n","import { PLACEHOLDERS_ALIAS } from \"../definitions/index.ts\";\n\n/**\n * Test if a `placeholderType` is a `targetType` or if `targetType` is an alias of `placeholderType`.\n */\nexport default function isPlaceholderType(\n  placeholderType: string,\n  targetType: string,\n): boolean {\n  if (placeholderType === targetType) return true;\n\n  const aliases: string[] | undefined = PLACEHOLDERS_ALIAS[placeholderType];\n  if (aliases?.includes(targetType)) return true;\n\n  return false;\n}\n","import shallowEqual from \"../utils/shallowEqual.ts\";\nimport isType from \"./isType.ts\";\nimport isPlaceholderType from \"./isPlaceholderType.ts\";\nimport { FLIPPED_ALIAS_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function is<T extends t.Node[\"type\"]>(\n  type: T,\n  node: t.Node | null | undefined,\n  opts?: undefined,\n): node is Extract<t.Node, { type: T }>;\n\nexport default function is<\n  T extends t.Node[\"type\"],\n  P extends Extract<t.Node, { type: T }>,\n>(type: T, n: t.Node | null | undefined, required: Partial<P>): n is P;\n\nexport default function is<P extends t.Node>(\n  type: string,\n  node: t.Node | null | undefined,\n  opts: Partial<P>,\n): node is P;\n\nexport default function is(\n  type: string,\n  node: t.Node | null | undefined,\n  opts?: Partial<t.Node>,\n): node is t.Node;\n/**\n * Returns whether `node` is of given `type`.\n *\n * For better performance, use this instead of `is[Type]` when `type` is unknown.\n */\nexport default function is(\n  type: string,\n  node: t.Node | null | undefined,\n  opts?: Partial<t.Node>,\n): node is t.Node {\n  if (!node) return false;\n\n  const matches = isType(node.type, type);\n  if (!matches) {\n    if (!opts && node.type === \"Placeholder\" && type in FLIPPED_ALIAS_KEYS) {\n      // We can only return true if the placeholder doesn't replace a real node,\n      // but it replaces a category of nodes (an alias).\n      //\n      // t.is(\"Identifier\", node) gives some guarantees about node's shape, so we\n      // can't say that Placeholder(expectedNode: \"Identifier\") is an identifier\n      // because it doesn't have the same properties.\n      // On the other hand, t.is(\"Expression\", node) doesn't say anything about\n      // the shape of node because Expression can be many different nodes: we can,\n      // and should, safely report expression placeholders as Expressions.\n      return isPlaceholderType(node.expectedNode, type);\n    }\n    return false;\n  }\n\n  if (opts === undefined) {\n    return true;\n  } else {\n    return shallowEqual(node, opts);\n  }\n}\n","import {\n  isIdentifierName,\n  isStrictReservedWord,\n  isKeyword,\n} from \"@babel/helper-validator-identifier\";\n\n/**\n * Check if the input `name` is a valid identifier name\n * and isn't a reserved word.\n */\nexport default function isValidIdentifier(\n  name: string,\n  reserved: boolean = true,\n): boolean {\n  if (typeof name !== \"string\") return false;\n\n  if (reserved) {\n    // \"await\" is invalid in module, valid in script; better be safe (see #4952)\n    if (isKeyword(name) || isStrictReservedWord(name, true)) {\n      return false;\n    }\n  }\n\n  return isIdentifierName(name);\n}\n","export const STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nexport const FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nexport const FOR_INIT_KEYS = [\"left\", \"init\"];\nexport const COMMENT_KEYS = [\n  \"leadingComments\",\n  \"trailingComments\",\n  \"innerComments\",\n] as const;\n\nexport const LOGICAL_OPERATORS = [\"||\", \"&&\", \"??\"];\nexport const UPDATE_OPERATORS = [\"++\", \"--\"];\n\nexport const BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nexport const EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nexport const COMPARISON_BINARY_OPERATORS = [\n  ...EQUALITY_BINARY_OPERATORS,\n  \"in\",\n  \"instanceof\",\n];\nexport const BOOLEAN_BINARY_OPERATORS = [\n  ...COMPARISON_BINARY_OPERATORS,\n  ...BOOLEAN_NUMBER_BINARY_OPERATORS,\n];\nexport const NUMBER_BINARY_OPERATORS = [\n  \"-\",\n  \"/\",\n  \"%\",\n  \"*\",\n  \"**\",\n  \"&\",\n  \"|\",\n  \">>\",\n  \">>>\",\n  \"<<\",\n  \"^\",\n];\nexport const BINARY_OPERATORS = [\n  \"+\",\n  ...NUMBER_BINARY_OPERATORS,\n  ...BOOLEAN_BINARY_OPERATORS,\n  \"|>\",\n];\n\nexport const ASSIGNMENT_OPERATORS = [\n  \"=\",\n  \"+=\",\n  ...NUMBER_BINARY_OPERATORS.map(op => op + \"=\"),\n  ...LOGICAL_OPERATORS.map(op => op + \"=\"),\n];\n\nexport const BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nexport const NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"~\"];\nexport const STRING_UNARY_OPERATORS = [\"typeof\"];\nexport const UNARY_OPERATORS = [\n  \"void\",\n  \"throw\",\n  ...BOOLEAN_UNARY_OPERATORS,\n  ...NUMBER_UNARY_OPERATORS,\n  ...STRING_UNARY_OPERATORS,\n];\n\nexport const INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"start\", \"loc\", \"end\"],\n} as const;\n","import is from \"../validators/is.ts\";\nimport { validateField, validateChild } from \"../validators/validate.ts\";\nimport type * as t from \"../index.ts\";\n\nexport const VISITOR_KEYS: Record<string, string[]> = {};\nexport const ALIAS_KEYS: Partial<Record<NodeTypesWithoutComment, string[]>> =\n  {};\nexport const FLIPPED_ALIAS_KEYS: Record<string, NodeTypesWithoutComment[]> = {};\nexport const NODE_FIELDS: Record<string, FieldDefinitions> = {};\nexport const BUILDER_KEYS: Record<string, string[]> = {};\nexport const DEPRECATED_KEYS: Record<string, NodeTypesWithoutComment> = {};\nexport const NODE_PARENT_VALIDATIONS: Record<string, Validator> = {};\nexport const NODE_UNION_SHAPES__PRIVATE: Record<string, UnionShape> = {};\n\nfunction getType(val: any) {\n  if (Array.isArray(val)) {\n    return \"array\";\n  } else if (val === null) {\n    return \"null\";\n  } else {\n    return typeof val;\n  }\n}\n\ntype NodeTypesWithoutComment = t.Node[\"type\"] | keyof t.Aliases;\n\ntype NodeTypes = NodeTypesWithoutComment | t.Comment[\"type\"];\n\ntype PrimitiveTypes = ReturnType<typeof getType>;\n\ntype FieldDefinitions = Record<string, FieldOptions>;\n\ntype UnionShape = {\n  discriminator: string;\n  shapes: {\n    name: string;\n    value: any[];\n    properties: Record<string, FieldOptions>;\n  }[];\n};\n\ntype DefineTypeOpts = {\n  fields?: FieldDefinitions;\n  visitor?: string[];\n  aliases?: string[];\n  builder?: string[];\n  inherits?: NodeTypes;\n  deprecatedAlias?: string;\n  validate?: Validator;\n  unionShape?: UnionShape;\n};\n\nexport type ValidatorImpl = (\n  node?: t.Node,\n  key?: string | { toString(): string },\n  val?: any,\n) => void;\n\nexport type ValidatorType = { type: PrimitiveTypes } & ValidatorImpl;\nexport type ValidatorEach = { each: Validator } & ValidatorImpl;\nexport type ValidatorChainOf = {\n  chainOf: readonly Validator[];\n} & ValidatorImpl;\nexport type ValidatorOneOf = { oneOf: readonly any[] } & ValidatorImpl;\nexport type ValidatorOneOfNodeTypes = {\n  oneOfNodeTypes: readonly NodeTypes[];\n} & ValidatorImpl;\nexport type ValidatorOneOfNodeOrValueTypes = {\n  oneOfNodeOrValueTypes: readonly (NodeTypes | PrimitiveTypes)[];\n} & ValidatorImpl;\nexport type ValidatorShapeOf = {\n  shapeOf: Record<string, FieldOptions>;\n} & ValidatorImpl;\n\nexport type Validator =\n  | ValidatorType\n  | ValidatorEach\n  | ValidatorChainOf\n  | ValidatorOneOf\n  | ValidatorOneOfNodeTypes\n  | ValidatorOneOfNodeOrValueTypes\n  | ValidatorShapeOf\n  | ValidatorImpl;\n\nexport type FieldOptions = {\n  default?: string | number | boolean | [];\n  optional?: boolean;\n  deprecated?: boolean;\n  validate?: Validator;\n};\n\nexport function validate(validate: Validator): FieldOptions {\n  return { validate };\n}\n\nexport function validateType(...typeNames: NodeTypes[]) {\n  return validate(assertNodeType(...typeNames));\n}\n\nexport function validateOptional(validate: Validator): FieldOptions {\n  return { validate, optional: true };\n}\n\nexport function validateOptionalType(...typeNames: NodeTypes[]): FieldOptions {\n  return { validate: assertNodeType(...typeNames), optional: true };\n}\n\nexport function arrayOf(elementType: Validator): Validator {\n  return chain(assertValueType(\"array\"), assertEach(elementType));\n}\n\nexport function arrayOfType(...typeNames: NodeTypes[]) {\n  return arrayOf(assertNodeType(...typeNames));\n}\n\nexport function validateArrayOfType(...typeNames: NodeTypes[]) {\n  return validate(arrayOfType(...typeNames));\n}\n\nexport function assertEach(callback: Validator): Validator {\n  const childValidator = validateChild;\n  function validator(node: t.Node, key: string, val: any) {\n    if (!Array.isArray(val)) return;\n\n    let i = 0;\n    // We lazily concatenate strings here for performance reasons.\n    // Concatenating the strings is expensive because we are actually concatenating a string and a number,\n    // so V8 cannot just create a \"rope string\" but has to allocate memory for the string resulting from the number\n    // This string is very rarely used, only in error paths, so we can skip the concatenation cost in most cases\n    const subKey = {\n      toString() {\n        return `${key}[${i}]`;\n      },\n    };\n\n    for (; i < val.length; i++) {\n      const v = val[i];\n      callback(node, subKey, v);\n      childValidator(node, subKey, v);\n    }\n  }\n  validator.each = callback;\n  return validator;\n}\n\nexport function assertOneOf(...values: any[]): Validator {\n  function validate(node: any, key: string, val: any) {\n    if (!values.includes(val)) {\n      throw new TypeError(\n        `Property ${key} expected value to be one of ${JSON.stringify(\n          values,\n        )} but got ${JSON.stringify(val)}`,\n      );\n    }\n  }\n\n  validate.oneOf = values;\n\n  return validate;\n}\n\nexport const allExpandedTypes: {\n  types: NodeTypes[];\n  set: Set<string>;\n}[] = [];\n\nexport function assertNodeType(...types: NodeTypes[]): Validator {\n  const expandedTypes = new Set<string>();\n\n  allExpandedTypes.push({ types, set: expandedTypes });\n\n  function validate(node: t.Node, key: string, val: any) {\n    const valType = val?.type;\n    if (valType != null) {\n      if (expandedTypes.has(valType)) {\n        validateChild(node, key, val);\n        return;\n      }\n      if (valType === \"Placeholder\") {\n        for (const type of types) {\n          if (is(type, val)) {\n            validateChild(node, key, val);\n            return;\n          }\n        }\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(valType)}`,\n    );\n  }\n\n  validate.oneOfNodeTypes = types;\n\n  return validate;\n}\n\nexport function assertNodeOrValueType(\n  ...types: (NodeTypes | PrimitiveTypes)[]\n): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    const primitiveType = getType(val);\n    for (const type of types) {\n      if (primitiveType === type || is(type, val)) {\n        validateChild(node, key, val);\n        return;\n      }\n    }\n\n    throw new TypeError(\n      `Property ${key} of ${\n        node.type\n      } expected node to be of a type ${JSON.stringify(\n        types,\n      )} but instead got ${JSON.stringify(val?.type)}`,\n    );\n  }\n\n  validate.oneOfNodeOrValueTypes = types;\n\n  return validate;\n}\n\nexport function assertValueType(type: PrimitiveTypes): Validator {\n  function validate(node: t.Node, key: string, val: any) {\n    if (getType(val) === type) {\n      return;\n    }\n\n    throw new TypeError(\n      `Property ${key} expected type of ${type} but got ${getType(val)}`,\n    );\n  }\n\n  validate.type = type;\n\n  return validate;\n}\n\nexport function assertShape(shape: Record<string, FieldOptions>): Validator {\n  const keys = Object.keys(shape);\n  function validate(node: t.Node, key: string, val: any) {\n    const errors = [];\n    for (const property of keys) {\n      try {\n        validateField(node, property, val[property], shape[property]);\n      } catch (error) {\n        if (error instanceof TypeError) {\n          errors.push(error.message);\n          continue;\n        }\n        throw error;\n      }\n    }\n    if (errors.length) {\n      throw new TypeError(\n        `Property ${key} of ${\n          node.type\n        } expected to have the following:\\n${errors.join(\"\\n\")}`,\n      );\n    }\n  }\n\n  validate.shapeOf = shape;\n\n  return validate;\n}\n\nexport function assertOptionalChainStart(): Validator {\n  function validate(node: t.Node) {\n    let current = node;\n    while (node) {\n      const { type } = current;\n      if (type === \"OptionalCallExpression\") {\n        if (current.optional) return;\n        current = current.callee;\n        continue;\n      }\n\n      if (type === \"OptionalMemberExpression\") {\n        if (current.optional) return;\n        current = current.object;\n        continue;\n      }\n\n      break;\n    }\n\n    throw new TypeError(\n      `Non-optional ${node.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${current?.type}`,\n    );\n  }\n\n  return validate;\n}\n\nexport function chain(...fns: Validator[]): Validator {\n  function validate(...args: Parameters<Validator>) {\n    for (const fn of fns) {\n      fn(...args);\n    }\n  }\n  validate.chainOf = fns;\n\n  if (\n    fns.length >= 2 &&\n    \"type\" in fns[0] &&\n    fns[0].type === \"array\" &&\n    !(\"each\" in fns[1])\n  ) {\n    throw new Error(\n      `An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.`,\n    );\n  }\n\n  return validate;\n}\n\nconst validTypeOpts = new Set([\n  \"aliases\",\n  \"builder\",\n  \"deprecatedAlias\",\n  \"fields\",\n  \"inherits\",\n  \"visitor\",\n  \"validate\",\n  \"unionShape\",\n]);\nconst validFieldKeys = new Set([\n  \"default\",\n  \"optional\",\n  \"deprecated\",\n  \"validate\",\n]);\n\nconst store = {} as Record<string, DefineTypeOpts>;\n\n// Wraps defineType to ensure these aliases are included.\nexport function defineAliasedType(...aliases: string[]) {\n  return (type: string, opts: DefineTypeOpts = {}) => {\n    let defined = opts.aliases;\n    if (!defined) {\n      if (opts.inherits) defined = store[opts.inherits].aliases?.slice();\n      defined ??= [];\n      opts.aliases = defined;\n    }\n    const additional = aliases.filter(a => !defined.includes(a));\n    defined.unshift(...additional);\n    defineType(type, opts);\n  };\n}\n\nexport default function defineType(type: string, opts: DefineTypeOpts = {}) {\n  const inherits = (opts.inherits && store[opts.inherits]) || {};\n\n  let fields = opts.fields;\n  if (!fields) {\n    fields = {};\n    if (inherits.fields) {\n      const keys = Object.getOwnPropertyNames(inherits.fields);\n      for (const key of keys) {\n        const field = inherits.fields[key];\n        const def = field.default;\n        if (\n          Array.isArray(def) ? def.length > 0 : def && typeof def === \"object\"\n        ) {\n          throw new Error(\n            \"field defaults can only be primitives or empty arrays currently\",\n          );\n        }\n        fields[key] = {\n          default: Array.isArray(def) ? [] : def,\n          optional: field.optional,\n          deprecated: field.deprecated,\n          validate: field.validate,\n        };\n      }\n    }\n  }\n\n  const visitor: string[] = opts.visitor || inherits.visitor || [];\n  const aliases: string[] = opts.aliases || inherits.aliases || [];\n  const builder: string[] =\n    opts.builder || inherits.builder || opts.visitor || [];\n\n  for (const k of Object.keys(opts)) {\n    if (!validTypeOpts.has(k)) {\n      throw new Error(`Unknown type option \"${k}\" on ${type}`);\n    }\n  }\n\n  if (opts.deprecatedAlias) {\n    DEPRECATED_KEYS[opts.deprecatedAlias] = type as NodeTypesWithoutComment;\n  }\n\n  // ensure all field keys are represented in `fields`\n  for (const key of visitor.concat(builder)) {\n    fields[key] = fields[key] || {};\n  }\n\n  for (const key of Object.keys(fields)) {\n    const field = fields[key];\n\n    if (field.default !== undefined && !builder.includes(key)) {\n      field.optional = true;\n    }\n    if (field.default === undefined) {\n      field.default = null;\n    } else if (!field.validate && field.default != null) {\n      field.validate = assertValueType(getType(field.default));\n    }\n\n    for (const k of Object.keys(field)) {\n      if (!validFieldKeys.has(k)) {\n        throw new Error(`Unknown field key \"${k}\" on ${type}.${key}`);\n      }\n    }\n  }\n\n  VISITOR_KEYS[type] = opts.visitor = visitor;\n  BUILDER_KEYS[type] = opts.builder = builder;\n  NODE_FIELDS[type] = opts.fields = fields;\n  ALIAS_KEYS[type as NodeTypesWithoutComment] = opts.aliases = aliases;\n  aliases.forEach(alias => {\n    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];\n    FLIPPED_ALIAS_KEYS[alias].push(type as NodeTypesWithoutComment);\n  });\n\n  if (opts.validate) {\n    NODE_PARENT_VALIDATIONS[type] = opts.validate;\n  }\n  if (opts.unionShape) {\n    NODE_UNION_SHAPES__PRIVATE[type] = opts.unionShape;\n  }\n\n  store[type] = opts;\n}\n","import is from \"../validators/is.ts\";\nimport isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isKeyword, isReservedWord } from \"@babel/helper-validator-identifier\";\nimport type * as t from \"../index.ts\";\nimport { readStringContents } from \"@babel/helper-string-parser\";\n\nimport {\n  BINARY_OPERATORS,\n  LOGICAL_OPERATORS,\n  ASSIGNMENT_OPERATORS,\n  UNARY_OPERATORS,\n  UPDATE_OPERATORS,\n} from \"../constants/index.ts\";\n\nimport {\n  defineAliasedType,\n  assertShape,\n  assertOptionalChainStart,\n  assertValueType,\n  assertNodeType,\n  assertNodeOrValueType,\n  assertEach,\n  chain,\n  assertOneOf,\n  validateOptional,\n  arrayOf,\n  arrayOfType,\n  validateArrayOfType,\n  validateType,\n  type Validator,\n  type ValidatorImpl,\n  type ValidatorOneOfNodeTypes,\n  type ValidatorType,\n} from \"./utils.ts\";\n\nexport const classMethodOrPropertyUnionShapeCommon = (\n  allowPrivateName = false,\n) => ({\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          key: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          key: {\n            validate: allowPrivateName\n              ? assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                  \"PrivateName\",\n                )\n              : assertNodeType(\n                  \"Identifier\",\n                  \"StringLiteral\",\n                  \"NumericLiteral\",\n                  \"BigIntLiteral\",\n                ),\n          },\n        },\n      },\n    ],\n  },\n});\n\nconst defineType = defineAliasedType(\"Standardized\");\n\ndefineType(\"ArrayExpression\", {\n  fields: {\n    elements: {\n      validate: arrayOf(\n        assertNodeOrValueType(\"null\", \"Expression\", \"SpreadElement\"),\n      ),\n      default: undefined,\n    },\n  },\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"AssignmentExpression\", {\n  fields: {\n    operator: {\n      validate: Object.assign(\n        (function () {\n          const identifier = assertOneOf(...ASSIGNMENT_OPERATORS);\n          const pattern = assertOneOf(\"=\");\n\n          return function (node: t.AssignmentExpression, key, val) {\n            const validator = is(\"Pattern\", node.left) ? pattern : identifier;\n            validator(node, key, val);\n          } satisfies ValidatorImpl;\n        })(),\n        { oneOf: ASSIGNMENT_OPERATORS },\n      ),\n    },\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"MemberExpression\",\n        \"OptionalMemberExpression\",\n        \"ArrayPattern\",\n        \"ObjectPattern\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...BINARY_OPERATORS),\n    },\n    left: {\n      validate: (function () {\n        const expression = assertNodeType(\"Expression\");\n        const inOp = assertNodeType(\"Expression\", \"PrivateName\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.BinaryExpression, key, val) {\n            const validator = node.operator === \"in\" ? inOp : expression;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          // todo(ts): can be discriminated union by `operator` property\n          { oneOfNodeTypes: [\"Expression\", \"PrivateName\"] as const },\n        );\n        return validator;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n});\n\ndefineType(\"InterpreterDirective\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"Directive\", {\n  visitor: [\"value\"],\n  fields: {\n    value: {\n      validate: assertNodeType(\"DirectiveLiteral\"),\n    },\n  },\n});\n\ndefineType(\"DirectiveLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"BlockStatement\", {\n  builder: [\"body\", \"directives\"],\n  visitor: [\"directives\", \"body\"],\n  fields: {\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"],\n});\n\ndefineType(\"BreakStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"CallExpression\", {\n  visitor: [\"callee\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\", \"Super\", \"V8IntrinsicIdentifier\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    typeArguments: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  fields: {\n    param: {\n      validate: assertNodeType(\"Identifier\", \"ArrayPattern\", \"ObjectPattern\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\"Scopable\", \"BlockParent\"],\n});\n\ndefineType(\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    alternate: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\", \"Conditional\"],\n});\n\ndefineType(\"ContinueStatement\", {\n  visitor: [\"label\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n  },\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n});\n\ndefineType(\"DebuggerStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"DoWhileStatement\", {\n  builder: [\"test\", \"body\"],\n  visitor: [\"body\", \"test\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n});\n\ndefineType(\"EmptyStatement\", {\n  aliases: [\"Statement\"],\n});\n\ndefineType(\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Statement\", \"ExpressionWrapper\"],\n});\n\ndefineType(\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"],\n  fields: {\n    program: {\n      validate: assertNodeType(\"Program\"),\n    },\n    comments: {\n      validate: assertEach(assertNodeType(\"CommentBlock\", \"CommentLine\")),\n      optional: true,\n    },\n    tokens: {\n      // todo(ts): add Token type\n      validate: assertEach(Object.assign(() => {}, { type: \"any\" })),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: assertNodeType(\n        \"VariableDeclaration\",\n        \"Identifier\",\n        \"MemberExpression\",\n        \"ArrayPattern\",\n        \"ObjectPattern\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"],\n  fields: {\n    init: {\n      validate: assertNodeType(\"VariableDeclaration\", \"Expression\"),\n      optional: true,\n    },\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    update: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\nexport const functionCommon = () => ({\n  params: validateArrayOfType(\"FunctionParameter\"),\n  generator: {\n    default: false,\n  },\n  async: {\n    default: false,\n  },\n});\n\nexport const functionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n    optional: true,\n  },\n  typeParameters: {\n    validate: assertNodeType(\n      \"TypeParameterDeclaration\",\n      \"TSTypeParameterDeclaration\",\n    ),\n\n    optional: true,\n  },\n});\n\nexport const functionDeclarationCommon = () => ({\n  ...functionCommon(),\n  declare: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  id: {\n    validate: assertNodeType(\"Identifier\"),\n    optional: true, // May be null for `export default function`\n  },\n});\n\ndefineType(\"FunctionDeclaration\", {\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\n    \"id\",\n    \"typeParameters\",\n    \"params\",\n    \"predicate\",\n    \"returnType\",\n    \"body\",\n  ],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Statement\",\n    \"Pureish\",\n    \"Declaration\",\n  ],\n  validate: (function () {\n    const identifier = assertNodeType(\"Identifier\");\n\n    return function (parent, key, node) {\n      if (!is(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  })(),\n});\n\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\nexport const patternLikeCommon = () => ({\n  typeAnnotation: {\n    validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n    optional: true,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\", \"decorators\" /* for legacy param decorators */],\n  aliases: [\n    \"Expression\",\n    \"FunctionParameter\",\n    \"PatternLike\",\n    \"LVal\",\n    \"TSEntityName\",\n  ],\n  fields: {\n    ...patternLikeCommon(),\n    name: {\n      validate: chain(\n        assertValueType(\"string\"),\n        Object.assign(\n          function (node, key, val) {\n            if (!isValidIdentifier(val, false)) {\n              throw new TypeError(`\"${val}\" is not a valid identifier name`);\n            }\n          } satisfies ValidatorImpl,\n          { type: \"string\" as const },\n        ) satisfies ValidatorType,\n      ),\n    },\n  },\n  validate: function (parent, key, node) {\n    const match = /\\.(\\w+)$/.exec(key.toString());\n    if (!match) return;\n\n    const [, parentKey] = match;\n    const nonComp = { computed: false };\n\n    // We can't check if `parent.property === node`, because nodes are validated\n    // before replacing them in the AST.\n    if (parentKey === \"property\") {\n      if (is(\"MemberExpression\", parent, nonComp)) return;\n      if (is(\"OptionalMemberExpression\", parent, nonComp)) return;\n    } else if (parentKey === \"key\") {\n      if (is(\"Property\", parent, nonComp)) return;\n      if (is(\"Method\", parent, nonComp)) return;\n    } else if (parentKey === \"exported\") {\n      if (is(\"ExportSpecifier\", parent)) return;\n    } else if (parentKey === \"imported\") {\n      if (is(\"ImportSpecifier\", parent, { imported: node })) return;\n    } else if (parentKey === \"meta\") {\n      if (is(\"MetaProperty\", parent, { meta: node })) return;\n    }\n\n    if (\n      // Ideally we should call isStrictReservedWord if this node is a descendant\n      // of a block in strict mode. Also, we should pass the inModule option so\n      // we can disable \"await\" in module.\n      (isKeyword(node.name) || isReservedWord(node.name, false)) &&\n      // Even if \"this\" is a keyword, we are using the Identifier\n      // node to represent it.\n      node.name !== \"this\"\n    ) {\n      throw new TypeError(`\"${node.name}\" is not a valid identifier`);\n    }\n  },\n});\n\ndefineType(\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\", \"Conditional\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    consequent: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    alternate: {\n      optional: true,\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    label: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"StringLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NumericLiteral\", {\n  builder: [\"value\"],\n  deprecatedAlias: \"NumberLiteral\",\n  fields: {\n    value: {\n      validate: chain(\n        assertValueType(\"number\"),\n        Object.assign(\n          function (node, key, val) {\n            if (1 / val < 0 || !Number.isFinite(val)) {\n              const error = new Error(\n                \"NumericLiterals must be non-negative finite numbers. \" +\n                  `You can use t.valueToNode(${val}) instead.`,\n              );\n\n              // TODO(@nicolo-ribaudo) Fix regenerator to not pass negative\n              // numbers here.\n              if (!IS_STANDALONE) {\n                if (!new Error().stack.includes(\"regenerator\")) {\n                  throw error;\n                }\n              }\n            }\n          } satisfies ValidatorImpl,\n          { type: \"number\" as const },\n        ) satisfies ValidatorType,\n      ),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"NullLiteral\", {\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"BooleanLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"boolean\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"RegExpLiteral\", {\n  builder: [\"pattern\", \"flags\"],\n  deprecatedAlias: \"RegexLiteral\",\n  aliases: [\"Expression\", \"Pureish\", \"Literal\"],\n  fields: {\n    pattern: {\n      validate: assertValueType(\"string\"),\n    },\n    flags: {\n      validate: chain(\n        assertValueType(\"string\"),\n        Object.assign(\n          function (node, key, val) {\n            const invalid = /[^dgimsuvy]/.exec(val);\n            if (invalid) {\n              throw new TypeError(`\"${invalid[0]}\" is not a valid RegExp flag`);\n            }\n          } satisfies ValidatorImpl,\n          { type: \"string\" as const },\n        ) satisfies ValidatorType,\n      ),\n      default: \"\",\n    },\n  },\n});\n\ndefineType(\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(...LOGICAL_OPERATORS),\n    },\n    left: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"MemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", ...[]],\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          property: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          property: {\n            validate: assertNodeType(\"Identifier\", \"PrivateName\"),\n          },\n        },\n      },\n    ],\n  },\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\", \"Super\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\", \"PrivateName\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = function (\n          node: t.MemberExpression,\n          key,\n          val,\n        ) {\n          const validator: Validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\"Expression\", \"Identifier\", \"PrivateName\"];\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"NewExpression\", { inherits: \"CallExpression\" });\n\ndefineType(\"Program\", {\n  // Note: We explicitly leave 'interpreter' out here because it is\n  // conceptually comment-like, and Babel does not traverse comments either.\n  visitor: [\"directives\", \"body\"],\n  builder: [\"body\", \"directives\", \"sourceType\", \"interpreter\"],\n  fields: {\n    sourceType: {\n      validate: assertOneOf(\"script\", \"module\"),\n      default: \"script\",\n    },\n    interpreter: {\n      validate: assertNodeType(\"InterpreterDirective\"),\n      default: null,\n      optional: true,\n    },\n    directives: {\n      validate: arrayOfType(\"Directive\"),\n      default: [],\n    },\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\"],\n});\n\ndefineType(\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"],\n  fields: {\n    properties: validateArrayOfType(\n      \"ObjectMethod\",\n      \"ObjectProperty\",\n      \"SpreadElement\",\n    ),\n  },\n});\n\ndefineType(\"ObjectMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"computed\", \"generator\", \"async\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n    },\n\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = function (\n          node: t.ObjectMethod,\n          key,\n          val,\n        ) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        };\n        // todo(ts): can be discriminated union by `computed` property\n        validator.oneOfNodeTypes = [\n          \"Expression\",\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        ];\n        return validator;\n      })(),\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n  aliases: [\n    \"UserWhitespacable\",\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"ObjectMember\",\n  ],\n});\n\ndefineType(\"ObjectProperty\", {\n  builder: [\"key\", \"value\", \"computed\", \"shorthand\", ...[]],\n  unionShape: {\n    discriminator: \"computed\",\n    shapes: [\n      {\n        name: \"computed\",\n        value: [true],\n        properties: {\n          key: {\n            validate: assertNodeType(\"Expression\"),\n          },\n        },\n      },\n      {\n        name: \"nonComputed\",\n        value: [false],\n        properties: {\n          key: {\n            validate: assertNodeType(\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"PrivateName\",\n            ),\n          },\n        },\n      },\n    ],\n  },\n  fields: {\n    computed: {\n      default: false,\n    },\n    key: {\n      validate: (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"PrivateName\",\n        );\n\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.ObjectProperty, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          {\n            // todo(ts): can be discriminated union by `computed` property\n            oneOfNodeTypes: [\n              \"Expression\",\n              \"Identifier\",\n              \"StringLiteral\",\n              \"NumericLiteral\",\n              \"BigIntLiteral\",\n              \"PrivateName\",\n            ] as const,\n          },\n        );\n        return validator;\n      })(),\n    },\n    value: {\n      // Value may be PatternLike if this is an AssignmentProperty\n      // https://github.com/babel/babylon/issues/434\n      validate: assertNodeType(\"Expression\", \"PatternLike\"),\n    },\n    shorthand: {\n      validate: chain(\n        assertValueType(\"boolean\"),\n        Object.assign(\n          function (node: t.ObjectProperty, key, shorthand) {\n            if (!shorthand) return;\n\n            if (node.computed) {\n              throw new TypeError(\n                \"Property shorthand of ObjectProperty cannot be true if computed is true\",\n              );\n            }\n\n            if (!is(\"Identifier\", node.key)) {\n              throw new TypeError(\n                \"Property shorthand of ObjectProperty cannot be true if key is not an Identifier\",\n              );\n            }\n          } satisfies ValidatorImpl,\n          { type: \"boolean\" as const },\n        ) satisfies ValidatorType,\n      ),\n      default: false,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n  visitor: [\"decorators\", \"key\", \"value\"],\n  aliases: [\"UserWhitespacable\", \"Property\", \"ObjectMember\"],\n  validate: (function () {\n    const pattern = assertNodeType(\n      \"Identifier\",\n      \"Pattern\",\n      \"TSAsExpression\",\n      \"TSSatisfiesExpression\",\n      \"TSNonNullExpression\",\n      \"TSTypeAssertion\",\n    );\n    const expression = assertNodeType(\"Expression\");\n\n    return function (parent, key, node) {\n      const validator = is(\"ObjectPattern\", parent) ? pattern : expression;\n      validator(node, \"value\", node.value);\n    };\n  })(),\n});\n\ndefineType(\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"],\n  builder: [\"argument\"],\n  aliases: [\"FunctionParameter\", \"PatternLike\"],\n  deprecatedAlias: \"RestProperty\",\n  fields: {\n    ...patternLikeCommon(),\n    argument: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ArrayPattern\",\n        \"ObjectPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n  },\n  validate: function (parent: t.ArrayPattern | t.ObjectPattern, key) {\n    const match = /(\\w+)\\[(\\d+)\\]/.exec(key.toString());\n    if (!match) throw new Error(\"Internal Babel error: malformed key.\");\n\n    const [, listKey, index] = match as unknown as [\n      string,\n      keyof typeof parent,\n      string,\n    ];\n    if ((parent[listKey] as t.Node[]).length > +index + 1) {\n      throw new TypeError(`RestElement must be last element of ${listKey}`);\n    }\n  } satisfies ValidatorImpl,\n});\n\ndefineType(\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  fields: {\n    expressions: validateArrayOfType(\"Expression\"),\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\", \"ExpressionWrapper\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    consequent: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"],\n  fields: {\n    discriminant: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    cases: validateArrayOfType(\"SwitchCase\"),\n  },\n});\n\ndefineType(\"ThisExpression\", {\n  aliases: [\"Expression\", \"TSEntityName\"],\n});\n\ndefineType(\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"TryStatement\", {\n  visitor: [\"block\", \"handler\", \"finalizer\"],\n  aliases: [\"Statement\"],\n  fields: {\n    block: {\n      validate: chain(\n        assertNodeType(\"BlockStatement\"),\n        Object.assign(\n          function (node: t.TryStatement) {\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (!node.handler && !node.finalizer) {\n              throw new TypeError(\n                \"TryStatement expects either a handler or finalizer, or both\",\n              );\n            }\n          } satisfies ValidatorImpl,\n          { oneOfNodeTypes: [\"BlockStatement\"] as const },\n        ) satisfies ValidatorOneOfNodeTypes,\n      ),\n    },\n    handler: {\n      optional: true,\n      validate: assertNodeType(\"CatchClause\"),\n    },\n    finalizer: {\n      optional: true,\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"UnaryExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: true,\n    },\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UNARY_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"],\n});\n\ndefineType(\"UpdateExpression\", {\n  builder: [\"operator\", \"argument\", \"prefix\"],\n  fields: {\n    prefix: {\n      default: false,\n    },\n    argument: {\n      validate: assertNodeType(\"Identifier\", \"MemberExpression\"),\n    },\n    operator: {\n      validate: assertOneOf(...UPDATE_OPERATORS),\n    },\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"],\n  fields: {\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    kind: {\n      validate: assertOneOf(\n        \"var\",\n        \"let\",\n        \"const\",\n        // https://github.com/tc39/proposal-explicit-resource-management\n        \"using\",\n        // https://github.com/tc39/proposal-async-explicit-resource-management\n        \"await using\",\n      ),\n    },\n    declarations: validateArrayOfType(\"VariableDeclarator\"),\n  },\n  validate: (() => {\n    const withoutInit = assertNodeType(\"Identifier\", \"Placeholder\");\n    const constOrLetOrVar = assertNodeType(\n      \"Identifier\",\n      \"ArrayPattern\",\n      \"ObjectPattern\",\n      \"Placeholder\",\n    );\n    const usingOrAwaitUsing = assertNodeType(\n      \"Identifier\",\n      \"VoidPattern\",\n      \"Placeholder\",\n    );\n\n    return function (parent, key, node: t.VariableDeclaration) {\n      const { kind, declarations } = node;\n      const parentIsForX = is(\"ForXStatement\", parent, { left: node });\n      if (parentIsForX) {\n        if (declarations.length !== 1) {\n          throw new TypeError(\n            `Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`,\n          );\n        }\n      }\n      for (const decl of declarations) {\n        if (kind === \"const\" || kind === \"let\" || kind === \"var\") {\n          if (!parentIsForX && !decl.init) {\n            withoutInit(decl, \"id\", decl.id);\n          } else {\n            constOrLetOrVar(decl, \"id\", decl.id);\n          }\n        } else {\n          usingOrAwaitUsing(decl, \"id\", decl.id);\n        }\n      }\n    };\n  })(),\n});\n\ndefineType(\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ArrayPattern\",\n        \"ObjectPattern\",\n        \"VoidPattern\",\n      ),\n    },\n    definite: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    init: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"],\n  fields: {\n    test: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\ndefineType(\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n  },\n});\n\n// --- ES2015 ---\ndefineType(\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\", \"decorators\" /* for legacy param decorators */],\n  builder: [\"left\", \"right\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\"],\n  fields: {\n    ...patternLikeCommon(),\n    left: {\n      validate: assertNodeType(\n        \"Identifier\",\n        \"ObjectPattern\",\n        \"ArrayPattern\",\n        \"MemberExpression\",\n        \"TSAsExpression\",\n        \"TSSatisfiesExpression\",\n        \"TSTypeAssertion\",\n        \"TSNonNullExpression\",\n      ),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    // For TypeScript\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  builder: [\"elements\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    elements: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeOrValueType(\"null\", \"PatternLike\")),\n      ),\n    },\n  },\n});\n\ndefineType(\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"typeParameters\", \"params\", \"predicate\", \"returnType\", \"body\"],\n  aliases: [\n    \"Scopable\",\n    \"Function\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Expression\",\n    \"Pureish\",\n  ],\n  fields: {\n    ...functionCommon(),\n    ...functionTypeAnnotationCommon(),\n    expression: {\n      // https://github.com/babel/babylon/issues/505\n      validate: assertValueType(\"boolean\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\", \"Expression\"),\n    },\n    predicate: {\n      validate: assertNodeType(\"DeclaredPredicate\", \"InferredPredicate\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\n      \"ClassMethod\",\n      \"ClassPrivateMethod\",\n      \"ClassProperty\",\n      \"ClassPrivateProperty\",\n      \"ClassAccessorProperty\",\n      \"TSDeclareMethod\",\n      \"TSIndexSignature\",\n      \"StaticBlock\",\n    ),\n  },\n});\n\ndefineType(\"ClassExpression\", {\n  builder: [\"id\", \"superClass\", \"body\", \"decorators\"],\n  visitor: [\n    \"decorators\",\n    \"id\",\n    \"typeParameters\",\n    \"superClass\",\n    \"superTypeArguments\",\n    \"mixins\",\n    \"implements\",\n    \"body\",\n  ],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterDeclaration\",\n        \"TSTypeParameterDeclaration\",\n      ),\n\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    [\"superTypeArguments\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\"TSClassImplements\", \"ClassImplements\"),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassDeclaration\", {\n  inherits: \"ClassExpression\",\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n      // The id may be omitted if this is the child of an\n      // ExportDefaultDeclaration.\n      optional: true,\n    },\n    typeParameters: {\n      validate: assertNodeType(\n        \"TypeParameterDeclaration\",\n        \"TSTypeParameterDeclaration\",\n      ),\n\n      optional: true,\n    },\n    body: {\n      validate: assertNodeType(\"ClassBody\"),\n    },\n    superClass: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n    [\"superTypeArguments\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n    implements: {\n      validate: arrayOfType(\"TSClassImplements\", \"ClassImplements\"),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    mixins: {\n      validate: assertNodeType(\"InterfaceExtends\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    abstract: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n  },\n  validate: (function () {\n    const identifier = assertNodeType(\"Identifier\");\n    return function (parent, key, node) {\n      if (!is(\"ExportDefaultDeclaration\", parent)) {\n        identifier(node, \"id\", node.id);\n      }\n    };\n  })(),\n});\n\nexport const importAttributes = {\n  attributes: {\n    optional: true,\n    validate: arrayOfType(\"ImportAttribute\"),\n  },\n};\n\ndefineType(\"ExportAllDeclaration\", {\n  builder: [\"source\"],\n  visitor: [\"source\", \"attributes\", \"assertions\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: validateType(\n      \"TSDeclareFunction\",\n      \"FunctionDeclaration\",\n      \"ClassDeclaration\",\n      \"Expression\",\n    ),\n    exportKind: validateOptional(assertOneOf(\"value\")),\n  },\n});\n\ndefineType(\"ExportNamedDeclaration\", {\n  builder: [\"declaration\", \"specifiers\", \"source\"],\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  aliases: [\n    \"Statement\",\n    \"Declaration\",\n    \"ImportOrExportDeclaration\",\n    \"ExportDeclaration\",\n  ],\n  fields: {\n    declaration: {\n      optional: true,\n      validate: chain(\n        assertNodeType(\"Declaration\"),\n        Object.assign(\n          function (node: t.ExportNamedDeclaration, key, val) {\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (val && node.specifiers.length) {\n              throw new TypeError(\n                \"Only declaration or specifiers is allowed on ExportNamedDeclaration\",\n              );\n            }\n\n            // This validator isn't put at the top level because we can run it\n            // even if this node doesn't have a parent.\n\n            if (val && node.source) {\n              throw new TypeError(\"Cannot export a declaration from a source\");\n            }\n          } satisfies ValidatorImpl,\n          { oneOfNodeTypes: [\"Declaration\"] as const },\n        ) satisfies ValidatorOneOfNodeTypes,\n      ),\n    },\n    ...importAttributes,\n    specifiers: {\n      default: [],\n      validate: arrayOf(\n        (function () {\n          const sourced = assertNodeType(\n            \"ExportSpecifier\",\n            \"ExportDefaultSpecifier\",\n            \"ExportNamespaceSpecifier\",\n          );\n          const sourceless = assertNodeType(\"ExportSpecifier\");\n\n          return Object.assign(\n            function (node: t.ExportNamedDeclaration, key, val) {\n              const validator = node.source ? sourced : sourceless;\n              validator(node, key, val);\n            } satisfies ValidatorImpl,\n            {\n              oneOfNodeTypes: [\n                \"ExportSpecifier\",\n                \"ExportDefaultSpecifier\",\n                \"ExportNamespaceSpecifier\",\n              ] as const,\n            },\n          ) satisfies ValidatorOneOfNodeTypes;\n        })(),\n      ),\n    },\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n      optional: true,\n    },\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n  },\n});\n\ndefineType(\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    exported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    exportKind: {\n      // And TypeScript's \"export { type foo } from\"\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  builder: [\"left\", \"right\", \"body\", \"await\"],\n  aliases: [\n    \"Scopable\",\n    \"Statement\",\n    \"For\",\n    \"BlockParent\",\n    \"Loop\",\n    \"ForXStatement\",\n  ],\n  fields: {\n    left: {\n      validate: (function () {\n        const declaration = assertNodeType(\"VariableDeclaration\");\n        const lval = assertNodeType(\n          \"Identifier\",\n          \"MemberExpression\",\n          \"ArrayPattern\",\n          \"ObjectPattern\",\n          \"TSAsExpression\",\n          \"TSSatisfiesExpression\",\n          \"TSTypeAssertion\",\n          \"TSNonNullExpression\",\n        );\n\n        return Object.assign(\n          function (node, key, val) {\n            if (is(\"VariableDeclaration\", val)) {\n              declaration(node, key, val);\n            } else {\n              lval(node, key, val);\n            }\n          } satisfies ValidatorImpl,\n          {\n            oneOfNodeTypes: [\n              \"VariableDeclaration\",\n              \"Identifier\",\n              \"MemberExpression\",\n              \"ArrayPattern\",\n              \"ObjectPattern\",\n              \"TSAsExpression\",\n              \"TSSatisfiesExpression\",\n              \"TSTypeAssertion\",\n              \"TSNonNullExpression\",\n            ] as const,\n          },\n        ) satisfies ValidatorOneOfNodeTypes;\n      })(),\n    },\n    right: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    body: {\n      validate: assertNodeType(\"Statement\"),\n    },\n    await: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ImportDeclaration\", {\n  builder: [\"specifiers\", \"source\"],\n  visitor: [\"specifiers\", \"source\", \"attributes\"],\n  aliases: [\"Statement\", \"Declaration\", \"ImportOrExportDeclaration\"],\n  fields: {\n    ...importAttributes,\n    module: {\n      optional: true,\n      validate: assertValueType(\"boolean\"),\n    },\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    specifiers: validateArrayOfType(\n      \"ImportSpecifier\",\n      \"ImportDefaultSpecifier\",\n      \"ImportNamespaceSpecifier\",\n    ),\n    source: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n    importKind: {\n      // Handle TypeScript/Flowtype's extension \"import type foo from\"\n      // TypeScript doesn't support typeof\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"ImportSpecifier\", {\n  visitor: [\"imported\", \"local\"],\n  builder: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    local: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    imported: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    importKind: {\n      // Handle Flowtype's extension \"import {typeof foo} from\"\n      // And TypeScript's \"import { type foo } from\"\n      validate: assertOneOf(\"type\", \"typeof\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ImportExpression\", {\n  visitor: [\"source\", \"options\"],\n  aliases: [\"Expression\"],\n  fields: {\n    phase: {\n      default: null,\n      validate: assertOneOf(\"source\", \"defer\"),\n    },\n    source: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    options: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"],\n  fields: {\n    meta: {\n      validate: chain(\n        assertNodeType(\"Identifier\"),\n        Object.assign(\n          function (node: t.MetaProperty, key, val) {\n            let property;\n            switch (val.name) {\n              case \"function\":\n                property = \"sent\";\n                break;\n              case \"new\":\n                property = \"target\";\n                break;\n              case \"import\":\n                property = \"meta\";\n                break;\n            }\n            if (!is(\"Identifier\", node.property, { name: property })) {\n              throw new TypeError(\"Unrecognised MetaProperty\");\n            }\n          } satisfies ValidatorImpl,\n          { oneOfNodeTypes: [\"Identifier\"] as const },\n        ) satisfies ValidatorOneOfNodeTypes,\n      ),\n    },\n    property: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\nexport const classMethodOrPropertyCommon = () => ({\n  abstract: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  accessibility: {\n    validate: assertOneOf(\"public\", \"private\", \"protected\"),\n    optional: true,\n  },\n  static: {\n    default: false,\n  },\n  override: {\n    default: false,\n  },\n  computed: {\n    default: false,\n  },\n  optional: {\n    validate: assertValueType(\"boolean\"),\n    optional: true,\n  },\n  key: {\n    validate: chain(\n      (function () {\n        const normal = assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const computed = assertNodeType(\"Expression\");\n\n        return function (\n          node: Extract<t.Node, { computed: boolean }>,\n          key,\n          val,\n        ) {\n          const validator = node.computed ? computed : normal;\n          validator(node, key, val);\n        } satisfies ValidatorImpl;\n      })(),\n      assertNodeType(\n        \"Identifier\",\n        \"StringLiteral\",\n        \"NumericLiteral\",\n        \"BigIntLiteral\",\n        \"Expression\",\n      ),\n    ),\n  },\n});\n\nexport const classMethodOrDeclareMethodCommon = () => ({\n  ...functionCommon(),\n  ...classMethodOrPropertyCommon(),\n  params: validateArrayOfType(\"FunctionParameter\", \"TSParameterProperty\"),\n  kind: {\n    validate: assertOneOf(\"get\", \"set\", \"method\", \"constructor\"),\n    default: \"method\",\n  },\n  access: {\n    validate: chain(\n      assertValueType(\"string\"),\n      assertOneOf(\"public\", \"private\", \"protected\"),\n    ),\n    optional: true,\n  },\n  decorators: {\n    validate: arrayOfType(\"Decorator\"),\n    optional: true,\n  },\n});\n\ndefineType(\"ClassMethod\", {\n  aliases: [\"Function\", \"Scopable\", \"BlockParent\", \"FunctionParent\", \"Method\"],\n  builder: [\n    \"kind\",\n    \"key\",\n    \"params\",\n    \"body\",\n    \"computed\",\n    \"static\",\n    \"generator\",\n    \"async\",\n  ],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"ObjectPattern\", {\n  visitor: [\n    \"decorators\" /* for legacy param decorators */,\n    \"properties\",\n    \"typeAnnotation\",\n  ],\n  builder: [\"properties\"],\n  aliases: [\"FunctionParameter\", \"Pattern\", \"PatternLike\", \"LVal\"],\n  fields: {\n    ...patternLikeCommon(),\n    properties: validateArrayOfType(\"RestElement\", \"ObjectProperty\"),\n  },\n});\n\ndefineType(\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"],\n  deprecatedAlias: \"SpreadProperty\",\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\n  \"Super\",\n\n  undefined,\n);\n\ndefineType(\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"typeArguments\", \"quasi\"],\n  builder: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"],\n  fields: {\n    tag: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    quasi: {\n      validate: assertNodeType(\"TemplateLiteral\"),\n    },\n    [\"typeArguments\"]: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TemplateElement\", {\n  builder: [\"value\", \"tail\"],\n  fields: {\n    value: {\n      validate: chain(\n        assertShape({\n          raw: {\n            validate: assertValueType(\"string\"),\n          },\n          cooked: {\n            validate: assertValueType(\"string\"),\n            optional: true,\n          },\n        }),\n        function templateElementCookedValidator(node: t.TemplateElement) {\n          const raw = node.value.raw;\n\n          let unterminatedCalled = false;\n\n          const error = () => {\n            // unreachable\n            throw new Error(\"Internal @babel/types error.\");\n          };\n          const { str, firstInvalidLoc } = readStringContents(\n            \"template\",\n            raw,\n            0,\n            0,\n            0,\n            {\n              unterminated() {\n                unterminatedCalled = true;\n              },\n              strictNumericEscape: error,\n              invalidEscapeSequence: error,\n              numericSeparatorInEscapeSequence: error,\n              unexpectedNumericSeparator: error,\n              invalidDigit: error,\n              invalidCodePoint: error,\n            },\n          );\n          if (!unterminatedCalled) throw new Error(\"Invalid raw\");\n\n          node.value.cooked = firstInvalidLoc ? null : str;\n        },\n      ),\n    },\n    tail: {\n      default: false,\n    },\n  },\n});\n\ndefineType(\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\", \"Literal\"],\n  fields: {\n    quasis: validateArrayOfType(\"TemplateElement\"),\n    expressions: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(\n          assertNodeType(\n            \"Expression\",\n            // For TypeScript template literal types\n            \"TSType\",\n          ),\n        ),\n        function (node: t.TemplateLiteral, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of expressions.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } satisfies ValidatorImpl,\n      ),\n    },\n  },\n});\n\ndefineType(\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    delegate: {\n      validate: chain(\n        assertValueType(\"boolean\"),\n        Object.assign(\n          function (node: t.YieldExpression, key, val) {\n            if (val && !node.argument) {\n              throw new TypeError(\n                \"Property delegate of YieldExpression cannot be true if there is no argument\",\n              );\n            }\n          } satisfies ValidatorImpl,\n          { type: \"boolean\" as const },\n        ) satisfies ValidatorType,\n      ),\n      default: false,\n    },\n    argument: {\n      optional: true,\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2017 ---\ndefineType(\"AwaitExpression\", {\n  builder: [\"argument\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\n// --- ES2019 ---\ndefineType(\"Import\", {\n  aliases: [\"Expression\"],\n});\n\n// --- ES2020 ---\ndefineType(\"BigIntLiteral\", {\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"bigint\"),\n    },\n  },\n  aliases: [\"Expression\", \"Pureish\", \"Literal\", \"Immutable\"],\n});\n\ndefineType(\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"OptionalMemberExpression\", {\n  builder: [\"object\", \"property\", \"computed\", \"optional\"],\n  visitor: [\"object\", \"property\"],\n  // todo: Add OptionalMemberExpression to LVal when optional-chaining-assign reaches stage 4\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    property: {\n      validate: (function () {\n        const normal = assertNodeType(\"Identifier\");\n        const computed = assertNodeType(\"Expression\");\n\n        const validator: ValidatorOneOfNodeTypes = Object.assign(\n          function (node: t.OptionalMemberExpression, key, val) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl,\n          // todo(ts): can be discriminated union by `computed` property\n          { oneOfNodeTypes: [\"Expression\", \"Identifier\"] as const },\n        );\n        return validator;\n      })(),\n    },\n    computed: {\n      default: false,\n    },\n    optional: {\n      validate: chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n  },\n});\n\ndefineType(\"OptionalCallExpression\", {\n  visitor: [\"callee\", \"typeArguments\", \"arguments\"],\n  builder: [\"callee\", \"arguments\", \"optional\"],\n  aliases: [\"Expression\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    arguments: validateArrayOfType(\n      \"Expression\",\n      \"SpreadElement\",\n      \"ArgumentPlaceholder\",\n    ),\n    optional: {\n      validate: chain(assertValueType(\"boolean\"), assertOptionalChainStart()),\n    },\n    typeArguments: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\n// --- ES2022 ---\ndefineType(\"ClassProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\"],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassAccessorProperty\", {\n  visitor: [\"decorators\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\n    \"key\",\n    \"value\",\n    \"typeAnnotation\",\n    \"decorators\",\n    \"computed\",\n    \"static\",\n  ],\n  aliases: [\"Property\", \"Accessor\"],\n  ...classMethodOrPropertyUnionShapeCommon(true),\n  fields: {\n    ...classMethodOrPropertyCommon(),\n    key: {\n      validate: chain(\n        (function () {\n          const normal = assertNodeType(\n            \"Identifier\",\n            \"StringLiteral\",\n            \"NumericLiteral\",\n            \"BigIntLiteral\",\n            \"PrivateName\",\n          );\n          const computed = assertNodeType(\"Expression\");\n\n          return function (\n            node: t.ClassAccessorProperty,\n            key: string,\n            val: any,\n          ) {\n            const validator = node.computed ? computed : normal;\n            validator(node, key, val);\n          } satisfies ValidatorImpl;\n        })(),\n        assertNodeType(\n          \"Identifier\",\n          \"StringLiteral\",\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n          \"Expression\",\n          \"PrivateName\",\n        ),\n      ),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    declare: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateProperty\", {\n  visitor: [\"decorators\", \"variance\", \"key\", \"typeAnnotation\", \"value\"],\n  builder: [\"key\", \"value\", \"decorators\", \"static\"],\n  aliases: [\"Property\", \"Private\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    value: {\n      validate: assertNodeType(\"Expression\"),\n      optional: true,\n    },\n    typeAnnotation: {\n      validate: assertNodeType(\"TypeAnnotation\", \"TSTypeAnnotation\"),\n\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n    static: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    optional: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    definite: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    variance: {\n      validate: assertNodeType(\"Variance\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"ClassPrivateMethod\", {\n  builder: [\"kind\", \"key\", \"params\", \"body\", \"static\"],\n  visitor: [\n    \"decorators\",\n    \"key\",\n    \"typeParameters\",\n    \"params\",\n    \"returnType\",\n    \"body\",\n  ],\n  aliases: [\n    \"Function\",\n    \"Scopable\",\n    \"BlockParent\",\n    \"FunctionParent\",\n    \"Method\",\n    \"Private\",\n  ],\n  // `computed` is not included in the `builder`\n  // ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...functionTypeAnnotationCommon(),\n    kind: {\n      validate: assertOneOf(\"get\", \"set\", \"method\"),\n      default: \"method\",\n    },\n    key: {\n      validate: assertNodeType(\"PrivateName\"),\n    },\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n  },\n});\n\ndefineType(\"PrivateName\", {\n  visitor: [\"id\"],\n  aliases: [\"Private\"],\n  fields: {\n    id: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\ndefineType(\"StaticBlock\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n  aliases: [\"Scopable\", \"BlockParent\", \"FunctionParent\"],\n});\n\n// --- ES2025 ---\ndefineType(\"ImportAttribute\", {\n  visitor: [\"key\", \"value\"],\n  fields: {\n    key: {\n      validate: assertNodeType(\"Identifier\", \"StringLiteral\"),\n    },\n    value: {\n      validate: assertNodeType(\"StringLiteral\"),\n    },\n  },\n});\n","import { importAttributes } from \"./core.ts\";\nimport {\n  defineAliasedType,\n  arrayOfType,\n  assertOneOf,\n  assertValueType,\n  validate,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n} from \"./utils.ts\";\n\nconst defineType = defineAliasedType(\"Flow\");\n\nconst defineInterfaceishType = (\n  name: \"DeclareClass\" | \"DeclareInterface\" | \"InterfaceDeclaration\",\n) => {\n  const isDeclareClass = name === \"DeclareClass\";\n\n  defineType(name, {\n    builder: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n    visitor: [\n      \"id\",\n      \"typeParameters\",\n      \"extends\",\n      ...(isDeclareClass ? [\"mixins\", \"implements\"] : []),\n      \"body\",\n    ],\n    aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n    fields: {\n      id: validateType(\"Identifier\"),\n      typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n      extends: validateOptional(arrayOfType(\"InterfaceExtends\")),\n      ...(isDeclareClass\n        ? {\n            mixins: validateOptional(arrayOfType(\"InterfaceExtends\")),\n            implements: validateOptional(arrayOfType(\"ClassImplements\")),\n          }\n        : {}),\n      body: validateType(\"ObjectTypeAnnotation\"),\n    },\n  });\n};\n\ndefineType(\"AnyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    elementType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"BooleanTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"BooleanLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"NullLiteralTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineInterfaceishType(\"DeclareClass\");\n\ndefineType(\"DeclareFunction\", {\n  builder: [\"id\"],\n  visitor: [\"id\", \"predicate\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    predicate: validateOptionalType(\"DeclaredPredicate\"),\n  },\n});\n\ndefineInterfaceishType(\"DeclareInterface\");\n\ndefineType(\"DeclareModule\", {\n  builder: [\"id\", \"body\", \"kind\"],\n  visitor: [\"id\", \"body\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\", \"StringLiteral\"),\n    body: validateType(\"BlockStatement\"),\n    kind: validateOptional(assertOneOf(\"CommonJS\", \"ES\")),\n  },\n});\n\ndefineType(\"DeclareModuleExports\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    typeAnnotation: validateType(\"TypeAnnotation\"),\n  },\n});\n\ndefineType(\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    right: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"DeclareOpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    supertype: validateOptionalType(\"FlowType\"),\n    impltype: validateOptionalType(\"FlowType\"),\n  },\n});\n\ndefineType(\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"DeclareExportDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    declaration: validateOptionalType(\"Flow\"),\n    specifiers: validateOptional(\n      arrayOfType(\"ExportSpecifier\", \"ExportNamespaceSpecifier\"),\n    ),\n    source: validateOptionalType(\"StringLiteral\"),\n    default: validateOptional(assertValueType(\"boolean\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"DeclareExportAllDeclaration\", {\n  visitor: [\"source\", \"attributes\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    source: validateType(\"StringLiteral\"),\n    exportKind: validateOptional(assertOneOf(\"type\", \"value\")),\n    ...importAttributes,\n  },\n});\n\ndefineType(\"DeclaredPredicate\", {\n  visitor: [\"value\"],\n  aliases: [\"FlowPredicate\"],\n  fields: {\n    value: validateType(\"Flow\"),\n  },\n});\n\ndefineType(\"ExistsTypeAnnotation\", {\n  aliases: [\"FlowType\"],\n});\n\ndefineType(\"FunctionTypeAnnotation\", {\n  builder: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  visitor: [\"typeParameters\", \"this\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    params: validateArrayOfType(\"FunctionTypeParam\"),\n    rest: validateOptionalType(\"FunctionTypeParam\"),\n    this: validateOptionalType(\"FunctionTypeParam\"),\n    returnType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  fields: {\n    name: validateOptionalType(\"Identifier\"),\n    typeAnnotation: validateType(\"FlowType\"),\n    optional: validateOptional(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    id: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"InferredPredicate\", {\n  aliases: [\"FlowPredicate\"],\n});\n\ndefineType(\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  fields: {\n    id: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterInstantiation\"),\n  },\n});\n\ndefineInterfaceishType(\"InterfaceDeclaration\");\n\ndefineType(\"InterfaceTypeAnnotation\", {\n  visitor: [\"extends\", \"body\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    extends: validateOptional(arrayOfType(\"InterfaceExtends\")),\n    body: validateType(\"ObjectTypeAnnotation\"),\n  },\n});\n\ndefineType(\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"MixedTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"EmptyTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    typeAnnotation: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"NumberLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"number\")),\n  },\n});\n\ndefineType(\"NumberTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\", \"internalSlots\"],\n  aliases: [\"FlowType\"],\n  builder: [\n    \"properties\",\n    \"indexers\",\n    \"callProperties\",\n    \"internalSlots\",\n    \"exact\",\n  ],\n  fields: {\n    properties: validate(\n      arrayOfType(\"ObjectTypeProperty\", \"ObjectTypeSpreadProperty\"),\n    ),\n    indexers: {\n      validate: arrayOfType(\"ObjectTypeIndexer\"),\n      optional: false,\n      default: [],\n    },\n    callProperties: {\n      validate: arrayOfType(\"ObjectTypeCallProperty\"),\n      optional: false,\n      default: [],\n    },\n    internalSlots: {\n      validate: arrayOfType(\"ObjectTypeInternalSlot\"),\n      optional: false,\n      default: [],\n    },\n    exact: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n    // If the inexact flag is present then this is an object type, and not a\n    // declare class, declare interface, or interface. If it is true, the\n    // object uses ... to express that it is inexact.\n    inexact: validateOptional(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeInternalSlot\", {\n  visitor: [\"id\", \"value\"],\n  builder: [\"id\", \"value\", \"optional\", \"static\", \"method\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    value: validateType(\"FlowType\"),\n    optional: validate(assertValueType(\"boolean\")),\n    static: validate(assertValueType(\"boolean\")),\n    method: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    value: validateType(\"FlowType\"),\n    static: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeIndexer\", {\n  visitor: [\"variance\", \"id\", \"key\", \"value\"],\n  builder: [\"id\", \"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    id: validateOptionalType(\"Identifier\"),\n    key: validateType(\"FlowType\"),\n    value: validateType(\"FlowType\"),\n    static: validate(assertValueType(\"boolean\")),\n    variance: validateOptionalType(\"Variance\"),\n  },\n});\n\ndefineType(\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\", \"variance\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    key: validateType(\"Identifier\", \"StringLiteral\"),\n    value: validateType(\"FlowType\"),\n    kind: validate(assertOneOf(\"init\", \"get\", \"set\")),\n    static: validate(assertValueType(\"boolean\")),\n    proto: validate(assertValueType(\"boolean\")),\n    optional: validate(assertValueType(\"boolean\")),\n    variance: validateOptionalType(\"Variance\"),\n    method: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"ObjectTypeSpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UserWhitespacable\"],\n  fields: {\n    argument: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"OpaqueType\", {\n  visitor: [\"id\", \"typeParameters\", \"supertype\", \"impltype\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    supertype: validateOptionalType(\"FlowType\"),\n    impltype: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"QualifiedTypeIdentifier\", {\n  visitor: [\"qualification\", \"id\"],\n  builder: [\"id\", \"qualification\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    qualification: validateType(\"Identifier\", \"QualifiedTypeIdentifier\"),\n  },\n});\n\ndefineType(\"StringLiteralTypeAnnotation\", {\n  builder: [\"value\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    value: validate(assertValueType(\"string\")),\n  },\n});\n\ndefineType(\"StringTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"SymbolTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"ThisTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\ndefineType(\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    argument: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"FlowDeclaration\", \"Statement\", \"Declaration\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TypeParameterDeclaration\"),\n    right: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"ExpressionWrapper\", \"Expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TypeAnnotation\"),\n  },\n});\n\ndefineType(\"TypeParameter\", {\n  visitor: [\"bound\", \"default\", \"variance\"],\n  fields: {\n    name: validate(assertValueType(\"string\")),\n    bound: validateOptionalType(\"TypeAnnotation\"),\n    default: validateOptionalType(\"FlowType\"),\n    variance: validateOptionalType(\"Variance\"),\n  },\n});\n\ndefineType(\"TypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validate(arrayOfType(\"TypeParameter\")),\n  },\n});\n\ndefineType(\"TypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    types: validate(arrayOfType(\"FlowType\")),\n  },\n});\n\ndefineType(\"Variance\", {\n  builder: [\"kind\"],\n  fields: {\n    kind: validate(assertOneOf(\"minus\", \"plus\")),\n  },\n});\n\ndefineType(\"VoidTypeAnnotation\", {\n  aliases: [\"FlowType\", \"FlowBaseAnnotation\"],\n});\n\n// Enums\ndefineType(\"EnumDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    body: validateType(\n      \"EnumBooleanBody\",\n      \"EnumNumberBody\",\n      \"EnumStringBody\",\n      \"EnumSymbolBody\",\n    ),\n  },\n});\n\ndefineType(\"EnumBooleanBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: validate(assertValueType(\"boolean\")),\n    members: validateArrayOfType(\"EnumBooleanMember\"),\n    hasUnknownMembers: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"EnumNumberBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: validate(assertValueType(\"boolean\")),\n    members: validateArrayOfType(\"EnumNumberMember\"),\n    hasUnknownMembers: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"EnumStringBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    explicitType: validate(assertValueType(\"boolean\")),\n    members: validateArrayOfType(\"EnumStringMember\", \"EnumDefaultedMember\"),\n    hasUnknownMembers: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"EnumSymbolBody\", {\n  aliases: [\"EnumBody\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"EnumDefaultedMember\"),\n    hasUnknownMembers: validate(assertValueType(\"boolean\")),\n  },\n});\n\ndefineType(\"EnumBooleanMember\", {\n  aliases: [\"EnumMember\"],\n  builder: [\"id\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"BooleanLiteral\"),\n  },\n});\n\ndefineType(\"EnumNumberMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"NumericLiteral\"),\n  },\n});\n\ndefineType(\"EnumStringMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\", \"init\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    init: validateType(\"StringLiteral\"),\n  },\n});\n\ndefineType(\"EnumDefaultedMember\", {\n  aliases: [\"EnumMember\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"IndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: validateType(\"FlowType\"),\n    indexType: validateType(\"FlowType\"),\n  },\n});\n\ndefineType(\"OptionalIndexedAccessType\", {\n  visitor: [\"objectType\", \"indexType\"],\n  aliases: [\"FlowType\"],\n  fields: {\n    objectType: validateType(\"FlowType\"),\n    indexType: validateType(\"FlowType\"),\n    optional: validate(assertValueType(\"boolean\")),\n  },\n});\n","import {\n  defineAliasedType,\n  assertNodeType,\n  assertValueType,\n  validateArrayOfType,\n} from \"./utils.ts\";\n\nconst defineType = defineAliasedType(\"JSX\");\n\ndefineType(\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\"JSXIdentifier\", \"JSXNamespacedName\"),\n    },\n    value: {\n      optional: true,\n      validate: assertNodeType(\n        \"JSXElement\",\n        \"JSXFragment\",\n        \"StringLiteral\",\n        \"JSXExpressionContainer\",\n      ),\n    },\n  },\n});\n\ndefineType(\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\n        \"JSXIdentifier\",\n        \"JSXMemberExpression\",\n        \"JSXNamespacedName\",\n      ),\n    },\n  },\n});\n\ndefineType(\"JSXElement\", {\n  builder: [\"openingElement\", \"closingElement\", \"children\"],\n  visitor: [\"openingElement\", \"children\", \"closingElement\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: {\n    openingElement: {\n      validate: assertNodeType(\"JSXOpeningElement\"),\n    },\n    closingElement: {\n      optional: true,\n      validate: assertNodeType(\"JSXClosingElement\"),\n    },\n    children: validateArrayOfType(\n      \"JSXText\",\n      \"JSXExpressionContainer\",\n      \"JSXSpreadChild\",\n      \"JSXElement\",\n      \"JSXFragment\",\n    ),\n  },\n});\n\ndefineType(\"JSXEmptyExpression\", {});\n\ndefineType(\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\", \"JSXEmptyExpression\"),\n    },\n  },\n});\n\ndefineType(\"JSXSpreadChild\", {\n  visitor: [\"expression\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"JSXIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"JSXMemberExpression\", \"JSXIdentifier\"),\n    },\n    property: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n  },\n});\n\ndefineType(\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  fields: {\n    namespace: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n    name: {\n      validate: assertNodeType(\"JSXIdentifier\"),\n    },\n  },\n});\n\ndefineType(\"JSXOpeningElement\", {\n  builder: [\"name\", \"attributes\", \"selfClosing\"],\n  visitor: [\"name\", \"typeArguments\", \"attributes\"],\n  aliases: [\"Immutable\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\n        \"JSXIdentifier\",\n        \"JSXMemberExpression\",\n        \"JSXNamespacedName\",\n      ),\n    },\n    selfClosing: {\n      default: false,\n    },\n    attributes: validateArrayOfType(\"JSXAttribute\", \"JSXSpreadAttribute\"),\n    typeArguments: {\n      validate: assertNodeType(\n        \"TypeParameterInstantiation\",\n        \"TSTypeParameterInstantiation\",\n      ),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  fields: {\n    argument: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"JSXText\", {\n  aliases: [\"Immutable\"],\n  builder: [\"value\"],\n  fields: {\n    value: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n\ndefineType(\"JSXFragment\", {\n  builder: [\"openingFragment\", \"closingFragment\", \"children\"],\n  visitor: [\"openingFragment\", \"children\", \"closingFragment\"],\n  aliases: [\"Immutable\", \"Expression\"],\n  fields: {\n    openingFragment: {\n      validate: assertNodeType(\"JSXOpeningFragment\"),\n    },\n    closingFragment: {\n      validate: assertNodeType(\"JSXClosingFragment\"),\n    },\n    children: validateArrayOfType(\n      \"JSXText\",\n      \"JSXExpressionContainer\",\n      \"JSXSpreadChild\",\n      \"JSXElement\",\n      \"JSXFragment\",\n    ),\n  },\n});\n\ndefineType(\"JSXOpeningFragment\", {\n  aliases: [\"Immutable\"],\n});\n\ndefineType(\"JSXClosingFragment\", {\n  aliases: [\"Immutable\"],\n});\n","import { ALIAS_KEYS } from \"./utils.ts\";\n\nexport const PLACEHOLDERS = [\n  \"Identifier\",\n  \"StringLiteral\",\n  \"Expression\",\n  \"Statement\",\n  \"Declaration\",\n  \"BlockStatement\",\n  \"ClassBody\",\n  \"Pattern\",\n] as const;\n\nexport const PLACEHOLDERS_ALIAS: Record<string, string[]> = {\n  Declaration: [\"Statement\"],\n  Pattern: [\"PatternLike\", \"LVal\"],\n};\n\nfor (const type of PLACEHOLDERS) {\n  const alias = ALIAS_KEYS[type];\n  if (alias?.length) PLACEHOLDERS_ALIAS[type] = alias;\n}\n\nexport const PLACEHOLDERS_FLIPPED_ALIAS: Record<string, string[]> = {};\n\nObject.keys(PLACEHOLDERS_ALIAS).forEach(type => {\n  PLACEHOLDERS_ALIAS[type].forEach(alias => {\n    if (!Object.hasOwn(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {\n      PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];\n    }\n    PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);\n  });\n});\n","import {\n  defineAliasedType,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n} from \"./utils.ts\";\nimport { PLACEHOLDERS } from \"./placeholders.ts\";\nimport { patternLikeCommon } from \"./core.ts\";\n\nconst defineType = defineAliasedType(\"Miscellaneous\");\n\ndefineType(\"Placeholder\", {\n  visitor: [],\n  builder: [\"expectedNode\", \"name\"],\n  // aliases: [], defined in placeholders.js\n  fields: {\n    name: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    expectedNode: {\n      validate: assertOneOf(...PLACEHOLDERS),\n    },\n    ...patternLikeCommon(),\n  },\n});\n\ndefineType(\"V8IntrinsicIdentifier\", {\n  builder: [\"name\"],\n  fields: {\n    name: {\n      validate: assertValueType(\"string\"),\n    },\n  },\n});\n","import defineType, { assertNodeType, assertValueType } from \"./utils.ts\";\n\ndefineType(\"ArgumentPlaceholder\", {});\n\ndefineType(\"BindExpression\", {\n  visitor: [\"object\", \"callee\"],\n  aliases: [\"Expression\"],\n  fields: {\n    object: {\n      validate: assertNodeType(\"Expression\"),\n    },\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"Decorator\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n});\n\ndefineType(\"DoExpression\", {\n  visitor: [\"body\"],\n  builder: [\"body\", \"async\"],\n  aliases: [\"Expression\"],\n  fields: {\n    body: {\n      validate: assertNodeType(\"BlockStatement\"),\n    },\n    async: {\n      validate: assertValueType(\"boolean\"),\n      default: false,\n    },\n  },\n});\n\ndefineType(\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"],\n  fields: {\n    exported: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n  },\n});\n\n// https://github.com/tc39/proposal-js-module-blocks\ndefineType(\"ModuleExpression\", {\n  visitor: [\"body\"],\n  fields: {\n    body: {\n      validate: assertNodeType(\"Program\"),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\n// https://github.com/tc39/proposal-pipeline-operator\n// https://github.com/js-choi/proposal-hack-pipes\ndefineType(\"TopicReference\", {\n  aliases: [\"Expression\"],\n});\n\n// https://github.com/tc39/proposal-pipeline-operator\n// https://github.com/js-choi/proposal-smart-pipes\ndefineType(\"PipelineTopicExpression\", {\n  builder: [\"expression\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"PipelineBareFunction\", {\n  builder: [\"callee\"],\n  visitor: [\"callee\"],\n  fields: {\n    callee: {\n      validate: assertNodeType(\"Expression\"),\n    },\n  },\n  aliases: [\"Expression\"],\n});\n\ndefineType(\"PipelinePrimaryTopicReference\", {\n  aliases: [\"Expression\"],\n});\n\n// https://github.com/tc39/proposal-discard-binding\ndefineType(\"VoidPattern\", {\n  aliases: [\"Pattern\", \"PatternLike\", \"FunctionParameter\"],\n});\n","import type * as t from \"../index.ts\";\nimport {\n  defineAliasedType,\n  arrayOfType,\n  assertEach,\n  assertNodeType,\n  assertOneOf,\n  assertValueType,\n  chain,\n  validateArrayOfType,\n  validateOptional,\n  validateOptionalType,\n  validateType,\n  type ValidatorImpl,\n  type ValidatorOneOfNodeTypes,\n} from \"./utils.ts\";\nimport {\n  functionDeclarationCommon,\n  classMethodOrDeclareMethodCommon,\n  classMethodOrPropertyUnionShapeCommon,\n} from \"./core.ts\";\nimport is from \"../validators/is.ts\";\n\nconst defineType = defineAliasedType(\"TypeScript\");\n\nconst bool = assertValueType(\"boolean\");\n\nconst tSFunctionTypeAnnotationCommon = () => ({\n  returnType: {\n    validate: assertNodeType(\"TSTypeAnnotation\"),\n\n    optional: true,\n  },\n  typeParameters: {\n    validate: assertNodeType(\"TSTypeParameterDeclaration\"),\n\n    optional: true,\n  },\n});\n\ndefineType(\"TSParameterProperty\", {\n  aliases: [],\n  visitor: [\"parameter\"],\n  fields: {\n    accessibility: {\n      validate: assertOneOf(\"public\", \"private\", \"protected\"),\n      optional: true,\n    },\n    readonly: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    parameter: {\n      validate: assertNodeType(\"Identifier\", \"AssignmentPattern\"),\n    },\n    override: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    decorators: {\n      validate: arrayOfType(\"Decorator\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSDeclareFunction\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...functionDeclarationCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSDeclareMethod\", {\n  visitor: [\"decorators\", \"key\", \"typeParameters\", \"params\", \"returnType\"],\n  ...classMethodOrPropertyUnionShapeCommon(),\n  fields: {\n    ...classMethodOrDeclareMethodCommon(),\n    ...tSFunctionTypeAnnotationCommon(),\n  },\n});\n\ndefineType(\"TSQualifiedName\", {\n  aliases: [\"TSEntityName\"],\n  visitor: [\"left\", \"right\"],\n  fields: {\n    left: validateType(\"TSEntityName\"),\n    right: validateType(\"Identifier\"),\n  },\n});\n\nconst signatureDeclarationCommon = () => ({\n  typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n  [\"params\"]: validateArrayOfType(\n    \"ArrayPattern\",\n    \"Identifier\",\n    \"ObjectPattern\",\n    \"RestElement\",\n  ),\n  [\"returnType\"]: validateOptionalType(\"TSTypeAnnotation\"),\n});\n\nconst callConstructSignatureDeclaration = {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"typeParameters\", \"params\", \"returnType\"],\n  fields: signatureDeclarationCommon(),\n};\n\ndefineType(\"TSCallSignatureDeclaration\", callConstructSignatureDeclaration);\ndefineType(\n  \"TSConstructSignatureDeclaration\",\n  callConstructSignatureDeclaration,\n);\n\nconst namedTypeElementCommon = () => ({\n  key: validateType(\"Expression\"),\n  computed: { default: false },\n  optional: validateOptional(bool),\n});\n\ndefineType(\"TSPropertySignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeAnnotation\"],\n  fields: {\n    ...namedTypeElementCommon(),\n    readonly: validateOptional(bool),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    kind: {\n      optional: true,\n      validate: assertOneOf(\"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSMethodSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"key\", \"typeParameters\", \"params\", \"returnType\"],\n  fields: {\n    ...signatureDeclarationCommon(),\n    ...namedTypeElementCommon(),\n    kind: {\n      validate: assertOneOf(\"method\", \"get\", \"set\"),\n    },\n  },\n});\n\ndefineType(\"TSIndexSignature\", {\n  aliases: [\"TSTypeElement\"],\n  visitor: [\"parameters\", \"typeAnnotation\"],\n  fields: {\n    readonly: validateOptional(bool),\n    static: validateOptional(bool),\n    parameters: validateArrayOfType(\"Identifier\"), // Length must be 1\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n  },\n});\n\nconst tsKeywordTypes = [\n  \"TSAnyKeyword\",\n  \"TSBooleanKeyword\",\n  \"TSBigIntKeyword\",\n  \"TSIntrinsicKeyword\",\n  \"TSNeverKeyword\",\n  \"TSNullKeyword\",\n  \"TSNumberKeyword\",\n  \"TSObjectKeyword\",\n  \"TSStringKeyword\",\n  \"TSSymbolKeyword\",\n  \"TSUndefinedKeyword\",\n  \"TSUnknownKeyword\",\n  \"TSVoidKeyword\",\n] as const;\n\nfor (const type of tsKeywordTypes) {\n  defineType(type, {\n    aliases: [\"TSType\", \"TSBaseType\"],\n    visitor: [],\n    fields: {},\n  });\n}\n\ndefineType(\"TSThisType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [],\n  fields: {},\n});\n\nconst fnOrCtrBase = {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameters\", \"params\", \"returnType\"],\n};\n\ndefineType(\"TSFunctionType\", {\n  ...fnOrCtrBase,\n  fields: signatureDeclarationCommon(),\n});\ndefineType(\"TSConstructorType\", {\n  ...fnOrCtrBase,\n  fields: {\n    ...signatureDeclarationCommon(),\n    abstract: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeReference\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeName\", \"typeArguments\"],\n  fields: {\n    typeName: validateType(\"TSEntityName\"),\n    [\"typeArguments\"]: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypePredicate\", {\n  aliases: [\"TSType\"],\n  visitor: [\"parameterName\", \"typeAnnotation\"],\n  builder: [\"parameterName\", \"typeAnnotation\", \"asserts\"],\n  fields: {\n    parameterName: validateType(\"Identifier\", \"TSThisType\"),\n    typeAnnotation: validateOptionalType(\"TSTypeAnnotation\"),\n    asserts: validateOptional(bool),\n  },\n});\n\ndefineType(\"TSTypeQuery\", {\n  aliases: [\"TSType\"],\n  visitor: [\"exprName\", \"typeArguments\"],\n  fields: {\n    exprName: validateType(\"TSEntityName\", \"TSImportType\"),\n    [\"typeArguments\"]: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSTypeLiteral\", {\n  aliases: [\"TSType\"],\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSArrayType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementType\"],\n  fields: {\n    elementType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTupleType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"elementTypes\"],\n  fields: {\n    elementTypes: validateArrayOfType(\"TSType\", \"TSNamedTupleMember\"),\n  },\n});\n\ndefineType(\"TSOptionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSRestType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSNamedTupleMember\", {\n  visitor: [\"label\", \"elementType\"],\n  builder: [\"label\", \"elementType\", \"optional\"],\n  fields: {\n    label: validateType(\"Identifier\"),\n    optional: {\n      validate: bool,\n      default: false,\n    },\n    elementType: validateType(\"TSType\"),\n  },\n});\n\nconst unionOrIntersection = {\n  aliases: [\"TSType\"],\n  visitor: [\"types\"],\n  fields: {\n    types: validateArrayOfType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSUnionType\", unionOrIntersection);\ndefineType(\"TSIntersectionType\", unionOrIntersection);\n\ndefineType(\"TSConditionalType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"checkType\", \"extendsType\", \"trueType\", \"falseType\"],\n  fields: {\n    checkType: validateType(\"TSType\"),\n    extendsType: validateType(\"TSType\"),\n    trueType: validateType(\"TSType\"),\n    falseType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInferType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeParameter\"],\n  fields: {\n    typeParameter: validateType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSParenthesizedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeOperator\", {\n  aliases: [\"TSType\"],\n  visitor: [\"typeAnnotation\"],\n  builder: [\"typeAnnotation\", \"operator\"],\n  fields: {\n    operator: {\n      validate: assertOneOf(\"keyof\", \"readonly\", \"unique\"),\n      // \"keyof\" is not a good default, but as this field is required better\n      // pick one. We need it for backwards compatibility with older versions\n      // of Babel 7.\n      default: undefined,\n    },\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSIndexedAccessType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"objectType\", \"indexType\"],\n  fields: {\n    objectType: validateType(\"TSType\"),\n    indexType: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSMappedType\", {\n  aliases: [\"TSType\"],\n  visitor: [\"key\", \"constraint\", \"nameType\", \"typeAnnotation\"],\n  builder: [\"key\", \"constraint\", \"nameType\", \"typeAnnotation\"],\n  fields: {\n    key: validateType(\"Identifier\"),\n    constraint: validateType(\"TSType\"),\n\n    readonly: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    optional: validateOptional(assertOneOf(true, false, \"+\", \"-\")),\n    typeAnnotation: validateOptionalType(\"TSType\"),\n    nameType: validateOptionalType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTemplateLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"quasis\", \"types\"],\n  fields: {\n    quasis: validateArrayOfType(\"TemplateElement\"),\n    types: {\n      validate: chain(\n        assertValueType(\"array\"),\n        assertEach(assertNodeType(\"TSType\")),\n        function (node: t.TSTemplateLiteralType, key, val) {\n          if (node.quasis.length !== val.length + 1) {\n            throw new TypeError(\n              `Number of ${\n                node.type\n              } quasis should be exactly one more than the number of types.\\nExpected ${\n                val.length + 1\n              } quasis but got ${node.quasis.length}`,\n            );\n          }\n        } satisfies ValidatorImpl,\n      ),\n    },\n  },\n});\n\ndefineType(\"TSLiteralType\", {\n  aliases: [\"TSType\", \"TSBaseType\"],\n  visitor: [\"literal\"],\n  fields: {\n    literal: {\n      validate: (function () {\n        const unaryExpression = assertNodeType(\n          \"NumericLiteral\",\n          \"BigIntLiteral\",\n        );\n        const unaryOperator = assertOneOf(\"-\");\n\n        const literal = assertNodeType(\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n        );\n        const validator: ValidatorOneOfNodeTypes = function validator(\n          parent: t.Node,\n          key: string,\n          node: t.Node,\n        ) {\n          // type A = -1 | 1;\n          if (is(\"UnaryExpression\", node)) {\n            // check operator first\n            unaryOperator(node, \"operator\", node.operator);\n            unaryExpression(node, \"argument\", node.argument);\n          } else {\n            // type A = 'foo' | 'bar' | false | 1;\n            literal(parent, key, node);\n          }\n        };\n\n        validator.oneOfNodeTypes = [\n          \"NumericLiteral\",\n          \"StringLiteral\",\n          \"BooleanLiteral\",\n          \"BigIntLiteral\",\n          \"TemplateLiteral\",\n          \"UnaryExpression\",\n        ];\n\n        return validator;\n      })(),\n    },\n  },\n});\n\ndefineType(\"TSClassImplements\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeArguments\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeArguments: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\ndefineType(\"TSInterfaceHeritage\", {\n  aliases: [\"TSType\"],\n  visitor: [\"expression\", \"typeArguments\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeArguments: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\ndefineType(\"TSInterfaceDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    extends: validateOptional(arrayOfType(\"TSClassImplements\")),\n    body: validateType(\"TSInterfaceBody\"),\n  },\n});\n\ndefineType(\"TSInterfaceBody\", {\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"TSTypeElement\"),\n  },\n});\n\ndefineType(\"TSTypeAliasDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"typeParameters\", \"typeAnnotation\"],\n  fields: {\n    declare: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n    typeParameters: validateOptionalType(\"TSTypeParameterDeclaration\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSInstantiationExpression\", {\n  aliases: [\"Expression\"],\n  visitor: [\"expression\", \"typeArguments\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    [\"typeArguments\"]: validateOptionalType(\"TSTypeParameterInstantiation\"),\n  },\n});\n\nconst TSTypeExpression = {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\", \"typeAnnotation\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n    typeAnnotation: validateType(\"TSType\"),\n  },\n};\n\ndefineType(\"TSAsExpression\", TSTypeExpression);\ndefineType(\"TSSatisfiesExpression\", TSTypeExpression);\n\ndefineType(\"TSTypeAssertion\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"typeAnnotation\", \"expression\"],\n  fields: {\n    typeAnnotation: validateType(\"TSType\"),\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSEnumBody\", {\n  visitor: [\"members\"],\n  fields: {\n    members: validateArrayOfType(\"TSEnumMember\"),\n  },\n});\n\ndefineType(\"TSEnumDeclaration\", {\n  // \"Statement\" alias prevents a semicolon from appearing after it in an export declaration.\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    declare: validateOptional(bool),\n    const: validateOptional(bool),\n    id: validateType(\"Identifier\"),\n\n    body: validateType(\"TSEnumBody\"),\n  },\n});\n\ndefineType(\"TSEnumMember\", {\n  visitor: [\"id\", \"initializer\"],\n  fields: {\n    id: validateType(\"Identifier\", \"StringLiteral\"),\n    initializer: validateOptionalType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSModuleDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"body\"],\n  fields: {\n    kind: {\n      validate: assertOneOf(\"global\", \"module\", \"namespace\"),\n    },\n    declare: validateOptional(bool),\n    id: {\n      validate: chain(\n        assertNodeType(\"TSEntityName\", \"StringLiteral\"),\n        Object.assign(\n          function (\n            node: t.TSModuleDeclaration,\n            key: string,\n            val: t.TSEntityName | t.StringLiteral,\n          ) {\n            if (node.kind === \"module\" && !is(\"StringLiteral\", val)) {\n              throw new TypeError(\n                `TSModuleDeclaration of kind 'module' must have a StringLiteral id.`,\n              );\n            }\n            if (node.kind === \"namespace\" && is(\"StringLiteral\", val)) {\n              throw new TypeError(\n                `TSModuleDeclaration of kind 'namespace' cannot have a StringLiteral id.`,\n              );\n            }\n          } satisfies ValidatorImpl,\n          { oneOfNodeTypes: [\"TSEntityName\", \"StringLiteral\"] as const },\n        ) satisfies ValidatorOneOfNodeTypes,\n      ),\n    },\n    body: validateType(\"TSModuleBlock\"),\n  },\n});\n\ndefineType(\"TSModuleBlock\", {\n  aliases: [\"Scopable\", \"Block\", \"BlockParent\", \"FunctionParent\"],\n  visitor: [\"body\"],\n  fields: {\n    body: validateArrayOfType(\"Statement\"),\n  },\n});\n\ndefineType(\"TSImportType\", {\n  aliases: [\"TSType\"],\n  builder: [\"source\", \"qualifier\", \"typeArguments\"],\n  visitor: [\"source\", \"options\", \"qualifier\", \"typeArguments\"],\n  fields: {\n    source: validateType(\"StringLiteral\"),\n    qualifier: validateOptionalType(\"TSEntityName\"),\n\n    typeArguments: validateOptionalType(\"TSTypeParameterInstantiation\"),\n\n    options: {\n      validate: assertNodeType(\"ObjectExpression\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSImportEqualsDeclaration\", {\n  aliases: [\"Statement\", \"Declaration\"],\n  visitor: [\"id\", \"moduleReference\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n    moduleReference: validateType(\"TSEntityName\", \"TSExternalModuleReference\"),\n    importKind: {\n      validate: assertOneOf(\"type\", \"value\"),\n      optional: true,\n    },\n  },\n});\n\ndefineType(\"TSExternalModuleReference\", {\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"StringLiteral\"),\n  },\n});\n\ndefineType(\"TSNonNullExpression\", {\n  aliases: [\"Expression\", \"LVal\", \"PatternLike\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSExportAssignment\", {\n  aliases: [\"Statement\"],\n  visitor: [\"expression\"],\n  fields: {\n    expression: validateType(\"Expression\"),\n  },\n});\n\ndefineType(\"TSNamespaceExportDeclaration\", {\n  aliases: [\"Statement\"],\n  visitor: [\"id\"],\n  fields: {\n    id: validateType(\"Identifier\"),\n  },\n});\n\ndefineType(\"TSTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  fields: {\n    typeAnnotation: {\n      validate: assertNodeType(\"TSType\"),\n    },\n  },\n});\n\ndefineType(\"TSTypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validateArrayOfType(\"TSType\"),\n  },\n});\n\ndefineType(\"TSTypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  fields: {\n    params: validateArrayOfType(\"TSTypeParameter\"),\n  },\n});\n\ndefineType(\"TSTypeParameter\", {\n  builder: [\"constraint\", \"default\", \"name\"],\n  visitor: [\"name\", \"constraint\", \"default\"],\n  fields: {\n    name: {\n      validate: assertNodeType(\"Identifier\"),\n    },\n    in: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    out: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    const: {\n      validate: assertValueType(\"boolean\"),\n      optional: true,\n    },\n    constraint: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n    default: {\n      validate: assertNodeType(\"TSType\"),\n      optional: true,\n    },\n  },\n});\n","export const DEPRECATED_ALIASES = {\n  ModuleDeclaration: \"ImportOrExportDeclaration\",\n};\n","import \"./core.ts\";\nimport \"./flow.ts\";\nimport \"./jsx.ts\";\nimport \"./misc.ts\";\nimport \"./experimental.ts\";\nimport \"./typescript.ts\";\nimport {\n  VISITOR_KEYS,\n  ALIAS_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  NODE_FIELDS,\n  BUILDER_KEYS,\n  DEPRECATED_KEYS,\n  NODE_PARENT_VALIDATIONS,\n  NODE_UNION_SHAPES__PRIVATE,\n  allExpandedTypes,\n} from \"./utils.ts\";\nimport {\n  PLACEHOLDERS,\n  PLACEHOLDERS_ALIAS,\n  PLACEHOLDERS_FLIPPED_ALIAS,\n} from \"./placeholders.ts\";\nimport { DEPRECATED_ALIASES } from \"./deprecated-aliases.ts\";\n\n(\n  Object.keys(DEPRECATED_ALIASES) as (keyof typeof DEPRECATED_ALIASES)[]\n).forEach(deprecatedAlias => {\n  FLIPPED_ALIAS_KEYS[deprecatedAlias] =\n    FLIPPED_ALIAS_KEYS[DEPRECATED_ALIASES[deprecatedAlias]];\n});\n\nfor (const { types, set } of allExpandedTypes) {\n  for (const type of types) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      aliases.forEach(set.add, set);\n    } else {\n      set.add(type);\n    }\n  }\n}\n\nconst TYPES: string[] = [].concat(\n  Object.keys(VISITOR_KEYS),\n  Object.keys(FLIPPED_ALIAS_KEYS),\n  Object.keys(DEPRECATED_KEYS),\n);\n\n/**\n * @internal\n */\nexport { NODE_UNION_SHAPES__PRIVATE };\n\nexport {\n  VISITOR_KEYS,\n  ALIAS_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  NODE_FIELDS,\n  BUILDER_KEYS,\n  DEPRECATED_ALIASES,\n  DEPRECATED_KEYS,\n  NODE_PARENT_VALIDATIONS,\n  PLACEHOLDERS,\n  PLACEHOLDERS_ALIAS,\n  PLACEHOLDERS_FLIPPED_ALIAS,\n  TYPES,\n};\n\nexport type { FieldOptions } from \"./utils.ts\";\n","import {\n  NODE_FIELDS,\n  NODE_PARENT_VALIDATIONS,\n  type FieldOptions,\n} from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function validate(\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n): void {\n  if (!node) return;\n\n  const fields = NODE_FIELDS[node.type];\n  if (!fields) return;\n\n  const field = fields[key];\n  validateField(node, key, val, field);\n  validateChild(node, key, val);\n}\n\nexport function validateInternal(\n  field: FieldOptions,\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n  maybeNode?: 1,\n): void {\n  if (!field?.validate) return;\n  if (field.optional && val == null) return;\n\n  field.validate(node, key, val);\n\n  if (maybeNode) {\n    const type = (val as t.Node).type;\n    if (type == null) return;\n    NODE_PARENT_VALIDATIONS[type]?.(node, key, val);\n  }\n}\n\nexport function validateField(\n  node: t.Node | undefined | null,\n  key: string,\n  val: unknown,\n  field: FieldOptions | undefined | null,\n): void {\n  if (!field?.validate) return;\n  if (field.optional && val == null) return;\n\n  field.validate(node, key, val);\n}\n\nexport function validateChild(\n  node: t.Node | undefined | null,\n  key: string | { toString(): string },\n  val?: unknown,\n) {\n  const type = (val as t.Node)?.type;\n  if (type == null) return;\n  NODE_PARENT_VALIDATIONS[type]?.(node, key, val);\n}\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport * as _validate from \"../../validators/validate.ts\";\nimport type * as t from \"../../ast-types/generated/index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\nimport * as utils from \"../../definitions/utils.ts\";\n\nconst { validateInternal: validate } = _validate;\nconst { NODE_FIELDS } = utils;\n\nexport function arrayExpression(\n  elements: (null | t.Expression | t.SpreadElement)[],\n): t.ArrayExpression {\n  const node: t.ArrayExpression = {\n    type: \"ArrayExpression\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayExpression;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function assignmentExpression(\n  operator:\n    | \"=\"\n    | \"+=\"\n    | \"-=\"\n    | \"/=\"\n    | \"%=\"\n    | \"*=\"\n    | \"**=\"\n    | \"&=\"\n    | \"|=\"\n    | \">>=\"\n    | \">>>=\"\n    | \"<<=\"\n    | \"^=\"\n    | \"||=\"\n    | \"&&=\"\n    | \"??=\",\n  left:\n    | t.Identifier\n    | t.MemberExpression\n    | t.OptionalMemberExpression\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n): t.AssignmentExpression {\n  const node: t.AssignmentExpression = {\n    type: \"AssignmentExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function binaryExpression(\n  operator:\n    | \"+\"\n    | \"-\"\n    | \"/\"\n    | \"%\"\n    | \"*\"\n    | \"**\"\n    | \"&\"\n    | \"|\"\n    | \">>\"\n    | \">>>\"\n    | \"<<\"\n    | \"^\"\n    | \"==\"\n    | \"===\"\n    | \"!=\"\n    | \"!==\"\n    | \"in\"\n    | \"instanceof\"\n    | \">\"\n    | \"<\"\n    | \">=\"\n    | \"<=\"\n    | \"|>\",\n  left: t.Expression | t.PrivateName,\n  right: t.Expression,\n): t.BinaryExpression {\n  const node: t.BinaryExpression = {\n    type: \"BinaryExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.BinaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function interpreterDirective(value: string): t.InterpreterDirective {\n  const node: t.InterpreterDirective = {\n    type: \"InterpreterDirective\",\n    value,\n  };\n  const defs = NODE_FIELDS.InterpreterDirective;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function directive(value: t.DirectiveLiteral): t.Directive {\n  const node: t.Directive = {\n    type: \"Directive\",\n    value,\n  };\n  const defs = NODE_FIELDS.Directive;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function directiveLiteral(value: string): t.DirectiveLiteral {\n  const node: t.DirectiveLiteral = {\n    type: \"DirectiveLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.DirectiveLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function blockStatement(\n  body: t.Statement[],\n  directives: t.Directive[] = [],\n): t.BlockStatement {\n  const node: t.BlockStatement = {\n    type: \"BlockStatement\",\n    body,\n    directives,\n  };\n  const defs = NODE_FIELDS.BlockStatement;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  return node;\n}\nexport function breakStatement(\n  label: t.Identifier | null = null,\n): t.BreakStatement {\n  const node: t.BreakStatement = {\n    type: \"BreakStatement\",\n    label,\n  };\n  const defs = NODE_FIELDS.BreakStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nexport function callExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: (t.Expression | t.SpreadElement | t.ArgumentPlaceholder)[],\n): t.CallExpression {\n  const node: t.CallExpression = {\n    type: \"CallExpression\",\n    callee,\n    arguments: _arguments,\n  };\n  const defs = NODE_FIELDS.CallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nexport function catchClause(\n  param:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | null\n    | undefined = null,\n  body: t.BlockStatement,\n): t.CatchClause {\n  const node: t.CatchClause = {\n    type: \"CatchClause\",\n    param,\n    body,\n  };\n  const defs = NODE_FIELDS.CatchClause;\n  validate(defs.param, node, \"param\", param, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function conditionalExpression(\n  test: t.Expression,\n  consequent: t.Expression,\n  alternate: t.Expression,\n): t.ConditionalExpression {\n  const node: t.ConditionalExpression = {\n    type: \"ConditionalExpression\",\n    test,\n    consequent,\n    alternate,\n  };\n  const defs = NODE_FIELDS.ConditionalExpression;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nexport function continueStatement(\n  label: t.Identifier | null = null,\n): t.ContinueStatement {\n  const node: t.ContinueStatement = {\n    type: \"ContinueStatement\",\n    label,\n  };\n  const defs = NODE_FIELDS.ContinueStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  return node;\n}\nexport function debuggerStatement(): t.DebuggerStatement {\n  return {\n    type: \"DebuggerStatement\",\n  };\n}\nexport function doWhileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.DoWhileStatement {\n  const node: t.DoWhileStatement = {\n    type: \"DoWhileStatement\",\n    test,\n    body,\n  };\n  const defs = NODE_FIELDS.DoWhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function emptyStatement(): t.EmptyStatement {\n  return {\n    type: \"EmptyStatement\",\n  };\n}\nexport function expressionStatement(\n  expression: t.Expression,\n): t.ExpressionStatement {\n  const node: t.ExpressionStatement = {\n    type: \"ExpressionStatement\",\n    expression,\n  };\n  const defs = NODE_FIELDS.ExpressionStatement;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function file(\n  program: t.Program,\n  comments: (t.CommentBlock | t.CommentLine)[] | null = null,\n  tokens: any[] | null = null,\n): t.File {\n  const node: t.File = {\n    type: \"File\",\n    program,\n    comments,\n    tokens,\n  };\n  const defs = NODE_FIELDS.File;\n  validate(defs.program, node, \"program\", program, 1);\n  validate(defs.comments, node, \"comments\", comments, 1);\n  validate(defs.tokens, node, \"tokens\", tokens);\n  return node;\n}\nexport function forInStatement(\n  left:\n    | t.VariableDeclaration\n    | t.Identifier\n    | t.MemberExpression\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n  body: t.Statement,\n): t.ForInStatement {\n  const node: t.ForInStatement = {\n    type: \"ForInStatement\",\n    left,\n    right,\n    body,\n  };\n  const defs = NODE_FIELDS.ForInStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function forStatement(\n  init: t.VariableDeclaration | t.Expression | null | undefined = null,\n  test: t.Expression | null | undefined = null,\n  update: t.Expression | null | undefined = null,\n  body: t.Statement,\n): t.ForStatement {\n  const node: t.ForStatement = {\n    type: \"ForStatement\",\n    init,\n    test,\n    update,\n    body,\n  };\n  const defs = NODE_FIELDS.ForStatement;\n  validate(defs.init, node, \"init\", init, 1);\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.update, node, \"update\", update, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function functionDeclaration(\n  id: t.Identifier | null | undefined = null,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionDeclaration {\n  const node: t.FunctionDeclaration = {\n    type: \"FunctionDeclaration\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.FunctionDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function functionExpression(\n  id: t.Identifier | null | undefined = null,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  generator: boolean = false,\n  async: boolean = false,\n): t.FunctionExpression {\n  const node: t.FunctionExpression = {\n    type: \"FunctionExpression\",\n    id,\n    params,\n    body,\n    generator,\n    async,\n  };\n  const defs = NODE_FIELDS.FunctionExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function identifier(name: string): t.Identifier {\n  const node: t.Identifier = {\n    type: \"Identifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.Identifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function ifStatement(\n  test: t.Expression,\n  consequent: t.Statement,\n  alternate: t.Statement | null = null,\n): t.IfStatement {\n  const node: t.IfStatement = {\n    type: \"IfStatement\",\n    test,\n    consequent,\n    alternate,\n  };\n  const defs = NODE_FIELDS.IfStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  validate(defs.alternate, node, \"alternate\", alternate, 1);\n  return node;\n}\nexport function labeledStatement(\n  label: t.Identifier,\n  body: t.Statement,\n): t.LabeledStatement {\n  const node: t.LabeledStatement = {\n    type: \"LabeledStatement\",\n    label,\n    body,\n  };\n  const defs = NODE_FIELDS.LabeledStatement;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function stringLiteral(value: string): t.StringLiteral {\n  const node: t.StringLiteral = {\n    type: \"StringLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.StringLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function numericLiteral(value: number): t.NumericLiteral {\n  const node: t.NumericLiteral = {\n    type: \"NumericLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.NumericLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function nullLiteral(): t.NullLiteral {\n  return {\n    type: \"NullLiteral\",\n  };\n}\nexport function booleanLiteral(value: boolean): t.BooleanLiteral {\n  const node: t.BooleanLiteral = {\n    type: \"BooleanLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.BooleanLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function regExpLiteral(\n  pattern: string,\n  flags: string = \"\",\n): t.RegExpLiteral {\n  const node: t.RegExpLiteral = {\n    type: \"RegExpLiteral\",\n    pattern,\n    flags,\n  };\n  const defs = NODE_FIELDS.RegExpLiteral;\n  validate(defs.pattern, node, \"pattern\", pattern);\n  validate(defs.flags, node, \"flags\", flags);\n  return node;\n}\nexport function logicalExpression(\n  operator: \"||\" | \"&&\" | \"??\",\n  left: t.Expression,\n  right: t.Expression,\n): t.LogicalExpression {\n  const node: t.LogicalExpression = {\n    type: \"LogicalExpression\",\n    operator,\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.LogicalExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression,\n  computed?: true,\n): Extract<t.MemberExpression, { computed: true }>;\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Identifier | t.PrivateName,\n  computed?: false,\n): Extract<t.MemberExpression, { computed: false }>;\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression | t.Identifier | t.PrivateName,\n  computed?: boolean,\n): t.MemberExpression;\nexport function memberExpression(\n  object: t.Expression | t.Super,\n  property: t.Expression | t.Identifier | t.PrivateName,\n  computed: boolean = false,\n): t.MemberExpression {\n  const node = {\n    type: \"MemberExpression\",\n    object,\n    property,\n    computed,\n  } as t.MemberExpression;\n  const defs = NODE_FIELDS.MemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  return node;\n}\nexport function newExpression(\n  callee: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n  _arguments: (t.Expression | t.SpreadElement | t.ArgumentPlaceholder)[],\n): t.NewExpression {\n  const node: t.NewExpression = {\n    type: \"NewExpression\",\n    callee,\n    arguments: _arguments,\n  };\n  const defs = NODE_FIELDS.NewExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  return node;\n}\nexport function program(\n  body: t.Statement[],\n  directives: t.Directive[] = [],\n  sourceType: \"script\" | \"module\" = \"script\",\n  interpreter: t.InterpreterDirective | null = null,\n): t.Program {\n  const node: t.Program = {\n    type: \"Program\",\n    body,\n    directives,\n    sourceType,\n    interpreter,\n  };\n  const defs = NODE_FIELDS.Program;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.directives, node, \"directives\", directives, 1);\n  validate(defs.sourceType, node, \"sourceType\", sourceType);\n  validate(defs.interpreter, node, \"interpreter\", interpreter, 1);\n  return node;\n}\nexport function objectExpression(\n  properties: (t.ObjectMethod | t.ObjectProperty | t.SpreadElement)[],\n): t.ObjectExpression {\n  const node: t.ObjectExpression = {\n    type: \"ObjectExpression\",\n    properties,\n  };\n  const defs = NODE_FIELDS.ObjectExpression;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\",\n  key: t.Expression,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  computed?: true,\n  generator?: boolean,\n  async?: boolean,\n): Extract<t.ObjectMethod, { computed: true }>;\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\",\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  computed?: false,\n  generator?: boolean,\n  async?: boolean,\n): Extract<t.ObjectMethod, { computed: false }>;\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\",\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  computed?: boolean,\n  generator?: boolean,\n  async?: boolean,\n): t.ObjectMethod;\nexport function objectMethod(\n  kind: \"method\" | \"get\" | \"set\",\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral,\n  params: t.FunctionParameter[],\n  body: t.BlockStatement,\n  computed: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ObjectMethod {\n  const node = {\n    type: \"ObjectMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    generator,\n    async,\n  } as t.ObjectMethod;\n  const defs = NODE_FIELDS.ObjectMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function objectProperty(\n  key: t.Expression,\n  value: t.Expression | t.PatternLike,\n  computed?: true,\n  shorthand?: boolean,\n): Extract<t.ObjectProperty, { computed: true }>;\nexport function objectProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed?: false,\n  shorthand?: boolean,\n): Extract<t.ObjectProperty, { computed: false }>;\nexport function objectProperty(\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed?: boolean,\n  shorthand?: boolean,\n): t.ObjectProperty;\nexport function objectProperty(\n  key:\n    | t.Expression\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.PrivateName,\n  value: t.Expression | t.PatternLike,\n  computed: boolean = false,\n  shorthand: boolean = false,\n): t.ObjectProperty {\n  const node = {\n    type: \"ObjectProperty\",\n    key,\n    value,\n    computed,\n    shorthand,\n  } as t.ObjectProperty;\n  const defs = NODE_FIELDS.ObjectProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.shorthand, node, \"shorthand\", shorthand);\n  return node;\n}\nexport function restElement(\n  argument:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n): t.RestElement {\n  const node: t.RestElement = {\n    type: \"RestElement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.RestElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function returnStatement(\n  argument: t.Expression | null = null,\n): t.ReturnStatement {\n  const node: t.ReturnStatement = {\n    type: \"ReturnStatement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ReturnStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function sequenceExpression(\n  expressions: t.Expression[],\n): t.SequenceExpression {\n  const node: t.SequenceExpression = {\n    type: \"SequenceExpression\",\n    expressions,\n  };\n  const defs = NODE_FIELDS.SequenceExpression;\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nexport function parenthesizedExpression(\n  expression: t.Expression,\n): t.ParenthesizedExpression {\n  const node: t.ParenthesizedExpression = {\n    type: \"ParenthesizedExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.ParenthesizedExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function switchCase(\n  test: t.Expression | null | undefined = null,\n  consequent: t.Statement[],\n): t.SwitchCase {\n  const node: t.SwitchCase = {\n    type: \"SwitchCase\",\n    test,\n    consequent,\n  };\n  const defs = NODE_FIELDS.SwitchCase;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.consequent, node, \"consequent\", consequent, 1);\n  return node;\n}\nexport function switchStatement(\n  discriminant: t.Expression,\n  cases: t.SwitchCase[],\n): t.SwitchStatement {\n  const node: t.SwitchStatement = {\n    type: \"SwitchStatement\",\n    discriminant,\n    cases,\n  };\n  const defs = NODE_FIELDS.SwitchStatement;\n  validate(defs.discriminant, node, \"discriminant\", discriminant, 1);\n  validate(defs.cases, node, \"cases\", cases, 1);\n  return node;\n}\nexport function thisExpression(): t.ThisExpression {\n  return {\n    type: \"ThisExpression\",\n  };\n}\nexport function throwStatement(argument: t.Expression): t.ThrowStatement {\n  const node: t.ThrowStatement = {\n    type: \"ThrowStatement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ThrowStatement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function tryStatement(\n  block: t.BlockStatement,\n  handler: t.CatchClause | null = null,\n  finalizer: t.BlockStatement | null = null,\n): t.TryStatement {\n  const node: t.TryStatement = {\n    type: \"TryStatement\",\n    block,\n    handler,\n    finalizer,\n  };\n  const defs = NODE_FIELDS.TryStatement;\n  validate(defs.block, node, \"block\", block, 1);\n  validate(defs.handler, node, \"handler\", handler, 1);\n  validate(defs.finalizer, node, \"finalizer\", finalizer, 1);\n  return node;\n}\nexport function unaryExpression(\n  operator: \"void\" | \"throw\" | \"delete\" | \"!\" | \"+\" | \"-\" | \"~\" | \"typeof\",\n  argument: t.Expression,\n  prefix: boolean = true,\n): t.UnaryExpression {\n  const node: t.UnaryExpression = {\n    type: \"UnaryExpression\",\n    operator,\n    argument,\n    prefix,\n  };\n  const defs = NODE_FIELDS.UnaryExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nexport function updateExpression(\n  operator: \"++\" | \"--\",\n  argument: t.Identifier | t.MemberExpression,\n  prefix: boolean = false,\n): t.UpdateExpression {\n  const node: t.UpdateExpression = {\n    type: \"UpdateExpression\",\n    operator,\n    argument,\n    prefix,\n  };\n  const defs = NODE_FIELDS.UpdateExpression;\n  validate(defs.operator, node, \"operator\", operator);\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.prefix, node, \"prefix\", prefix);\n  return node;\n}\nexport function variableDeclaration(\n  kind: \"var\" | \"let\" | \"const\" | \"using\" | \"await using\",\n  declarations: t.VariableDeclarator[],\n): t.VariableDeclaration {\n  const node: t.VariableDeclaration = {\n    type: \"VariableDeclaration\",\n    kind,\n    declarations,\n  };\n  const defs = NODE_FIELDS.VariableDeclaration;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.declarations, node, \"declarations\", declarations, 1);\n  return node;\n}\nexport function variableDeclarator(\n  id: t.Identifier | t.ArrayPattern | t.ObjectPattern | t.VoidPattern,\n  init: t.Expression | null = null,\n): t.VariableDeclarator {\n  const node: t.VariableDeclarator = {\n    type: \"VariableDeclarator\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.VariableDeclarator;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function whileStatement(\n  test: t.Expression,\n  body: t.Statement,\n): t.WhileStatement {\n  const node: t.WhileStatement = {\n    type: \"WhileStatement\",\n    test,\n    body,\n  };\n  const defs = NODE_FIELDS.WhileStatement;\n  validate(defs.test, node, \"test\", test, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function withStatement(\n  object: t.Expression,\n  body: t.Statement,\n): t.WithStatement {\n  const node: t.WithStatement = {\n    type: \"WithStatement\",\n    object,\n    body,\n  };\n  const defs = NODE_FIELDS.WithStatement;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function assignmentPattern(\n  left:\n    | t.Identifier\n    | t.ObjectPattern\n    | t.ArrayPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n): t.AssignmentPattern {\n  const node: t.AssignmentPattern = {\n    type: \"AssignmentPattern\",\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.AssignmentPattern;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function arrayPattern(\n  elements: (null | t.PatternLike)[],\n): t.ArrayPattern {\n  const node: t.ArrayPattern = {\n    type: \"ArrayPattern\",\n    elements,\n  };\n  const defs = NODE_FIELDS.ArrayPattern;\n  validate(defs.elements, node, \"elements\", elements, 1);\n  return node;\n}\nexport function arrowFunctionExpression(\n  params: t.FunctionParameter[],\n  body: t.BlockStatement | t.Expression,\n  async: boolean = false,\n): t.ArrowFunctionExpression {\n  const node: t.ArrowFunctionExpression = {\n    type: \"ArrowFunctionExpression\",\n    params,\n    body,\n    async,\n    expression: null,\n  };\n  const defs = NODE_FIELDS.ArrowFunctionExpression;\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function classBody(\n  body: (\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty\n    | t.TSDeclareMethod\n    | t.TSIndexSignature\n    | t.StaticBlock\n  )[],\n): t.ClassBody {\n  const node: t.ClassBody = {\n    type: \"ClassBody\",\n    body,\n  };\n  const defs = NODE_FIELDS.ClassBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function classExpression(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: t.Decorator[] | null = null,\n): t.ClassExpression {\n  const node: t.ClassExpression = {\n    type: \"ClassExpression\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassExpression;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function classDeclaration(\n  id: t.Identifier | null | undefined = null,\n  superClass: t.Expression | null | undefined = null,\n  body: t.ClassBody,\n  decorators: t.Decorator[] | null = null,\n): t.ClassDeclaration {\n  const node: t.ClassDeclaration = {\n    type: \"ClassDeclaration\",\n    id,\n    superClass,\n    body,\n    decorators,\n  };\n  const defs = NODE_FIELDS.ClassDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.superClass, node, \"superClass\", superClass, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  return node;\n}\nexport function exportAllDeclaration(\n  source: t.StringLiteral,\n): t.ExportAllDeclaration {\n  const node: t.ExportAllDeclaration = {\n    type: \"ExportAllDeclaration\",\n    source,\n    assertions: null,\n  };\n  const defs = NODE_FIELDS.ExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function exportDefaultDeclaration(\n  declaration:\n    | t.TSDeclareFunction\n    | t.FunctionDeclaration\n    | t.ClassDeclaration\n    | t.Expression,\n): t.ExportDefaultDeclaration {\n  const node: t.ExportDefaultDeclaration = {\n    type: \"ExportDefaultDeclaration\",\n    declaration,\n  };\n  const defs = NODE_FIELDS.ExportDefaultDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  return node;\n}\nexport function exportNamedDeclaration(\n  declaration: t.Declaration | null = null,\n  specifiers: (\n    | t.ExportSpecifier\n    | t.ExportDefaultSpecifier\n    | t.ExportNamespaceSpecifier\n  )[] = [],\n  source: t.StringLiteral | null = null,\n): t.ExportNamedDeclaration {\n  const node: t.ExportNamedDeclaration = {\n    type: \"ExportNamedDeclaration\",\n    declaration,\n    specifiers,\n    source,\n  };\n  const defs = NODE_FIELDS.ExportNamedDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function exportSpecifier(\n  local: t.Identifier,\n  exported: t.Identifier | t.StringLiteral,\n): t.ExportSpecifier {\n  const node: t.ExportSpecifier = {\n    type: \"ExportSpecifier\",\n    local,\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function forOfStatement(\n  left:\n    | t.VariableDeclaration\n    | t.Identifier\n    | t.MemberExpression\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n  right: t.Expression,\n  body: t.Statement,\n  _await: boolean = false,\n): t.ForOfStatement {\n  const node: t.ForOfStatement = {\n    type: \"ForOfStatement\",\n    left,\n    right,\n    body,\n    await: _await,\n  };\n  const defs = NODE_FIELDS.ForOfStatement;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.await, node, \"await\", _await);\n  return node;\n}\nexport function importDeclaration(\n  specifiers: (\n    | t.ImportSpecifier\n    | t.ImportDefaultSpecifier\n    | t.ImportNamespaceSpecifier\n  )[],\n  source: t.StringLiteral,\n): t.ImportDeclaration {\n  const node: t.ImportDeclaration = {\n    type: \"ImportDeclaration\",\n    specifiers,\n    source,\n  };\n  const defs = NODE_FIELDS.ImportDeclaration;\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  return node;\n}\nexport function importDefaultSpecifier(\n  local: t.Identifier,\n): t.ImportDefaultSpecifier {\n  const node: t.ImportDefaultSpecifier = {\n    type: \"ImportDefaultSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportDefaultSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importNamespaceSpecifier(\n  local: t.Identifier,\n): t.ImportNamespaceSpecifier {\n  const node: t.ImportNamespaceSpecifier = {\n    type: \"ImportNamespaceSpecifier\",\n    local,\n  };\n  const defs = NODE_FIELDS.ImportNamespaceSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  return node;\n}\nexport function importSpecifier(\n  local: t.Identifier,\n  imported: t.Identifier | t.StringLiteral,\n): t.ImportSpecifier {\n  const node: t.ImportSpecifier = {\n    type: \"ImportSpecifier\",\n    local,\n    imported,\n  };\n  const defs = NODE_FIELDS.ImportSpecifier;\n  validate(defs.local, node, \"local\", local, 1);\n  validate(defs.imported, node, \"imported\", imported, 1);\n  return node;\n}\nexport function importExpression(\n  source: t.Expression,\n  options: t.Expression | null = null,\n): t.ImportExpression {\n  const node: t.ImportExpression = {\n    type: \"ImportExpression\",\n    source,\n    options,\n  };\n  const defs = NODE_FIELDS.ImportExpression;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.options, node, \"options\", options, 1);\n  return node;\n}\nexport function metaProperty(\n  meta: t.Identifier,\n  property: t.Identifier,\n): t.MetaProperty {\n  const node: t.MetaProperty = {\n    type: \"MetaProperty\",\n    meta,\n    property,\n  };\n  const defs = NODE_FIELDS.MetaProperty;\n  validate(defs.meta, node, \"meta\", meta, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined,\n  key: t.Expression,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  computed?: true,\n  _static?: boolean,\n  generator?: boolean,\n  async?: boolean,\n): Extract<t.ClassMethod, { computed: true }>;\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined,\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  computed?: false,\n  _static?: boolean,\n  generator?: boolean,\n  async?: boolean,\n): Extract<t.ClassMethod, { computed: false }>;\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  computed?: boolean,\n  _static?: boolean,\n  generator?: boolean,\n  async?: boolean,\n): t.ClassMethod;\nexport function classMethod(\n  kind: \"get\" | \"set\" | \"method\" | \"constructor\" | undefined = \"method\",\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  computed: boolean = false,\n  _static: boolean = false,\n  generator: boolean = false,\n  async: boolean = false,\n): t.ClassMethod {\n  const node = {\n    type: \"ClassMethod\",\n    kind,\n    key,\n    params,\n    body,\n    computed,\n    static: _static,\n    generator,\n    async,\n  } as t.ClassMethod;\n  const defs = NODE_FIELDS.ClassMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.generator, node, \"generator\", generator);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function objectPattern(\n  properties: (t.RestElement | t.ObjectProperty)[],\n): t.ObjectPattern {\n  const node: t.ObjectPattern = {\n    type: \"ObjectPattern\",\n    properties,\n  };\n  const defs = NODE_FIELDS.ObjectPattern;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  return node;\n}\nexport function spreadElement(argument: t.Expression): t.SpreadElement {\n  const node: t.SpreadElement = {\n    type: \"SpreadElement\",\n    argument,\n  };\n  const defs = NODE_FIELDS.SpreadElement;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _super(): t.Super {\n  return {\n    type: \"Super\",\n  };\n}\nexport { _super as super };\nexport function taggedTemplateExpression(\n  tag: t.Expression,\n  quasi: t.TemplateLiteral,\n): t.TaggedTemplateExpression {\n  const node: t.TaggedTemplateExpression = {\n    type: \"TaggedTemplateExpression\",\n    tag,\n    quasi,\n  };\n  const defs = NODE_FIELDS.TaggedTemplateExpression;\n  validate(defs.tag, node, \"tag\", tag, 1);\n  validate(defs.quasi, node, \"quasi\", quasi, 1);\n  return node;\n}\nexport function templateElement(\n  value: { raw: string; cooked?: string },\n  tail: boolean = false,\n): t.TemplateElement {\n  const node: t.TemplateElement = {\n    type: \"TemplateElement\",\n    value,\n    tail,\n  };\n  const defs = NODE_FIELDS.TemplateElement;\n  validate(defs.value, node, \"value\", value);\n  validate(defs.tail, node, \"tail\", tail);\n  return node;\n}\nexport function templateLiteral(\n  quasis: t.TemplateElement[],\n  expressions: (t.Expression | t.TSType)[],\n): t.TemplateLiteral {\n  const node: t.TemplateLiteral = {\n    type: \"TemplateLiteral\",\n    quasis,\n    expressions,\n  };\n  const defs = NODE_FIELDS.TemplateLiteral;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.expressions, node, \"expressions\", expressions, 1);\n  return node;\n}\nexport function yieldExpression(\n  argument: t.Expression | null = null,\n  delegate: boolean = false,\n): t.YieldExpression {\n  const node: t.YieldExpression = {\n    type: \"YieldExpression\",\n    argument,\n    delegate,\n  };\n  const defs = NODE_FIELDS.YieldExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  validate(defs.delegate, node, \"delegate\", delegate);\n  return node;\n}\nexport function awaitExpression(argument: t.Expression): t.AwaitExpression {\n  const node: t.AwaitExpression = {\n    type: \"AwaitExpression\",\n    argument,\n  };\n  const defs = NODE_FIELDS.AwaitExpression;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nfunction _import(): t.Import {\n  return {\n    type: \"Import\",\n  };\n}\nexport { _import as import };\nexport function bigIntLiteral(value: bigint): t.BigIntLiteral {\n  const node: t.BigIntLiteral = {\n    type: \"BigIntLiteral\",\n    value,\n  };\n  const defs = NODE_FIELDS.BigIntLiteral;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function exportNamespaceSpecifier(\n  exported: t.Identifier,\n): t.ExportNamespaceSpecifier {\n  const node: t.ExportNamespaceSpecifier = {\n    type: \"ExportNamespaceSpecifier\",\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportNamespaceSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function optionalMemberExpression(\n  object: t.Expression,\n  property: t.Expression | t.Identifier,\n  computed: boolean | undefined = false,\n  optional: boolean,\n): t.OptionalMemberExpression {\n  const node: t.OptionalMemberExpression = {\n    type: \"OptionalMemberExpression\",\n    object,\n    property,\n    computed,\n    optional,\n  };\n  const defs = NODE_FIELDS.OptionalMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function optionalCallExpression(\n  callee: t.Expression,\n  _arguments: (t.Expression | t.SpreadElement | t.ArgumentPlaceholder)[],\n  optional: boolean,\n): t.OptionalCallExpression {\n  const node: t.OptionalCallExpression = {\n    type: \"OptionalCallExpression\",\n    callee,\n    arguments: _arguments,\n    optional,\n  };\n  const defs = NODE_FIELDS.OptionalCallExpression;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  validate(defs.arguments, node, \"arguments\", _arguments, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function classProperty(\n  key: t.Expression,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: true,\n  _static?: boolean,\n): Extract<t.ClassProperty, { computed: true }>;\nexport function classProperty(\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: false,\n  _static?: boolean,\n): Extract<t.ClassProperty, { computed: false }>;\nexport function classProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: boolean,\n  _static?: boolean,\n): t.ClassProperty;\nexport function classProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | null = null,\n  decorators: t.Decorator[] | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassProperty {\n  const node = {\n    type: \"ClassProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  } as t.ClassProperty;\n  const defs = NODE_FIELDS.ClassProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classAccessorProperty(\n  key: t.Expression,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: true,\n  _static?: boolean,\n): Extract<t.ClassAccessorProperty, { computed: true }>;\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.PrivateName,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: false,\n  _static?: boolean,\n): Extract<t.ClassAccessorProperty, { computed: false }>;\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression\n    | t.PrivateName,\n  value?: t.Expression | null,\n  typeAnnotation?: t.TypeAnnotation | t.TSTypeAnnotation | null,\n  decorators?: t.Decorator[] | null,\n  computed?: boolean,\n  _static?: boolean,\n): t.ClassAccessorProperty;\nexport function classAccessorProperty(\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression\n    | t.PrivateName,\n  value: t.Expression | null = null,\n  typeAnnotation: t.TypeAnnotation | t.TSTypeAnnotation | null = null,\n  decorators: t.Decorator[] | null = null,\n  computed: boolean = false,\n  _static: boolean = false,\n): t.ClassAccessorProperty {\n  const node = {\n    type: \"ClassAccessorProperty\",\n    key,\n    value,\n    typeAnnotation,\n    decorators,\n    computed,\n    static: _static,\n  } as t.ClassAccessorProperty;\n  const defs = NODE_FIELDS.ClassAccessorProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.computed, node, \"computed\", computed);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classPrivateProperty(\n  key: t.PrivateName,\n  value: t.Expression | null = null,\n  decorators: t.Decorator[] | null = null,\n  _static: boolean = false,\n): t.ClassPrivateProperty {\n  const node: t.ClassPrivateProperty = {\n    type: \"ClassPrivateProperty\",\n    key,\n    value,\n    decorators,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassPrivateProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function classPrivateMethod(\n  kind: \"get\" | \"set\" | \"method\" | undefined = \"method\",\n  key: t.PrivateName,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  body: t.BlockStatement,\n  _static: boolean = false,\n): t.ClassPrivateMethod {\n  const node: t.ClassPrivateMethod = {\n    type: \"ClassPrivateMethod\",\n    kind,\n    key,\n    params,\n    body,\n    static: _static,\n  };\n  const defs = NODE_FIELDS.ClassPrivateMethod;\n  validate(defs.kind, node, \"kind\", kind);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.static, node, \"static\", _static);\n  return node;\n}\nexport function privateName(id: t.Identifier): t.PrivateName {\n  const node: t.PrivateName = {\n    type: \"PrivateName\",\n    id,\n  };\n  const defs = NODE_FIELDS.PrivateName;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function staticBlock(body: t.Statement[]): t.StaticBlock {\n  const node: t.StaticBlock = {\n    type: \"StaticBlock\",\n    body,\n  };\n  const defs = NODE_FIELDS.StaticBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function importAttribute(\n  key: t.Identifier | t.StringLiteral,\n  value: t.StringLiteral,\n): t.ImportAttribute {\n  const node: t.ImportAttribute = {\n    type: \"ImportAttribute\",\n    key,\n    value,\n  };\n  const defs = NODE_FIELDS.ImportAttribute;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function anyTypeAnnotation(): t.AnyTypeAnnotation {\n  return {\n    type: \"AnyTypeAnnotation\",\n  };\n}\nexport function arrayTypeAnnotation(\n  elementType: t.FlowType,\n): t.ArrayTypeAnnotation {\n  const node: t.ArrayTypeAnnotation = {\n    type: \"ArrayTypeAnnotation\",\n    elementType,\n  };\n  const defs = NODE_FIELDS.ArrayTypeAnnotation;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nexport function booleanTypeAnnotation(): t.BooleanTypeAnnotation {\n  return {\n    type: \"BooleanTypeAnnotation\",\n  };\n}\nexport function booleanLiteralTypeAnnotation(\n  value: boolean,\n): t.BooleanLiteralTypeAnnotation {\n  const node: t.BooleanLiteralTypeAnnotation = {\n    type: \"BooleanLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function nullLiteralTypeAnnotation(): t.NullLiteralTypeAnnotation {\n  return {\n    type: \"NullLiteralTypeAnnotation\",\n  };\n}\nexport function classImplements(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.ClassImplements {\n  const node: t.ClassImplements = {\n    type: \"ClassImplements\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.ClassImplements;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function declareClass(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: t.InterfaceExtends[] | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareClass {\n  const node: t.DeclareClass = {\n    type: \"DeclareClass\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.DeclareClass;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function declareFunction(id: t.Identifier): t.DeclareFunction {\n  const node: t.DeclareFunction = {\n    type: \"DeclareFunction\",\n    id,\n  };\n  const defs = NODE_FIELDS.DeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function declareInterface(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: t.InterfaceExtends[] | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.DeclareInterface {\n  const node: t.DeclareInterface = {\n    type: \"DeclareInterface\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.DeclareInterface;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function declareModule(\n  id: t.Identifier | t.StringLiteral,\n  body: t.BlockStatement,\n  kind: \"CommonJS\" | \"ES\" | null = null,\n): t.DeclareModule {\n  const node: t.DeclareModule = {\n    type: \"DeclareModule\",\n    id,\n    body,\n    kind,\n  };\n  const defs = NODE_FIELDS.DeclareModule;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nexport function declareModuleExports(\n  typeAnnotation: t.TypeAnnotation,\n): t.DeclareModuleExports {\n  const node: t.DeclareModuleExports = {\n    type: \"DeclareModuleExports\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.DeclareModuleExports;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function declareTypeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.DeclareTypeAlias {\n  const node: t.DeclareTypeAlias = {\n    type: \"DeclareTypeAlias\",\n    id,\n    typeParameters,\n    right,\n  };\n  const defs = NODE_FIELDS.DeclareTypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function declareOpaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null = null,\n  supertype: t.FlowType | null = null,\n): t.DeclareOpaqueType {\n  const node: t.DeclareOpaqueType = {\n    type: \"DeclareOpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n  };\n  const defs = NODE_FIELDS.DeclareOpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  return node;\n}\nexport function declareVariable(id: t.Identifier): t.DeclareVariable {\n  const node: t.DeclareVariable = {\n    type: \"DeclareVariable\",\n    id,\n  };\n  const defs = NODE_FIELDS.DeclareVariable;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function declareExportDeclaration(\n  declaration: t.Flow | null = null,\n  specifiers: (t.ExportSpecifier | t.ExportNamespaceSpecifier)[] | null = null,\n  source: t.StringLiteral | null = null,\n  attributes: t.ImportAttribute[] | null = null,\n): t.DeclareExportDeclaration {\n  const node: t.DeclareExportDeclaration = {\n    type: \"DeclareExportDeclaration\",\n    declaration,\n    specifiers,\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.DeclareExportDeclaration;\n  validate(defs.declaration, node, \"declaration\", declaration, 1);\n  validate(defs.specifiers, node, \"specifiers\", specifiers, 1);\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function declareExportAllDeclaration(\n  source: t.StringLiteral,\n  attributes: t.ImportAttribute[] | null = null,\n): t.DeclareExportAllDeclaration {\n  const node: t.DeclareExportAllDeclaration = {\n    type: \"DeclareExportAllDeclaration\",\n    source,\n    attributes,\n  };\n  const defs = NODE_FIELDS.DeclareExportAllDeclaration;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  return node;\n}\nexport function declaredPredicate(value: t.Flow): t.DeclaredPredicate {\n  const node: t.DeclaredPredicate = {\n    type: \"DeclaredPredicate\",\n    value,\n  };\n  const defs = NODE_FIELDS.DeclaredPredicate;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function existsTypeAnnotation(): t.ExistsTypeAnnotation {\n  return {\n    type: \"ExistsTypeAnnotation\",\n  };\n}\nexport function functionTypeAnnotation(\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  params: t.FunctionTypeParam[],\n  rest: t.FunctionTypeParam | null | undefined = null,\n  returnType: t.FlowType,\n): t.FunctionTypeAnnotation {\n  const node: t.FunctionTypeAnnotation = {\n    type: \"FunctionTypeAnnotation\",\n    typeParameters,\n    params,\n    rest,\n    returnType,\n  };\n  const defs = NODE_FIELDS.FunctionTypeAnnotation;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.rest, node, \"rest\", rest, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function functionTypeParam(\n  name: t.Identifier | null | undefined = null,\n  typeAnnotation: t.FlowType,\n): t.FunctionTypeParam {\n  const node: t.FunctionTypeParam = {\n    type: \"FunctionTypeParam\",\n    name,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.FunctionTypeParam;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function genericTypeAnnotation(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.GenericTypeAnnotation {\n  const node: t.GenericTypeAnnotation = {\n    type: \"GenericTypeAnnotation\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.GenericTypeAnnotation;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function inferredPredicate(): t.InferredPredicate {\n  return {\n    type: \"InferredPredicate\",\n  };\n}\nexport function interfaceExtends(\n  id: t.Identifier | t.QualifiedTypeIdentifier,\n  typeParameters: t.TypeParameterInstantiation | null = null,\n): t.InterfaceExtends {\n  const node: t.InterfaceExtends = {\n    type: \"InterfaceExtends\",\n    id,\n    typeParameters,\n  };\n  const defs = NODE_FIELDS.InterfaceExtends;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  return node;\n}\nexport function interfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  _extends: t.InterfaceExtends[] | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceDeclaration {\n  const node: t.InterfaceDeclaration = {\n    type: \"InterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.InterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function interfaceTypeAnnotation(\n  _extends: t.InterfaceExtends[] | null | undefined = null,\n  body: t.ObjectTypeAnnotation,\n): t.InterfaceTypeAnnotation {\n  const node: t.InterfaceTypeAnnotation = {\n    type: \"InterfaceTypeAnnotation\",\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.InterfaceTypeAnnotation;\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function intersectionTypeAnnotation(\n  types: t.FlowType[],\n): t.IntersectionTypeAnnotation {\n  const node: t.IntersectionTypeAnnotation = {\n    type: \"IntersectionTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.IntersectionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function mixedTypeAnnotation(): t.MixedTypeAnnotation {\n  return {\n    type: \"MixedTypeAnnotation\",\n  };\n}\nexport function emptyTypeAnnotation(): t.EmptyTypeAnnotation {\n  return {\n    type: \"EmptyTypeAnnotation\",\n  };\n}\nexport function nullableTypeAnnotation(\n  typeAnnotation: t.FlowType,\n): t.NullableTypeAnnotation {\n  const node: t.NullableTypeAnnotation = {\n    type: \"NullableTypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.NullableTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function numberLiteralTypeAnnotation(\n  value: number,\n): t.NumberLiteralTypeAnnotation {\n  const node: t.NumberLiteralTypeAnnotation = {\n    type: \"NumberLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function numberTypeAnnotation(): t.NumberTypeAnnotation {\n  return {\n    type: \"NumberTypeAnnotation\",\n  };\n}\nexport function objectTypeAnnotation(\n  properties: (t.ObjectTypeProperty | t.ObjectTypeSpreadProperty)[],\n  indexers: t.ObjectTypeIndexer[] = [],\n  callProperties: t.ObjectTypeCallProperty[] = [],\n  internalSlots: t.ObjectTypeInternalSlot[] = [],\n  exact: boolean = false,\n): t.ObjectTypeAnnotation {\n  const node: t.ObjectTypeAnnotation = {\n    type: \"ObjectTypeAnnotation\",\n    properties,\n    indexers,\n    callProperties,\n    internalSlots,\n    exact,\n  };\n  const defs = NODE_FIELDS.ObjectTypeAnnotation;\n  validate(defs.properties, node, \"properties\", properties, 1);\n  validate(defs.indexers, node, \"indexers\", indexers, 1);\n  validate(defs.callProperties, node, \"callProperties\", callProperties, 1);\n  validate(defs.internalSlots, node, \"internalSlots\", internalSlots, 1);\n  validate(defs.exact, node, \"exact\", exact);\n  return node;\n}\nexport function objectTypeInternalSlot(\n  id: t.Identifier,\n  value: t.FlowType,\n  optional: boolean,\n  _static: boolean,\n  method: boolean,\n): t.ObjectTypeInternalSlot {\n  const node: t.ObjectTypeInternalSlot = {\n    type: \"ObjectTypeInternalSlot\",\n    id,\n    value,\n    optional,\n    static: _static,\n    method,\n  };\n  const defs = NODE_FIELDS.ObjectTypeInternalSlot;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  validate(defs.static, node, \"static\", _static);\n  validate(defs.method, node, \"method\", method);\n  return node;\n}\nexport function objectTypeCallProperty(\n  value: t.FlowType,\n): t.ObjectTypeCallProperty {\n  const node: t.ObjectTypeCallProperty = {\n    type: \"ObjectTypeCallProperty\",\n    value,\n    static: null,\n  };\n  const defs = NODE_FIELDS.ObjectTypeCallProperty;\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function objectTypeIndexer(\n  id: t.Identifier | null | undefined = null,\n  key: t.FlowType,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeIndexer {\n  const node: t.ObjectTypeIndexer = {\n    type: \"ObjectTypeIndexer\",\n    id,\n    key,\n    value,\n    variance,\n    static: null,\n  };\n  const defs = NODE_FIELDS.ObjectTypeIndexer;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function objectTypeProperty(\n  key: t.Identifier | t.StringLiteral,\n  value: t.FlowType,\n  variance: t.Variance | null = null,\n): t.ObjectTypeProperty {\n  const node: t.ObjectTypeProperty = {\n    type: \"ObjectTypeProperty\",\n    key,\n    value,\n    variance,\n    kind: null,\n    method: null,\n    optional: null,\n    proto: null,\n    static: null,\n  };\n  const defs = NODE_FIELDS.ObjectTypeProperty;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function objectTypeSpreadProperty(\n  argument: t.FlowType,\n): t.ObjectTypeSpreadProperty {\n  const node: t.ObjectTypeSpreadProperty = {\n    type: \"ObjectTypeSpreadProperty\",\n    argument,\n  };\n  const defs = NODE_FIELDS.ObjectTypeSpreadProperty;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function opaqueType(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  supertype: t.FlowType | null | undefined = null,\n  impltype: t.FlowType,\n): t.OpaqueType {\n  const node: t.OpaqueType = {\n    type: \"OpaqueType\",\n    id,\n    typeParameters,\n    supertype,\n    impltype,\n  };\n  const defs = NODE_FIELDS.OpaqueType;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.supertype, node, \"supertype\", supertype, 1);\n  validate(defs.impltype, node, \"impltype\", impltype, 1);\n  return node;\n}\nexport function qualifiedTypeIdentifier(\n  id: t.Identifier,\n  qualification: t.Identifier | t.QualifiedTypeIdentifier,\n): t.QualifiedTypeIdentifier {\n  const node: t.QualifiedTypeIdentifier = {\n    type: \"QualifiedTypeIdentifier\",\n    id,\n    qualification,\n  };\n  const defs = NODE_FIELDS.QualifiedTypeIdentifier;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.qualification, node, \"qualification\", qualification, 1);\n  return node;\n}\nexport function stringLiteralTypeAnnotation(\n  value: string,\n): t.StringLiteralTypeAnnotation {\n  const node: t.StringLiteralTypeAnnotation = {\n    type: \"StringLiteralTypeAnnotation\",\n    value,\n  };\n  const defs = NODE_FIELDS.StringLiteralTypeAnnotation;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function stringTypeAnnotation(): t.StringTypeAnnotation {\n  return {\n    type: \"StringTypeAnnotation\",\n  };\n}\nexport function symbolTypeAnnotation(): t.SymbolTypeAnnotation {\n  return {\n    type: \"SymbolTypeAnnotation\",\n  };\n}\nexport function thisTypeAnnotation(): t.ThisTypeAnnotation {\n  return {\n    type: \"ThisTypeAnnotation\",\n  };\n}\nexport function tupleTypeAnnotation(\n  types: t.FlowType[],\n): t.TupleTypeAnnotation {\n  const node: t.TupleTypeAnnotation = {\n    type: \"TupleTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.TupleTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function typeofTypeAnnotation(\n  argument: t.FlowType,\n): t.TypeofTypeAnnotation {\n  const node: t.TypeofTypeAnnotation = {\n    type: \"TypeofTypeAnnotation\",\n    argument,\n  };\n  const defs = NODE_FIELDS.TypeofTypeAnnotation;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function typeAlias(\n  id: t.Identifier,\n  typeParameters: t.TypeParameterDeclaration | null | undefined = null,\n  right: t.FlowType,\n): t.TypeAlias {\n  const node: t.TypeAlias = {\n    type: \"TypeAlias\",\n    id,\n    typeParameters,\n    right,\n  };\n  const defs = NODE_FIELDS.TypeAlias;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function typeAnnotation(typeAnnotation: t.FlowType): t.TypeAnnotation {\n  const node: t.TypeAnnotation = {\n    type: \"TypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function typeCastExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TypeAnnotation,\n): t.TypeCastExpression {\n  const node: t.TypeCastExpression = {\n    type: \"TypeCastExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TypeCastExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function typeParameter(\n  bound: t.TypeAnnotation | null = null,\n  _default: t.FlowType | null = null,\n  variance: t.Variance | null = null,\n): t.TypeParameter {\n  const node: t.TypeParameter = {\n    type: \"TypeParameter\",\n    bound,\n    default: _default,\n    variance,\n    name: null,\n  };\n  const defs = NODE_FIELDS.TypeParameter;\n  validate(defs.bound, node, \"bound\", bound, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.variance, node, \"variance\", variance, 1);\n  return node;\n}\nexport function typeParameterDeclaration(\n  params: t.TypeParameter[],\n): t.TypeParameterDeclaration {\n  const node: t.TypeParameterDeclaration = {\n    type: \"TypeParameterDeclaration\",\n    params,\n  };\n  const defs = NODE_FIELDS.TypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function typeParameterInstantiation(\n  params: t.FlowType[],\n): t.TypeParameterInstantiation {\n  const node: t.TypeParameterInstantiation = {\n    type: \"TypeParameterInstantiation\",\n    params,\n  };\n  const defs = NODE_FIELDS.TypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function unionTypeAnnotation(\n  types: t.FlowType[],\n): t.UnionTypeAnnotation {\n  const node: t.UnionTypeAnnotation = {\n    type: \"UnionTypeAnnotation\",\n    types,\n  };\n  const defs = NODE_FIELDS.UnionTypeAnnotation;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function variance(kind: \"minus\" | \"plus\"): t.Variance {\n  const node: t.Variance = {\n    type: \"Variance\",\n    kind,\n  };\n  const defs = NODE_FIELDS.Variance;\n  validate(defs.kind, node, \"kind\", kind);\n  return node;\n}\nexport function voidTypeAnnotation(): t.VoidTypeAnnotation {\n  return {\n    type: \"VoidTypeAnnotation\",\n  };\n}\nexport function enumDeclaration(\n  id: t.Identifier,\n  body:\n    | t.EnumBooleanBody\n    | t.EnumNumberBody\n    | t.EnumStringBody\n    | t.EnumSymbolBody,\n): t.EnumDeclaration {\n  const node: t.EnumDeclaration = {\n    type: \"EnumDeclaration\",\n    id,\n    body,\n  };\n  const defs = NODE_FIELDS.EnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function enumBooleanBody(\n  members: t.EnumBooleanMember[],\n): t.EnumBooleanBody {\n  const node: t.EnumBooleanBody = {\n    type: \"EnumBooleanBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  };\n  const defs = NODE_FIELDS.EnumBooleanBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumNumberBody(\n  members: t.EnumNumberMember[],\n): t.EnumNumberBody {\n  const node: t.EnumNumberBody = {\n    type: \"EnumNumberBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  };\n  const defs = NODE_FIELDS.EnumNumberBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumStringBody(\n  members: (t.EnumStringMember | t.EnumDefaultedMember)[],\n): t.EnumStringBody {\n  const node: t.EnumStringBody = {\n    type: \"EnumStringBody\",\n    members,\n    explicitType: null,\n    hasUnknownMembers: null,\n  };\n  const defs = NODE_FIELDS.EnumStringBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumSymbolBody(\n  members: t.EnumDefaultedMember[],\n): t.EnumSymbolBody {\n  const node: t.EnumSymbolBody = {\n    type: \"EnumSymbolBody\",\n    members,\n    hasUnknownMembers: null,\n  };\n  const defs = NODE_FIELDS.EnumSymbolBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function enumBooleanMember(id: t.Identifier): t.EnumBooleanMember {\n  const node: t.EnumBooleanMember = {\n    type: \"EnumBooleanMember\",\n    id,\n    init: null,\n  };\n  const defs = NODE_FIELDS.EnumBooleanMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function enumNumberMember(\n  id: t.Identifier,\n  init: t.NumericLiteral,\n): t.EnumNumberMember {\n  const node: t.EnumNumberMember = {\n    type: \"EnumNumberMember\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.EnumNumberMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function enumStringMember(\n  id: t.Identifier,\n  init: t.StringLiteral,\n): t.EnumStringMember {\n  const node: t.EnumStringMember = {\n    type: \"EnumStringMember\",\n    id,\n    init,\n  };\n  const defs = NODE_FIELDS.EnumStringMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.init, node, \"init\", init, 1);\n  return node;\n}\nexport function enumDefaultedMember(id: t.Identifier): t.EnumDefaultedMember {\n  const node: t.EnumDefaultedMember = {\n    type: \"EnumDefaultedMember\",\n    id,\n  };\n  const defs = NODE_FIELDS.EnumDefaultedMember;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function indexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.IndexedAccessType {\n  const node: t.IndexedAccessType = {\n    type: \"IndexedAccessType\",\n    objectType,\n    indexType,\n  };\n  const defs = NODE_FIELDS.IndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport function optionalIndexedAccessType(\n  objectType: t.FlowType,\n  indexType: t.FlowType,\n): t.OptionalIndexedAccessType {\n  const node: t.OptionalIndexedAccessType = {\n    type: \"OptionalIndexedAccessType\",\n    objectType,\n    indexType,\n    optional: null,\n  };\n  const defs = NODE_FIELDS.OptionalIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport function jsxAttribute(\n  name: t.JSXIdentifier | t.JSXNamespacedName,\n  value:\n    | t.JSXElement\n    | t.JSXFragment\n    | t.StringLiteral\n    | t.JSXExpressionContainer\n    | null = null,\n): t.JSXAttribute {\n  const node: t.JSXAttribute = {\n    type: \"JSXAttribute\",\n    name,\n    value,\n  };\n  const defs = NODE_FIELDS.JSXAttribute;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.value, node, \"value\", value, 1);\n  return node;\n}\nexport function jsxClosingElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n): t.JSXClosingElement {\n  const node: t.JSXClosingElement = {\n    type: \"JSXClosingElement\",\n    name,\n  };\n  const defs = NODE_FIELDS.JSXClosingElement;\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport function jsxElement(\n  openingElement: t.JSXOpeningElement,\n  closingElement: t.JSXClosingElement | null | undefined = null,\n  children: (\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  )[],\n): t.JSXElement {\n  const node: t.JSXElement = {\n    type: \"JSXElement\",\n    openingElement,\n    closingElement,\n    children,\n  };\n  const defs = NODE_FIELDS.JSXElement;\n  validate(defs.openingElement, node, \"openingElement\", openingElement, 1);\n  validate(defs.closingElement, node, \"closingElement\", closingElement, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  return node;\n}\nexport function jsxEmptyExpression(): t.JSXEmptyExpression {\n  return {\n    type: \"JSXEmptyExpression\",\n  };\n}\nexport function jsxExpressionContainer(\n  expression: t.Expression | t.JSXEmptyExpression,\n): t.JSXExpressionContainer {\n  const node: t.JSXExpressionContainer = {\n    type: \"JSXExpressionContainer\",\n    expression,\n  };\n  const defs = NODE_FIELDS.JSXExpressionContainer;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function jsxSpreadChild(expression: t.Expression): t.JSXSpreadChild {\n  const node: t.JSXSpreadChild = {\n    type: \"JSXSpreadChild\",\n    expression,\n  };\n  const defs = NODE_FIELDS.JSXSpreadChild;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function jsxIdentifier(name: string): t.JSXIdentifier {\n  const node: t.JSXIdentifier = {\n    type: \"JSXIdentifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.JSXIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function jsxMemberExpression(\n  object: t.JSXMemberExpression | t.JSXIdentifier,\n  property: t.JSXIdentifier,\n): t.JSXMemberExpression {\n  const node: t.JSXMemberExpression = {\n    type: \"JSXMemberExpression\",\n    object,\n    property,\n  };\n  const defs = NODE_FIELDS.JSXMemberExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.property, node, \"property\", property, 1);\n  return node;\n}\nexport function jsxNamespacedName(\n  namespace: t.JSXIdentifier,\n  name: t.JSXIdentifier,\n): t.JSXNamespacedName {\n  const node: t.JSXNamespacedName = {\n    type: \"JSXNamespacedName\",\n    namespace,\n    name,\n  };\n  const defs = NODE_FIELDS.JSXNamespacedName;\n  validate(defs.namespace, node, \"namespace\", namespace, 1);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport function jsxOpeningElement(\n  name: t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName,\n  attributes: (t.JSXAttribute | t.JSXSpreadAttribute)[],\n  selfClosing: boolean = false,\n): t.JSXOpeningElement {\n  const node: t.JSXOpeningElement = {\n    type: \"JSXOpeningElement\",\n    name,\n    attributes,\n    selfClosing,\n  };\n  const defs = NODE_FIELDS.JSXOpeningElement;\n  validate(defs.name, node, \"name\", name, 1);\n  validate(defs.attributes, node, \"attributes\", attributes, 1);\n  validate(defs.selfClosing, node, \"selfClosing\", selfClosing);\n  return node;\n}\nexport function jsxSpreadAttribute(\n  argument: t.Expression,\n): t.JSXSpreadAttribute {\n  const node: t.JSXSpreadAttribute = {\n    type: \"JSXSpreadAttribute\",\n    argument,\n  };\n  const defs = NODE_FIELDS.JSXSpreadAttribute;\n  validate(defs.argument, node, \"argument\", argument, 1);\n  return node;\n}\nexport function jsxText(value: string): t.JSXText {\n  const node: t.JSXText = {\n    type: \"JSXText\",\n    value,\n  };\n  const defs = NODE_FIELDS.JSXText;\n  validate(defs.value, node, \"value\", value);\n  return node;\n}\nexport function jsxFragment(\n  openingFragment: t.JSXOpeningFragment,\n  closingFragment: t.JSXClosingFragment,\n  children: (\n    | t.JSXText\n    | t.JSXExpressionContainer\n    | t.JSXSpreadChild\n    | t.JSXElement\n    | t.JSXFragment\n  )[],\n): t.JSXFragment {\n  const node: t.JSXFragment = {\n    type: \"JSXFragment\",\n    openingFragment,\n    closingFragment,\n    children,\n  };\n  const defs = NODE_FIELDS.JSXFragment;\n  validate(defs.openingFragment, node, \"openingFragment\", openingFragment, 1);\n  validate(defs.closingFragment, node, \"closingFragment\", closingFragment, 1);\n  validate(defs.children, node, \"children\", children, 1);\n  return node;\n}\nexport function jsxOpeningFragment(): t.JSXOpeningFragment {\n  return {\n    type: \"JSXOpeningFragment\",\n  };\n}\nexport function jsxClosingFragment(): t.JSXClosingFragment {\n  return {\n    type: \"JSXClosingFragment\",\n  };\n}\nexport function placeholder(\n  expectedNode:\n    | \"Identifier\"\n    | \"StringLiteral\"\n    | \"Expression\"\n    | \"Statement\"\n    | \"Declaration\"\n    | \"BlockStatement\"\n    | \"ClassBody\"\n    | \"Pattern\",\n  name: t.Identifier,\n): t.Placeholder {\n  const node: t.Placeholder = {\n    type: \"Placeholder\",\n    expectedNode,\n    name,\n  };\n  const defs = NODE_FIELDS.Placeholder;\n  validate(defs.expectedNode, node, \"expectedNode\", expectedNode);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\nexport function v8IntrinsicIdentifier(name: string): t.V8IntrinsicIdentifier {\n  const node: t.V8IntrinsicIdentifier = {\n    type: \"V8IntrinsicIdentifier\",\n    name,\n  };\n  const defs = NODE_FIELDS.V8IntrinsicIdentifier;\n  validate(defs.name, node, \"name\", name);\n  return node;\n}\nexport function argumentPlaceholder(): t.ArgumentPlaceholder {\n  return {\n    type: \"ArgumentPlaceholder\",\n  };\n}\nexport function bindExpression(\n  object: t.Expression,\n  callee: t.Expression,\n): t.BindExpression {\n  const node: t.BindExpression = {\n    type: \"BindExpression\",\n    object,\n    callee,\n  };\n  const defs = NODE_FIELDS.BindExpression;\n  validate(defs.object, node, \"object\", object, 1);\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nexport function decorator(expression: t.Expression): t.Decorator {\n  const node: t.Decorator = {\n    type: \"Decorator\",\n    expression,\n  };\n  const defs = NODE_FIELDS.Decorator;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function doExpression(\n  body: t.BlockStatement,\n  async: boolean = false,\n): t.DoExpression {\n  const node: t.DoExpression = {\n    type: \"DoExpression\",\n    body,\n    async,\n  };\n  const defs = NODE_FIELDS.DoExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  validate(defs.async, node, \"async\", async);\n  return node;\n}\nexport function exportDefaultSpecifier(\n  exported: t.Identifier,\n): t.ExportDefaultSpecifier {\n  const node: t.ExportDefaultSpecifier = {\n    type: \"ExportDefaultSpecifier\",\n    exported,\n  };\n  const defs = NODE_FIELDS.ExportDefaultSpecifier;\n  validate(defs.exported, node, \"exported\", exported, 1);\n  return node;\n}\nexport function moduleExpression(body: t.Program): t.ModuleExpression {\n  const node: t.ModuleExpression = {\n    type: \"ModuleExpression\",\n    body,\n  };\n  const defs = NODE_FIELDS.ModuleExpression;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function topicReference(): t.TopicReference {\n  return {\n    type: \"TopicReference\",\n  };\n}\nexport function pipelineTopicExpression(\n  expression: t.Expression,\n): t.PipelineTopicExpression {\n  const node: t.PipelineTopicExpression = {\n    type: \"PipelineTopicExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.PipelineTopicExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function pipelineBareFunction(\n  callee: t.Expression,\n): t.PipelineBareFunction {\n  const node: t.PipelineBareFunction = {\n    type: \"PipelineBareFunction\",\n    callee,\n  };\n  const defs = NODE_FIELDS.PipelineBareFunction;\n  validate(defs.callee, node, \"callee\", callee, 1);\n  return node;\n}\nexport function pipelinePrimaryTopicReference(): t.PipelinePrimaryTopicReference {\n  return {\n    type: \"PipelinePrimaryTopicReference\",\n  };\n}\nexport function voidPattern(): t.VoidPattern {\n  return {\n    type: \"VoidPattern\",\n  };\n}\nexport function tsParameterProperty(\n  parameter: t.Identifier | t.AssignmentPattern,\n): t.TSParameterProperty {\n  const node: t.TSParameterProperty = {\n    type: \"TSParameterProperty\",\n    parameter,\n  };\n  const defs = NODE_FIELDS.TSParameterProperty;\n  validate(defs.parameter, node, \"parameter\", parameter, 1);\n  return node;\n}\nexport function tsDeclareFunction(\n  id: t.Identifier | null | undefined = null,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: t.FunctionParameter[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSDeclareFunction {\n  const node: t.TSDeclareFunction = {\n    type: \"TSDeclareFunction\",\n    id,\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSDeclareFunction;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined,\n  key: t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  returnType?: t.TSTypeAnnotation | null,\n): Extract<t.TSDeclareMethod, { computed: true }>;\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined,\n  key: t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  returnType?: t.TSTypeAnnotation | null,\n): Extract<t.TSDeclareMethod, { computed: false }>;\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  returnType?: t.TSTypeAnnotation | null,\n): t.TSDeclareMethod;\nexport function tsDeclareMethod(\n  decorators: t.Decorator[] | null | undefined = null,\n  key:\n    | t.Identifier\n    | t.StringLiteral\n    | t.NumericLiteral\n    | t.BigIntLiteral\n    | t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.FunctionParameter | t.TSParameterProperty)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSDeclareMethod {\n  const node = {\n    type: \"TSDeclareMethod\",\n    decorators,\n    key,\n    typeParameters,\n    params,\n    returnType,\n  } as t.TSDeclareMethod;\n  const defs = NODE_FIELDS.TSDeclareMethod;\n  validate(defs.decorators, node, \"decorators\", decorators, 1);\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsQualifiedName(\n  left: t.TSEntityName,\n  right: t.Identifier,\n): t.TSQualifiedName {\n  const node: t.TSQualifiedName = {\n    type: \"TSQualifiedName\",\n    left,\n    right,\n  };\n  const defs = NODE_FIELDS.TSQualifiedName;\n  validate(defs.left, node, \"left\", left, 1);\n  validate(defs.right, node, \"right\", right, 1);\n  return node;\n}\nexport function tsCallSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSCallSignatureDeclaration {\n  const node: t.TSCallSignatureDeclaration = {\n    type: \"TSCallSignatureDeclaration\",\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSCallSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsConstructSignatureDeclaration(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSConstructSignatureDeclaration {\n  const node: t.TSConstructSignatureDeclaration = {\n    type: \"TSConstructSignatureDeclaration\",\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSConstructSignatureDeclaration;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsPropertySignature(\n  key: t.Expression,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSPropertySignature {\n  const node: t.TSPropertySignature = {\n    type: \"TSPropertySignature\",\n    key,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSPropertySignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsMethodSignature(\n  key: t.Expression,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSMethodSignature {\n  const node: t.TSMethodSignature = {\n    type: \"TSMethodSignature\",\n    key,\n    typeParameters,\n    params,\n    returnType,\n    kind: null,\n  };\n  const defs = NODE_FIELDS.TSMethodSignature;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsIndexSignature(\n  parameters: t.Identifier[],\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n): t.TSIndexSignature {\n  const node: t.TSIndexSignature = {\n    type: \"TSIndexSignature\",\n    parameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSIndexSignature;\n  validate(defs.parameters, node, \"parameters\", parameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsAnyKeyword(): t.TSAnyKeyword {\n  return {\n    type: \"TSAnyKeyword\",\n  };\n}\nexport function tsBooleanKeyword(): t.TSBooleanKeyword {\n  return {\n    type: \"TSBooleanKeyword\",\n  };\n}\nexport function tsBigIntKeyword(): t.TSBigIntKeyword {\n  return {\n    type: \"TSBigIntKeyword\",\n  };\n}\nexport function tsIntrinsicKeyword(): t.TSIntrinsicKeyword {\n  return {\n    type: \"TSIntrinsicKeyword\",\n  };\n}\nexport function tsNeverKeyword(): t.TSNeverKeyword {\n  return {\n    type: \"TSNeverKeyword\",\n  };\n}\nexport function tsNullKeyword(): t.TSNullKeyword {\n  return {\n    type: \"TSNullKeyword\",\n  };\n}\nexport function tsNumberKeyword(): t.TSNumberKeyword {\n  return {\n    type: \"TSNumberKeyword\",\n  };\n}\nexport function tsObjectKeyword(): t.TSObjectKeyword {\n  return {\n    type: \"TSObjectKeyword\",\n  };\n}\nexport function tsStringKeyword(): t.TSStringKeyword {\n  return {\n    type: \"TSStringKeyword\",\n  };\n}\nexport function tsSymbolKeyword(): t.TSSymbolKeyword {\n  return {\n    type: \"TSSymbolKeyword\",\n  };\n}\nexport function tsUndefinedKeyword(): t.TSUndefinedKeyword {\n  return {\n    type: \"TSUndefinedKeyword\",\n  };\n}\nexport function tsUnknownKeyword(): t.TSUnknownKeyword {\n  return {\n    type: \"TSUnknownKeyword\",\n  };\n}\nexport function tsVoidKeyword(): t.TSVoidKeyword {\n  return {\n    type: \"TSVoidKeyword\",\n  };\n}\nexport function tsThisType(): t.TSThisType {\n  return {\n    type: \"TSThisType\",\n  };\n}\nexport function tsFunctionType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSFunctionType {\n  const node: t.TSFunctionType = {\n    type: \"TSFunctionType\",\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSFunctionType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsConstructorType(\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  params: (t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement)[],\n  returnType: t.TSTypeAnnotation | null = null,\n): t.TSConstructorType {\n  const node: t.TSConstructorType = {\n    type: \"TSConstructorType\",\n    typeParameters,\n    params,\n    returnType,\n  };\n  const defs = NODE_FIELDS.TSConstructorType;\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.params, node, \"params\", params, 1);\n  validate(defs.returnType, node, \"returnType\", returnType, 1);\n  return node;\n}\nexport function tsTypeReference(\n  typeName: t.TSEntityName,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSTypeReference {\n  const node: t.TSTypeReference = {\n    type: \"TSTypeReference\",\n    typeName,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSTypeReference;\n  validate(defs.typeName, node, \"typeName\", typeName, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsTypePredicate(\n  parameterName: t.Identifier | t.TSThisType,\n  typeAnnotation: t.TSTypeAnnotation | null = null,\n  asserts: boolean | null = null,\n): t.TSTypePredicate {\n  const node: t.TSTypePredicate = {\n    type: \"TSTypePredicate\",\n    parameterName,\n    typeAnnotation,\n    asserts,\n  };\n  const defs = NODE_FIELDS.TSTypePredicate;\n  validate(defs.parameterName, node, \"parameterName\", parameterName, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.asserts, node, \"asserts\", asserts);\n  return node;\n}\nexport function tsTypeQuery(\n  exprName: t.TSEntityName | t.TSImportType,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSTypeQuery {\n  const node: t.TSTypeQuery = {\n    type: \"TSTypeQuery\",\n    exprName,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSTypeQuery;\n  validate(defs.exprName, node, \"exprName\", exprName, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsTypeLiteral(members: t.TSTypeElement[]): t.TSTypeLiteral {\n  const node: t.TSTypeLiteral = {\n    type: \"TSTypeLiteral\",\n    members,\n  };\n  const defs = NODE_FIELDS.TSTypeLiteral;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function tsArrayType(elementType: t.TSType): t.TSArrayType {\n  const node: t.TSArrayType = {\n    type: \"TSArrayType\",\n    elementType,\n  };\n  const defs = NODE_FIELDS.TSArrayType;\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  return node;\n}\nexport function tsTupleType(\n  elementTypes: (t.TSType | t.TSNamedTupleMember)[],\n): t.TSTupleType {\n  const node: t.TSTupleType = {\n    type: \"TSTupleType\",\n    elementTypes,\n  };\n  const defs = NODE_FIELDS.TSTupleType;\n  validate(defs.elementTypes, node, \"elementTypes\", elementTypes, 1);\n  return node;\n}\nexport function tsOptionalType(typeAnnotation: t.TSType): t.TSOptionalType {\n  const node: t.TSOptionalType = {\n    type: \"TSOptionalType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSOptionalType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsRestType(typeAnnotation: t.TSType): t.TSRestType {\n  const node: t.TSRestType = {\n    type: \"TSRestType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSRestType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsNamedTupleMember(\n  label: t.Identifier,\n  elementType: t.TSType,\n  optional: boolean = false,\n): t.TSNamedTupleMember {\n  const node: t.TSNamedTupleMember = {\n    type: \"TSNamedTupleMember\",\n    label,\n    elementType,\n    optional,\n  };\n  const defs = NODE_FIELDS.TSNamedTupleMember;\n  validate(defs.label, node, \"label\", label, 1);\n  validate(defs.elementType, node, \"elementType\", elementType, 1);\n  validate(defs.optional, node, \"optional\", optional);\n  return node;\n}\nexport function tsUnionType(types: t.TSType[]): t.TSUnionType {\n  const node: t.TSUnionType = {\n    type: \"TSUnionType\",\n    types,\n  };\n  const defs = NODE_FIELDS.TSUnionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function tsIntersectionType(types: t.TSType[]): t.TSIntersectionType {\n  const node: t.TSIntersectionType = {\n    type: \"TSIntersectionType\",\n    types,\n  };\n  const defs = NODE_FIELDS.TSIntersectionType;\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function tsConditionalType(\n  checkType: t.TSType,\n  extendsType: t.TSType,\n  trueType: t.TSType,\n  falseType: t.TSType,\n): t.TSConditionalType {\n  const node: t.TSConditionalType = {\n    type: \"TSConditionalType\",\n    checkType,\n    extendsType,\n    trueType,\n    falseType,\n  };\n  const defs = NODE_FIELDS.TSConditionalType;\n  validate(defs.checkType, node, \"checkType\", checkType, 1);\n  validate(defs.extendsType, node, \"extendsType\", extendsType, 1);\n  validate(defs.trueType, node, \"trueType\", trueType, 1);\n  validate(defs.falseType, node, \"falseType\", falseType, 1);\n  return node;\n}\nexport function tsInferType(typeParameter: t.TSTypeParameter): t.TSInferType {\n  const node: t.TSInferType = {\n    type: \"TSInferType\",\n    typeParameter,\n  };\n  const defs = NODE_FIELDS.TSInferType;\n  validate(defs.typeParameter, node, \"typeParameter\", typeParameter, 1);\n  return node;\n}\nexport function tsParenthesizedType(\n  typeAnnotation: t.TSType,\n): t.TSParenthesizedType {\n  const node: t.TSParenthesizedType = {\n    type: \"TSParenthesizedType\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSParenthesizedType;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsTypeOperator(\n  typeAnnotation: t.TSType,\n  operator: \"keyof\" | \"readonly\" | \"unique\",\n): t.TSTypeOperator {\n  const node: t.TSTypeOperator = {\n    type: \"TSTypeOperator\",\n    typeAnnotation,\n    operator,\n  };\n  const defs = NODE_FIELDS.TSTypeOperator;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.operator, node, \"operator\", operator);\n  return node;\n}\nexport function tsIndexedAccessType(\n  objectType: t.TSType,\n  indexType: t.TSType,\n): t.TSIndexedAccessType {\n  const node: t.TSIndexedAccessType = {\n    type: \"TSIndexedAccessType\",\n    objectType,\n    indexType,\n  };\n  const defs = NODE_FIELDS.TSIndexedAccessType;\n  validate(defs.objectType, node, \"objectType\", objectType, 1);\n  validate(defs.indexType, node, \"indexType\", indexType, 1);\n  return node;\n}\nexport function tsMappedType(\n  key: t.Identifier,\n  constraint: t.TSType,\n  nameType: t.TSType | null = null,\n  typeAnnotation: t.TSType | null = null,\n): t.TSMappedType {\n  const node: t.TSMappedType = {\n    type: \"TSMappedType\",\n    key,\n    constraint,\n    nameType,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSMappedType;\n  validate(defs.key, node, \"key\", key, 1);\n  validate(defs.constraint, node, \"constraint\", constraint, 1);\n  validate(defs.nameType, node, \"nameType\", nameType, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsTemplateLiteralType(\n  quasis: t.TemplateElement[],\n  types: t.TSType[],\n): t.TSTemplateLiteralType {\n  const node: t.TSTemplateLiteralType = {\n    type: \"TSTemplateLiteralType\",\n    quasis,\n    types,\n  };\n  const defs = NODE_FIELDS.TSTemplateLiteralType;\n  validate(defs.quasis, node, \"quasis\", quasis, 1);\n  validate(defs.types, node, \"types\", types, 1);\n  return node;\n}\nexport function tsLiteralType(\n  literal:\n    | t.NumericLiteral\n    | t.StringLiteral\n    | t.BooleanLiteral\n    | t.BigIntLiteral\n    | t.TemplateLiteral\n    | t.UnaryExpression,\n): t.TSLiteralType {\n  const node: t.TSLiteralType = {\n    type: \"TSLiteralType\",\n    literal,\n  };\n  const defs = NODE_FIELDS.TSLiteralType;\n  validate(defs.literal, node, \"literal\", literal, 1);\n  return node;\n}\nexport function tsClassImplements(\n  expression: t.Expression,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSClassImplements {\n  const node: t.TSClassImplements = {\n    type: \"TSClassImplements\",\n    expression,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSClassImplements;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsInterfaceHeritage(\n  expression: t.Expression,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSInterfaceHeritage {\n  const node: t.TSInterfaceHeritage = {\n    type: \"TSInterfaceHeritage\",\n    expression,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSInterfaceHeritage;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsInterfaceDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  _extends: t.TSClassImplements[] | null | undefined = null,\n  body: t.TSInterfaceBody,\n): t.TSInterfaceDeclaration {\n  const node: t.TSInterfaceDeclaration = {\n    type: \"TSInterfaceDeclaration\",\n    id,\n    typeParameters,\n    extends: _extends,\n    body,\n  };\n  const defs = NODE_FIELDS.TSInterfaceDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.extends, node, \"extends\", _extends, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsInterfaceBody(body: t.TSTypeElement[]): t.TSInterfaceBody {\n  const node: t.TSInterfaceBody = {\n    type: \"TSInterfaceBody\",\n    body,\n  };\n  const defs = NODE_FIELDS.TSInterfaceBody;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsTypeAliasDeclaration(\n  id: t.Identifier,\n  typeParameters: t.TSTypeParameterDeclaration | null | undefined = null,\n  typeAnnotation: t.TSType,\n): t.TSTypeAliasDeclaration {\n  const node: t.TSTypeAliasDeclaration = {\n    type: \"TSTypeAliasDeclaration\",\n    id,\n    typeParameters,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSTypeAliasDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.typeParameters, node, \"typeParameters\", typeParameters, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsInstantiationExpression(\n  expression: t.Expression,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSInstantiationExpression {\n  const node: t.TSInstantiationExpression = {\n    type: \"TSInstantiationExpression\",\n    expression,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSInstantiationExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsAsExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSAsExpression {\n  const node: t.TSAsExpression = {\n    type: \"TSAsExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSAsExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsSatisfiesExpression(\n  expression: t.Expression,\n  typeAnnotation: t.TSType,\n): t.TSSatisfiesExpression {\n  const node: t.TSSatisfiesExpression = {\n    type: \"TSSatisfiesExpression\",\n    expression,\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSSatisfiesExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsTypeAssertion(\n  typeAnnotation: t.TSType,\n  expression: t.Expression,\n): t.TSTypeAssertion {\n  const node: t.TSTypeAssertion = {\n    type: \"TSTypeAssertion\",\n    typeAnnotation,\n    expression,\n  };\n  const defs = NODE_FIELDS.TSTypeAssertion;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function tsEnumBody(members: t.TSEnumMember[]): t.TSEnumBody {\n  const node: t.TSEnumBody = {\n    type: \"TSEnumBody\",\n    members,\n  };\n  const defs = NODE_FIELDS.TSEnumBody;\n  validate(defs.members, node, \"members\", members, 1);\n  return node;\n}\nexport function tsEnumDeclaration(\n  id: t.Identifier,\n  body: t.TSEnumBody,\n): t.TSEnumDeclaration {\n  const node: t.TSEnumDeclaration = {\n    type: \"TSEnumDeclaration\",\n    id,\n    body,\n  };\n  const defs = NODE_FIELDS.TSEnumDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsEnumMember(\n  id: t.Identifier | t.StringLiteral,\n  initializer: t.Expression | null = null,\n): t.TSEnumMember {\n  const node: t.TSEnumMember = {\n    type: \"TSEnumMember\",\n    id,\n    initializer,\n  };\n  const defs = NODE_FIELDS.TSEnumMember;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.initializer, node, \"initializer\", initializer, 1);\n  return node;\n}\nexport function tsModuleDeclaration(\n  id: t.TSEntityName | t.StringLiteral,\n  body: t.TSModuleBlock,\n): t.TSModuleDeclaration {\n  const node: t.TSModuleDeclaration = {\n    type: \"TSModuleDeclaration\",\n    id,\n    body,\n    kind: null,\n  };\n  const defs = NODE_FIELDS.TSModuleDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsModuleBlock(body: t.Statement[]): t.TSModuleBlock {\n  const node: t.TSModuleBlock = {\n    type: \"TSModuleBlock\",\n    body,\n  };\n  const defs = NODE_FIELDS.TSModuleBlock;\n  validate(defs.body, node, \"body\", body, 1);\n  return node;\n}\nexport function tsImportType(\n  source: t.StringLiteral,\n  qualifier: t.TSEntityName | null = null,\n  typeArguments: t.TSTypeParameterInstantiation | null = null,\n): t.TSImportType {\n  const node: t.TSImportType = {\n    type: \"TSImportType\",\n    source,\n    qualifier,\n    typeArguments,\n  };\n  const defs = NODE_FIELDS.TSImportType;\n  validate(defs.source, node, \"source\", source, 1);\n  validate(defs.qualifier, node, \"qualifier\", qualifier, 1);\n  validate(defs.typeArguments, node, \"typeArguments\", typeArguments, 1);\n  return node;\n}\nexport function tsImportEqualsDeclaration(\n  id: t.Identifier,\n  moduleReference: t.TSEntityName | t.TSExternalModuleReference,\n): t.TSImportEqualsDeclaration {\n  const node: t.TSImportEqualsDeclaration = {\n    type: \"TSImportEqualsDeclaration\",\n    id,\n    moduleReference,\n  };\n  const defs = NODE_FIELDS.TSImportEqualsDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  validate(defs.moduleReference, node, \"moduleReference\", moduleReference, 1);\n  return node;\n}\nexport function tsExternalModuleReference(\n  expression: t.StringLiteral,\n): t.TSExternalModuleReference {\n  const node: t.TSExternalModuleReference = {\n    type: \"TSExternalModuleReference\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSExternalModuleReference;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function tsNonNullExpression(\n  expression: t.Expression,\n): t.TSNonNullExpression {\n  const node: t.TSNonNullExpression = {\n    type: \"TSNonNullExpression\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSNonNullExpression;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function tsExportAssignment(\n  expression: t.Expression,\n): t.TSExportAssignment {\n  const node: t.TSExportAssignment = {\n    type: \"TSExportAssignment\",\n    expression,\n  };\n  const defs = NODE_FIELDS.TSExportAssignment;\n  validate(defs.expression, node, \"expression\", expression, 1);\n  return node;\n}\nexport function tsNamespaceExportDeclaration(\n  id: t.Identifier,\n): t.TSNamespaceExportDeclaration {\n  const node: t.TSNamespaceExportDeclaration = {\n    type: \"TSNamespaceExportDeclaration\",\n    id,\n  };\n  const defs = NODE_FIELDS.TSNamespaceExportDeclaration;\n  validate(defs.id, node, \"id\", id, 1);\n  return node;\n}\nexport function tsTypeAnnotation(typeAnnotation: t.TSType): t.TSTypeAnnotation {\n  const node: t.TSTypeAnnotation = {\n    type: \"TSTypeAnnotation\",\n    typeAnnotation,\n  };\n  const defs = NODE_FIELDS.TSTypeAnnotation;\n  validate(defs.typeAnnotation, node, \"typeAnnotation\", typeAnnotation, 1);\n  return node;\n}\nexport function tsTypeParameterInstantiation(\n  params: t.TSType[],\n): t.TSTypeParameterInstantiation {\n  const node: t.TSTypeParameterInstantiation = {\n    type: \"TSTypeParameterInstantiation\",\n    params,\n  };\n  const defs = NODE_FIELDS.TSTypeParameterInstantiation;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function tsTypeParameterDeclaration(\n  params: t.TSTypeParameter[],\n): t.TSTypeParameterDeclaration {\n  const node: t.TSTypeParameterDeclaration = {\n    type: \"TSTypeParameterDeclaration\",\n    params,\n  };\n  const defs = NODE_FIELDS.TSTypeParameterDeclaration;\n  validate(defs.params, node, \"params\", params, 1);\n  return node;\n}\nexport function tsTypeParameter(\n  constraint: t.TSType | null | undefined = null,\n  _default: t.TSType | null | undefined = null,\n  name: t.Identifier,\n): t.TSTypeParameter {\n  const node: t.TSTypeParameter = {\n    type: \"TSTypeParameter\",\n    constraint,\n    default: _default,\n    name,\n  };\n  const defs = NODE_FIELDS.TSTypeParameter;\n  validate(defs.constraint, node, \"constraint\", constraint, 1);\n  validate(defs.default, node, \"default\", _default, 1);\n  validate(defs.name, node, \"name\", name, 1);\n  return node;\n}\n/** @deprecated */\nfunction NumberLiteral(value: number) {\n  deprecationWarning(\"NumberLiteral\", \"NumericLiteral\", \"The node type \");\n  return numericLiteral(value);\n}\nexport { NumberLiteral as numberLiteral };\n/** @deprecated */\nfunction RegexLiteral(pattern: string, flags: string = \"\") {\n  deprecationWarning(\"RegexLiteral\", \"RegExpLiteral\", \"The node type \");\n  return regExpLiteral(pattern, flags);\n}\nexport { RegexLiteral as regexLiteral };\n/** @deprecated */\nfunction RestProperty(\n  argument:\n    | t.Identifier\n    | t.ArrayPattern\n    | t.ObjectPattern\n    | t.MemberExpression\n    | t.TSAsExpression\n    | t.TSSatisfiesExpression\n    | t.TSTypeAssertion\n    | t.TSNonNullExpression,\n) {\n  deprecationWarning(\"RestProperty\", \"RestElement\", \"The node type \");\n  return restElement(argument);\n}\nexport { RestProperty as restProperty };\n/** @deprecated */\nfunction SpreadProperty(argument: t.Expression) {\n  deprecationWarning(\"SpreadProperty\", \"SpreadElement\", \"The node type \");\n  return spreadElement(argument);\n}\nexport { SpreadProperty as spreadProperty };\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\nimport * as b from \"./lowercase.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\nfunction alias<const N extends keyof typeof b>(lowercase: N): (typeof b)[N] {\n  return function () {\n    deprecationWarning(\n      lowercase.replace(/^(?:ts|jsx|[a-z])/, x => x.toUpperCase()),\n      lowercase,\n      \"Usage of builders starting with an uppercase letter such as \",\n      \"uppercase builders\",\n    );\n    return (b[lowercase] as any)(...arguments);\n  } as any;\n}\n\nexport const ArrayExpression = alias(\"arrayExpression\"),\n  AssignmentExpression = alias(\"assignmentExpression\"),\n  BinaryExpression = alias(\"binaryExpression\"),\n  InterpreterDirective = alias(\"interpreterDirective\"),\n  Directive = alias(\"directive\"),\n  DirectiveLiteral = alias(\"directiveLiteral\"),\n  BlockStatement = alias(\"blockStatement\"),\n  BreakStatement = alias(\"breakStatement\"),\n  CallExpression = alias(\"callExpression\"),\n  CatchClause = alias(\"catchClause\"),\n  ConditionalExpression = alias(\"conditionalExpression\"),\n  ContinueStatement = alias(\"continueStatement\"),\n  DebuggerStatement = alias(\"debuggerStatement\"),\n  DoWhileStatement = alias(\"doWhileStatement\"),\n  EmptyStatement = alias(\"emptyStatement\"),\n  ExpressionStatement = alias(\"expressionStatement\"),\n  File = alias(\"file\"),\n  ForInStatement = alias(\"forInStatement\"),\n  ForStatement = alias(\"forStatement\"),\n  FunctionDeclaration = alias(\"functionDeclaration\"),\n  FunctionExpression = alias(\"functionExpression\"),\n  Identifier = alias(\"identifier\"),\n  IfStatement = alias(\"ifStatement\"),\n  LabeledStatement = alias(\"labeledStatement\"),\n  StringLiteral = alias(\"stringLiteral\"),\n  NumericLiteral = alias(\"numericLiteral\"),\n  NullLiteral = alias(\"nullLiteral\"),\n  BooleanLiteral = alias(\"booleanLiteral\"),\n  RegExpLiteral = alias(\"regExpLiteral\"),\n  LogicalExpression = alias(\"logicalExpression\"),\n  MemberExpression = alias(\"memberExpression\"),\n  NewExpression = alias(\"newExpression\"),\n  Program = alias(\"program\"),\n  ObjectExpression = alias(\"objectExpression\"),\n  ObjectMethod = alias(\"objectMethod\"),\n  ObjectProperty = alias(\"objectProperty\"),\n  RestElement = alias(\"restElement\"),\n  ReturnStatement = alias(\"returnStatement\"),\n  SequenceExpression = alias(\"sequenceExpression\"),\n  ParenthesizedExpression = alias(\"parenthesizedExpression\"),\n  SwitchCase = alias(\"switchCase\"),\n  SwitchStatement = alias(\"switchStatement\"),\n  ThisExpression = alias(\"thisExpression\"),\n  ThrowStatement = alias(\"throwStatement\"),\n  TryStatement = alias(\"tryStatement\"),\n  UnaryExpression = alias(\"unaryExpression\"),\n  UpdateExpression = alias(\"updateExpression\"),\n  VariableDeclaration = alias(\"variableDeclaration\"),\n  VariableDeclarator = alias(\"variableDeclarator\"),\n  WhileStatement = alias(\"whileStatement\"),\n  WithStatement = alias(\"withStatement\"),\n  AssignmentPattern = alias(\"assignmentPattern\"),\n  ArrayPattern = alias(\"arrayPattern\"),\n  ArrowFunctionExpression = alias(\"arrowFunctionExpression\"),\n  ClassBody = alias(\"classBody\"),\n  ClassExpression = alias(\"classExpression\"),\n  ClassDeclaration = alias(\"classDeclaration\"),\n  ExportAllDeclaration = alias(\"exportAllDeclaration\"),\n  ExportDefaultDeclaration = alias(\"exportDefaultDeclaration\"),\n  ExportNamedDeclaration = alias(\"exportNamedDeclaration\"),\n  ExportSpecifier = alias(\"exportSpecifier\"),\n  ForOfStatement = alias(\"forOfStatement\"),\n  ImportDeclaration = alias(\"importDeclaration\"),\n  ImportDefaultSpecifier = alias(\"importDefaultSpecifier\"),\n  ImportNamespaceSpecifier = alias(\"importNamespaceSpecifier\"),\n  ImportSpecifier = alias(\"importSpecifier\"),\n  ImportExpression = alias(\"importExpression\"),\n  MetaProperty = alias(\"metaProperty\"),\n  ClassMethod = alias(\"classMethod\"),\n  ObjectPattern = alias(\"objectPattern\"),\n  SpreadElement = alias(\"spreadElement\"),\n  Super = alias(\"super\"),\n  TaggedTemplateExpression = alias(\"taggedTemplateExpression\"),\n  TemplateElement = alias(\"templateElement\"),\n  TemplateLiteral = alias(\"templateLiteral\"),\n  YieldExpression = alias(\"yieldExpression\"),\n  AwaitExpression = alias(\"awaitExpression\"),\n  Import = alias(\"import\"),\n  BigIntLiteral = alias(\"bigIntLiteral\"),\n  ExportNamespaceSpecifier = alias(\"exportNamespaceSpecifier\"),\n  OptionalMemberExpression = alias(\"optionalMemberExpression\"),\n  OptionalCallExpression = alias(\"optionalCallExpression\"),\n  ClassProperty = alias(\"classProperty\"),\n  ClassAccessorProperty = alias(\"classAccessorProperty\"),\n  ClassPrivateProperty = alias(\"classPrivateProperty\"),\n  ClassPrivateMethod = alias(\"classPrivateMethod\"),\n  PrivateName = alias(\"privateName\"),\n  StaticBlock = alias(\"staticBlock\"),\n  ImportAttribute = alias(\"importAttribute\"),\n  AnyTypeAnnotation = alias(\"anyTypeAnnotation\"),\n  ArrayTypeAnnotation = alias(\"arrayTypeAnnotation\"),\n  BooleanTypeAnnotation = alias(\"booleanTypeAnnotation\"),\n  BooleanLiteralTypeAnnotation = alias(\"booleanLiteralTypeAnnotation\"),\n  NullLiteralTypeAnnotation = alias(\"nullLiteralTypeAnnotation\"),\n  ClassImplements = alias(\"classImplements\"),\n  DeclareClass = alias(\"declareClass\"),\n  DeclareFunction = alias(\"declareFunction\"),\n  DeclareInterface = alias(\"declareInterface\"),\n  DeclareModule = alias(\"declareModule\"),\n  DeclareModuleExports = alias(\"declareModuleExports\"),\n  DeclareTypeAlias = alias(\"declareTypeAlias\"),\n  DeclareOpaqueType = alias(\"declareOpaqueType\"),\n  DeclareVariable = alias(\"declareVariable\"),\n  DeclareExportDeclaration = alias(\"declareExportDeclaration\"),\n  DeclareExportAllDeclaration = alias(\"declareExportAllDeclaration\"),\n  DeclaredPredicate = alias(\"declaredPredicate\"),\n  ExistsTypeAnnotation = alias(\"existsTypeAnnotation\"),\n  FunctionTypeAnnotation = alias(\"functionTypeAnnotation\"),\n  FunctionTypeParam = alias(\"functionTypeParam\"),\n  GenericTypeAnnotation = alias(\"genericTypeAnnotation\"),\n  InferredPredicate = alias(\"inferredPredicate\"),\n  InterfaceExtends = alias(\"interfaceExtends\"),\n  InterfaceDeclaration = alias(\"interfaceDeclaration\"),\n  InterfaceTypeAnnotation = alias(\"interfaceTypeAnnotation\"),\n  IntersectionTypeAnnotation = alias(\"intersectionTypeAnnotation\"),\n  MixedTypeAnnotation = alias(\"mixedTypeAnnotation\"),\n  EmptyTypeAnnotation = alias(\"emptyTypeAnnotation\"),\n  NullableTypeAnnotation = alias(\"nullableTypeAnnotation\"),\n  NumberLiteralTypeAnnotation = alias(\"numberLiteralTypeAnnotation\"),\n  NumberTypeAnnotation = alias(\"numberTypeAnnotation\"),\n  ObjectTypeAnnotation = alias(\"objectTypeAnnotation\"),\n  ObjectTypeInternalSlot = alias(\"objectTypeInternalSlot\"),\n  ObjectTypeCallProperty = alias(\"objectTypeCallProperty\"),\n  ObjectTypeIndexer = alias(\"objectTypeIndexer\"),\n  ObjectTypeProperty = alias(\"objectTypeProperty\"),\n  ObjectTypeSpreadProperty = alias(\"objectTypeSpreadProperty\"),\n  OpaqueType = alias(\"opaqueType\"),\n  QualifiedTypeIdentifier = alias(\"qualifiedTypeIdentifier\"),\n  StringLiteralTypeAnnotation = alias(\"stringLiteralTypeAnnotation\"),\n  StringTypeAnnotation = alias(\"stringTypeAnnotation\"),\n  SymbolTypeAnnotation = alias(\"symbolTypeAnnotation\"),\n  ThisTypeAnnotation = alias(\"thisTypeAnnotation\"),\n  TupleTypeAnnotation = alias(\"tupleTypeAnnotation\"),\n  TypeofTypeAnnotation = alias(\"typeofTypeAnnotation\"),\n  TypeAlias = alias(\"typeAlias\"),\n  TypeAnnotation = alias(\"typeAnnotation\"),\n  TypeCastExpression = alias(\"typeCastExpression\"),\n  TypeParameter = alias(\"typeParameter\"),\n  TypeParameterDeclaration = alias(\"typeParameterDeclaration\"),\n  TypeParameterInstantiation = alias(\"typeParameterInstantiation\"),\n  UnionTypeAnnotation = alias(\"unionTypeAnnotation\"),\n  Variance = alias(\"variance\"),\n  VoidTypeAnnotation = alias(\"voidTypeAnnotation\"),\n  EnumDeclaration = alias(\"enumDeclaration\"),\n  EnumBooleanBody = alias(\"enumBooleanBody\"),\n  EnumNumberBody = alias(\"enumNumberBody\"),\n  EnumStringBody = alias(\"enumStringBody\"),\n  EnumSymbolBody = alias(\"enumSymbolBody\"),\n  EnumBooleanMember = alias(\"enumBooleanMember\"),\n  EnumNumberMember = alias(\"enumNumberMember\"),\n  EnumStringMember = alias(\"enumStringMember\"),\n  EnumDefaultedMember = alias(\"enumDefaultedMember\"),\n  IndexedAccessType = alias(\"indexedAccessType\"),\n  OptionalIndexedAccessType = alias(\"optionalIndexedAccessType\"),\n  JSXAttribute = alias(\"jsxAttribute\"),\n  JSXClosingElement = alias(\"jsxClosingElement\"),\n  JSXElement = alias(\"jsxElement\"),\n  JSXEmptyExpression = alias(\"jsxEmptyExpression\"),\n  JSXExpressionContainer = alias(\"jsxExpressionContainer\"),\n  JSXSpreadChild = alias(\"jsxSpreadChild\"),\n  JSXIdentifier = alias(\"jsxIdentifier\"),\n  JSXMemberExpression = alias(\"jsxMemberExpression\"),\n  JSXNamespacedName = alias(\"jsxNamespacedName\"),\n  JSXOpeningElement = alias(\"jsxOpeningElement\"),\n  JSXSpreadAttribute = alias(\"jsxSpreadAttribute\"),\n  JSXText = alias(\"jsxText\"),\n  JSXFragment = alias(\"jsxFragment\"),\n  JSXOpeningFragment = alias(\"jsxOpeningFragment\"),\n  JSXClosingFragment = alias(\"jsxClosingFragment\"),\n  Placeholder = alias(\"placeholder\"),\n  V8IntrinsicIdentifier = alias(\"v8IntrinsicIdentifier\"),\n  ArgumentPlaceholder = alias(\"argumentPlaceholder\"),\n  BindExpression = alias(\"bindExpression\"),\n  Decorator = alias(\"decorator\"),\n  DoExpression = alias(\"doExpression\"),\n  ExportDefaultSpecifier = alias(\"exportDefaultSpecifier\"),\n  ModuleExpression = alias(\"moduleExpression\"),\n  TopicReference = alias(\"topicReference\"),\n  PipelineTopicExpression = alias(\"pipelineTopicExpression\"),\n  PipelineBareFunction = alias(\"pipelineBareFunction\"),\n  PipelinePrimaryTopicReference = alias(\"pipelinePrimaryTopicReference\"),\n  VoidPattern = alias(\"voidPattern\"),\n  TSParameterProperty = alias(\"tsParameterProperty\"),\n  TSDeclareFunction = alias(\"tsDeclareFunction\"),\n  TSDeclareMethod = alias(\"tsDeclareMethod\"),\n  TSQualifiedName = alias(\"tsQualifiedName\"),\n  TSCallSignatureDeclaration = alias(\"tsCallSignatureDeclaration\"),\n  TSConstructSignatureDeclaration = alias(\"tsConstructSignatureDeclaration\"),\n  TSPropertySignature = alias(\"tsPropertySignature\"),\n  TSMethodSignature = alias(\"tsMethodSignature\"),\n  TSIndexSignature = alias(\"tsIndexSignature\"),\n  TSAnyKeyword = alias(\"tsAnyKeyword\"),\n  TSBooleanKeyword = alias(\"tsBooleanKeyword\"),\n  TSBigIntKeyword = alias(\"tsBigIntKeyword\"),\n  TSIntrinsicKeyword = alias(\"tsIntrinsicKeyword\"),\n  TSNeverKeyword = alias(\"tsNeverKeyword\"),\n  TSNullKeyword = alias(\"tsNullKeyword\"),\n  TSNumberKeyword = alias(\"tsNumberKeyword\"),\n  TSObjectKeyword = alias(\"tsObjectKeyword\"),\n  TSStringKeyword = alias(\"tsStringKeyword\"),\n  TSSymbolKeyword = alias(\"tsSymbolKeyword\"),\n  TSUndefinedKeyword = alias(\"tsUndefinedKeyword\"),\n  TSUnknownKeyword = alias(\"tsUnknownKeyword\"),\n  TSVoidKeyword = alias(\"tsVoidKeyword\"),\n  TSThisType = alias(\"tsThisType\"),\n  TSFunctionType = alias(\"tsFunctionType\"),\n  TSConstructorType = alias(\"tsConstructorType\"),\n  TSTypeReference = alias(\"tsTypeReference\"),\n  TSTypePredicate = alias(\"tsTypePredicate\"),\n  TSTypeQuery = alias(\"tsTypeQuery\"),\n  TSTypeLiteral = alias(\"tsTypeLiteral\"),\n  TSArrayType = alias(\"tsArrayType\"),\n  TSTupleType = alias(\"tsTupleType\"),\n  TSOptionalType = alias(\"tsOptionalType\"),\n  TSRestType = alias(\"tsRestType\"),\n  TSNamedTupleMember = alias(\"tsNamedTupleMember\"),\n  TSUnionType = alias(\"tsUnionType\"),\n  TSIntersectionType = alias(\"tsIntersectionType\"),\n  TSConditionalType = alias(\"tsConditionalType\"),\n  TSInferType = alias(\"tsInferType\"),\n  TSParenthesizedType = alias(\"tsParenthesizedType\"),\n  TSTypeOperator = alias(\"tsTypeOperator\"),\n  TSIndexedAccessType = alias(\"tsIndexedAccessType\"),\n  TSMappedType = alias(\"tsMappedType\"),\n  TSTemplateLiteralType = alias(\"tsTemplateLiteralType\"),\n  TSLiteralType = alias(\"tsLiteralType\"),\n  TSClassImplements = alias(\"tsClassImplements\"),\n  TSInterfaceHeritage = alias(\"tsInterfaceHeritage\"),\n  TSInterfaceDeclaration = alias(\"tsInterfaceDeclaration\"),\n  TSInterfaceBody = alias(\"tsInterfaceBody\"),\n  TSTypeAliasDeclaration = alias(\"tsTypeAliasDeclaration\"),\n  TSInstantiationExpression = alias(\"tsInstantiationExpression\"),\n  TSAsExpression = alias(\"tsAsExpression\"),\n  TSSatisfiesExpression = alias(\"tsSatisfiesExpression\"),\n  TSTypeAssertion = alias(\"tsTypeAssertion\"),\n  TSEnumBody = alias(\"tsEnumBody\"),\n  TSEnumDeclaration = alias(\"tsEnumDeclaration\"),\n  TSEnumMember = alias(\"tsEnumMember\"),\n  TSModuleDeclaration = alias(\"tsModuleDeclaration\"),\n  TSModuleBlock = alias(\"tsModuleBlock\"),\n  TSImportType = alias(\"tsImportType\"),\n  TSImportEqualsDeclaration = alias(\"tsImportEqualsDeclaration\"),\n  TSExternalModuleReference = alias(\"tsExternalModuleReference\"),\n  TSNonNullExpression = alias(\"tsNonNullExpression\"),\n  TSExportAssignment = alias(\"tsExportAssignment\"),\n  TSNamespaceExportDeclaration = alias(\"tsNamespaceExportDeclaration\"),\n  TSTypeAnnotation = alias(\"tsTypeAnnotation\"),\n  TSTypeParameterInstantiation = alias(\"tsTypeParameterInstantiation\"),\n  TSTypeParameterDeclaration = alias(\"tsTypeParameterDeclaration\"),\n  TSTypeParameter = alias(\"tsTypeParameter\");\n","import { stringLiteral } from \"../../builders/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\nimport { inherits } from \"../../index.ts\";\n\nexport default function cleanJSXElementLiteralChild(\n  child: t.JSXText,\n  args: t.Node[],\n) {\n  const lines = child.value.split(/\\r\\n|\\n|\\r/);\n\n  let lastNonEmptyLine = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    if (/[^ \\t]/.exec(lines[i])) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  let str = \"\";\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    const isFirstLine = i === 0;\n    const isLastLine = i === lines.length - 1;\n    const isLastNonEmptyLine = i === lastNonEmptyLine;\n\n    // replace rendered whitespace tabs with spaces\n    let trimmedLine = line.replace(/\\t/g, \" \");\n\n    // trim whitespace touching a newline\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^ +/, \"\");\n    }\n\n    // trim whitespace touching an endline\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/ +$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push(inherits(stringLiteral(str), child));\n}\n","import {\n  isJSXText,\n  isJSXExpressionContainer,\n  isJSXEmptyExpression,\n} from \"../../validators/generated/index.ts\";\nimport cleanJSXElementLiteralChild from \"../../utils/react/cleanJSXElementLiteralChild.ts\";\nimport type * as t from \"../../index.ts\";\n\ntype ReturnedChild =\n  | t.JSXSpreadChild\n  | t.JSXElement\n  | t.JSXFragment\n  | t.Expression;\n\nexport default function buildChildren(\n  node: t.JSXElement | t.JSXFragment,\n): ReturnedChild[] {\n  const elements = [];\n\n  for (let i = 0; i < node.children.length; i++) {\n    let child: any = node.children[i];\n\n    if (isJSXText(child)) {\n      cleanJSXElementLiteralChild(child, elements);\n      continue;\n    }\n\n    if (isJSXExpressionContainer(child)) child = child.expression;\n    if (isJSXEmptyExpression(child)) continue;\n\n    elements.push(child);\n  }\n\n  return elements;\n}\n","import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function isNode(node: any): node is t.Node {\n  return !!(node && VISITOR_KEYS[node.type]);\n}\n","import isNode from \"../validators/isNode.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function assertNode(node?: any): asserts node is t.Node {\n  if (!isNode(node)) {\n    const type = node?.type ?? JSON.stringify(node);\n    throw new TypeError(`Not a valid node of type \"${type}\"`);\n  }\n}\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport is from \"../../validators/is.ts\";\nimport type * as t from \"../../index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\nfunction assert(type: string, node: any, opts?: any): void {\n  if (!is(type, node, opts)) {\n    throw new Error(\n      `Expected type \"${type}\" with option ${JSON.stringify(opts)}, ` +\n        `but instead got \"${node.type}\".`,\n    );\n  }\n}\n\nexport function assertArrayExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayExpression {\n  assert(\"ArrayExpression\", node, opts);\n}\nexport function assertAssignmentExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AssignmentExpression {\n  assert(\"AssignmentExpression\", node, opts);\n}\nexport function assertBinaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BinaryExpression {\n  assert(\"BinaryExpression\", node, opts);\n}\nexport function assertInterpreterDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterpreterDirective {\n  assert(\"InterpreterDirective\", node, opts);\n}\nexport function assertDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Directive {\n  assert(\"Directive\", node, opts);\n}\nexport function assertDirectiveLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DirectiveLiteral {\n  assert(\"DirectiveLiteral\", node, opts);\n}\nexport function assertBlockStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BlockStatement {\n  assert(\"BlockStatement\", node, opts);\n}\nexport function assertBreakStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BreakStatement {\n  assert(\"BreakStatement\", node, opts);\n}\nexport function assertCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CallExpression {\n  assert(\"CallExpression\", node, opts);\n}\nexport function assertCatchClause(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CatchClause {\n  assert(\"CatchClause\", node, opts);\n}\nexport function assertConditionalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ConditionalExpression {\n  assert(\"ConditionalExpression\", node, opts);\n}\nexport function assertContinueStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ContinueStatement {\n  assert(\"ContinueStatement\", node, opts);\n}\nexport function assertDebuggerStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DebuggerStatement {\n  assert(\"DebuggerStatement\", node, opts);\n}\nexport function assertDoWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DoWhileStatement {\n  assert(\"DoWhileStatement\", node, opts);\n}\nexport function assertEmptyStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EmptyStatement {\n  assert(\"EmptyStatement\", node, opts);\n}\nexport function assertExpressionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExpressionStatement {\n  assert(\"ExpressionStatement\", node, opts);\n}\nexport function assertFile(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.File {\n  assert(\"File\", node, opts);\n}\nexport function assertForInStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForInStatement {\n  assert(\"ForInStatement\", node, opts);\n}\nexport function assertForStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForStatement {\n  assert(\"ForStatement\", node, opts);\n}\nexport function assertFunctionDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionDeclaration {\n  assert(\"FunctionDeclaration\", node, opts);\n}\nexport function assertFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionExpression {\n  assert(\"FunctionExpression\", node, opts);\n}\nexport function assertIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Identifier {\n  assert(\"Identifier\", node, opts);\n}\nexport function assertIfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IfStatement {\n  assert(\"IfStatement\", node, opts);\n}\nexport function assertLabeledStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LabeledStatement {\n  assert(\"LabeledStatement\", node, opts);\n}\nexport function assertStringLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringLiteral {\n  assert(\"StringLiteral\", node, opts);\n}\nexport function assertNumericLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumericLiteral {\n  assert(\"NumericLiteral\", node, opts);\n}\nexport function assertNullLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullLiteral {\n  assert(\"NullLiteral\", node, opts);\n}\nexport function assertBooleanLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanLiteral {\n  assert(\"BooleanLiteral\", node, opts);\n}\nexport function assertRegExpLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.RegExpLiteral {\n  assert(\"RegExpLiteral\", node, opts);\n}\nexport function assertLogicalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LogicalExpression {\n  assert(\"LogicalExpression\", node, opts);\n}\nexport function assertMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MemberExpression {\n  assert(\"MemberExpression\", node, opts);\n}\nexport function assertNewExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NewExpression {\n  assert(\"NewExpression\", node, opts);\n}\nexport function assertProgram(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Program {\n  assert(\"Program\", node, opts);\n}\nexport function assertObjectExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectExpression {\n  assert(\"ObjectExpression\", node, opts);\n}\nexport function assertObjectMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectMethod {\n  assert(\"ObjectMethod\", node, opts);\n}\nexport function assertObjectProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectProperty {\n  assert(\"ObjectProperty\", node, opts);\n}\nexport function assertRestElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.RestElement {\n  assert(\"RestElement\", node, opts);\n}\nexport function assertReturnStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ReturnStatement {\n  assert(\"ReturnStatement\", node, opts);\n}\nexport function assertSequenceExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SequenceExpression {\n  assert(\"SequenceExpression\", node, opts);\n}\nexport function assertParenthesizedExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ParenthesizedExpression {\n  assert(\"ParenthesizedExpression\", node, opts);\n}\nexport function assertSwitchCase(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SwitchCase {\n  assert(\"SwitchCase\", node, opts);\n}\nexport function assertSwitchStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SwitchStatement {\n  assert(\"SwitchStatement\", node, opts);\n}\nexport function assertThisExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThisExpression {\n  assert(\"ThisExpression\", node, opts);\n}\nexport function assertThrowStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThrowStatement {\n  assert(\"ThrowStatement\", node, opts);\n}\nexport function assertTryStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TryStatement {\n  assert(\"TryStatement\", node, opts);\n}\nexport function assertUnaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnaryExpression {\n  assert(\"UnaryExpression\", node, opts);\n}\nexport function assertUpdateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UpdateExpression {\n  assert(\"UpdateExpression\", node, opts);\n}\nexport function assertVariableDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VariableDeclaration {\n  assert(\"VariableDeclaration\", node, opts);\n}\nexport function assertVariableDeclarator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VariableDeclarator {\n  assert(\"VariableDeclarator\", node, opts);\n}\nexport function assertWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.WhileStatement {\n  assert(\"WhileStatement\", node, opts);\n}\nexport function assertWithStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.WithStatement {\n  assert(\"WithStatement\", node, opts);\n}\nexport function assertAssignmentPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AssignmentPattern {\n  assert(\"AssignmentPattern\", node, opts);\n}\nexport function assertArrayPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayPattern {\n  assert(\"ArrayPattern\", node, opts);\n}\nexport function assertArrowFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrowFunctionExpression {\n  assert(\"ArrowFunctionExpression\", node, opts);\n}\nexport function assertClassBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassBody {\n  assert(\"ClassBody\", node, opts);\n}\nexport function assertClassExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassExpression {\n  assert(\"ClassExpression\", node, opts);\n}\nexport function assertClassDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassDeclaration {\n  assert(\"ClassDeclaration\", node, opts);\n}\nexport function assertExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportAllDeclaration {\n  assert(\"ExportAllDeclaration\", node, opts);\n}\nexport function assertExportDefaultDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDefaultDeclaration {\n  assert(\"ExportDefaultDeclaration\", node, opts);\n}\nexport function assertExportNamedDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportNamedDeclaration {\n  assert(\"ExportNamedDeclaration\", node, opts);\n}\nexport function assertExportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportSpecifier {\n  assert(\"ExportSpecifier\", node, opts);\n}\nexport function assertForOfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForOfStatement {\n  assert(\"ForOfStatement\", node, opts);\n}\nexport function assertImportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportDeclaration {\n  assert(\"ImportDeclaration\", node, opts);\n}\nexport function assertImportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportDefaultSpecifier {\n  assert(\"ImportDefaultSpecifier\", node, opts);\n}\nexport function assertImportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportNamespaceSpecifier {\n  assert(\"ImportNamespaceSpecifier\", node, opts);\n}\nexport function assertImportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportSpecifier {\n  assert(\"ImportSpecifier\", node, opts);\n}\nexport function assertImportExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportExpression {\n  assert(\"ImportExpression\", node, opts);\n}\nexport function assertMetaProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MetaProperty {\n  assert(\"MetaProperty\", node, opts);\n}\nexport function assertClassMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassMethod {\n  assert(\"ClassMethod\", node, opts);\n}\nexport function assertObjectPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectPattern {\n  assert(\"ObjectPattern\", node, opts);\n}\nexport function assertSpreadElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SpreadElement {\n  assert(\"SpreadElement\", node, opts);\n}\nexport function assertSuper(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Super {\n  assert(\"Super\", node, opts);\n}\nexport function assertTaggedTemplateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TaggedTemplateExpression {\n  assert(\"TaggedTemplateExpression\", node, opts);\n}\nexport function assertTemplateElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TemplateElement {\n  assert(\"TemplateElement\", node, opts);\n}\nexport function assertTemplateLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TemplateLiteral {\n  assert(\"TemplateLiteral\", node, opts);\n}\nexport function assertYieldExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.YieldExpression {\n  assert(\"YieldExpression\", node, opts);\n}\nexport function assertAwaitExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AwaitExpression {\n  assert(\"AwaitExpression\", node, opts);\n}\nexport function assertImport(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Import {\n  assert(\"Import\", node, opts);\n}\nexport function assertBigIntLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BigIntLiteral {\n  assert(\"BigIntLiteral\", node, opts);\n}\nexport function assertExportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportNamespaceSpecifier {\n  assert(\"ExportNamespaceSpecifier\", node, opts);\n}\nexport function assertOptionalMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalMemberExpression {\n  assert(\"OptionalMemberExpression\", node, opts);\n}\nexport function assertOptionalCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalCallExpression {\n  assert(\"OptionalCallExpression\", node, opts);\n}\nexport function assertClassProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassProperty {\n  assert(\"ClassProperty\", node, opts);\n}\nexport function assertClassAccessorProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassAccessorProperty {\n  assert(\"ClassAccessorProperty\", node, opts);\n}\nexport function assertClassPrivateProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassPrivateProperty {\n  assert(\"ClassPrivateProperty\", node, opts);\n}\nexport function assertClassPrivateMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassPrivateMethod {\n  assert(\"ClassPrivateMethod\", node, opts);\n}\nexport function assertPrivateName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PrivateName {\n  assert(\"PrivateName\", node, opts);\n}\nexport function assertStaticBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StaticBlock {\n  assert(\"StaticBlock\", node, opts);\n}\nexport function assertImportAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportAttribute {\n  assert(\"ImportAttribute\", node, opts);\n}\nexport function assertAnyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.AnyTypeAnnotation {\n  assert(\"AnyTypeAnnotation\", node, opts);\n}\nexport function assertArrayTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArrayTypeAnnotation {\n  assert(\"ArrayTypeAnnotation\", node, opts);\n}\nexport function assertBooleanTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanTypeAnnotation {\n  assert(\"BooleanTypeAnnotation\", node, opts);\n}\nexport function assertBooleanLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BooleanLiteralTypeAnnotation {\n  assert(\"BooleanLiteralTypeAnnotation\", node, opts);\n}\nexport function assertNullLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullLiteralTypeAnnotation {\n  assert(\"NullLiteralTypeAnnotation\", node, opts);\n}\nexport function assertClassImplements(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ClassImplements {\n  assert(\"ClassImplements\", node, opts);\n}\nexport function assertDeclareClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareClass {\n  assert(\"DeclareClass\", node, opts);\n}\nexport function assertDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareFunction {\n  assert(\"DeclareFunction\", node, opts);\n}\nexport function assertDeclareInterface(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareInterface {\n  assert(\"DeclareInterface\", node, opts);\n}\nexport function assertDeclareModule(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareModule {\n  assert(\"DeclareModule\", node, opts);\n}\nexport function assertDeclareModuleExports(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareModuleExports {\n  assert(\"DeclareModuleExports\", node, opts);\n}\nexport function assertDeclareTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareTypeAlias {\n  assert(\"DeclareTypeAlias\", node, opts);\n}\nexport function assertDeclareOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareOpaqueType {\n  assert(\"DeclareOpaqueType\", node, opts);\n}\nexport function assertDeclareVariable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareVariable {\n  assert(\"DeclareVariable\", node, opts);\n}\nexport function assertDeclareExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareExportDeclaration {\n  assert(\"DeclareExportDeclaration\", node, opts);\n}\nexport function assertDeclareExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclareExportAllDeclaration {\n  assert(\"DeclareExportAllDeclaration\", node, opts);\n}\nexport function assertDeclaredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DeclaredPredicate {\n  assert(\"DeclaredPredicate\", node, opts);\n}\nexport function assertExistsTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExistsTypeAnnotation {\n  assert(\"ExistsTypeAnnotation\", node, opts);\n}\nexport function assertFunctionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionTypeAnnotation {\n  assert(\"FunctionTypeAnnotation\", node, opts);\n}\nexport function assertFunctionTypeParam(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionTypeParam {\n  assert(\"FunctionTypeParam\", node, opts);\n}\nexport function assertGenericTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.GenericTypeAnnotation {\n  assert(\"GenericTypeAnnotation\", node, opts);\n}\nexport function assertInferredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InferredPredicate {\n  assert(\"InferredPredicate\", node, opts);\n}\nexport function assertInterfaceExtends(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceExtends {\n  assert(\"InterfaceExtends\", node, opts);\n}\nexport function assertInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceDeclaration {\n  assert(\"InterfaceDeclaration\", node, opts);\n}\nexport function assertInterfaceTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.InterfaceTypeAnnotation {\n  assert(\"InterfaceTypeAnnotation\", node, opts);\n}\nexport function assertIntersectionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IntersectionTypeAnnotation {\n  assert(\"IntersectionTypeAnnotation\", node, opts);\n}\nexport function assertMixedTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.MixedTypeAnnotation {\n  assert(\"MixedTypeAnnotation\", node, opts);\n}\nexport function assertEmptyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EmptyTypeAnnotation {\n  assert(\"EmptyTypeAnnotation\", node, opts);\n}\nexport function assertNullableTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NullableTypeAnnotation {\n  assert(\"NullableTypeAnnotation\", node, opts);\n}\nexport function assertNumberLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumberLiteralTypeAnnotation {\n  assert(\"NumberLiteralTypeAnnotation\", node, opts);\n}\nexport function assertNumberTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.NumberTypeAnnotation {\n  assert(\"NumberTypeAnnotation\", node, opts);\n}\nexport function assertObjectTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeAnnotation {\n  assert(\"ObjectTypeAnnotation\", node, opts);\n}\nexport function assertObjectTypeInternalSlot(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeInternalSlot {\n  assert(\"ObjectTypeInternalSlot\", node, opts);\n}\nexport function assertObjectTypeCallProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeCallProperty {\n  assert(\"ObjectTypeCallProperty\", node, opts);\n}\nexport function assertObjectTypeIndexer(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeIndexer {\n  assert(\"ObjectTypeIndexer\", node, opts);\n}\nexport function assertObjectTypeProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeProperty {\n  assert(\"ObjectTypeProperty\", node, opts);\n}\nexport function assertObjectTypeSpreadProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectTypeSpreadProperty {\n  assert(\"ObjectTypeSpreadProperty\", node, opts);\n}\nexport function assertOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OpaqueType {\n  assert(\"OpaqueType\", node, opts);\n}\nexport function assertQualifiedTypeIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.QualifiedTypeIdentifier {\n  assert(\"QualifiedTypeIdentifier\", node, opts);\n}\nexport function assertStringLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringLiteralTypeAnnotation {\n  assert(\"StringLiteralTypeAnnotation\", node, opts);\n}\nexport function assertStringTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.StringTypeAnnotation {\n  assert(\"StringTypeAnnotation\", node, opts);\n}\nexport function assertSymbolTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.SymbolTypeAnnotation {\n  assert(\"SymbolTypeAnnotation\", node, opts);\n}\nexport function assertThisTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ThisTypeAnnotation {\n  assert(\"ThisTypeAnnotation\", node, opts);\n}\nexport function assertTupleTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TupleTypeAnnotation {\n  assert(\"TupleTypeAnnotation\", node, opts);\n}\nexport function assertTypeofTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeofTypeAnnotation {\n  assert(\"TypeofTypeAnnotation\", node, opts);\n}\nexport function assertTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeAlias {\n  assert(\"TypeAlias\", node, opts);\n}\nexport function assertTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeAnnotation {\n  assert(\"TypeAnnotation\", node, opts);\n}\nexport function assertTypeCastExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeCastExpression {\n  assert(\"TypeCastExpression\", node, opts);\n}\nexport function assertTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameter {\n  assert(\"TypeParameter\", node, opts);\n}\nexport function assertTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameterDeclaration {\n  assert(\"TypeParameterDeclaration\", node, opts);\n}\nexport function assertTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeParameterInstantiation {\n  assert(\"TypeParameterInstantiation\", node, opts);\n}\nexport function assertUnionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnionTypeAnnotation {\n  assert(\"UnionTypeAnnotation\", node, opts);\n}\nexport function assertVariance(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Variance {\n  assert(\"Variance\", node, opts);\n}\nexport function assertVoidTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VoidTypeAnnotation {\n  assert(\"VoidTypeAnnotation\", node, opts);\n}\nexport function assertEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumDeclaration {\n  assert(\"EnumDeclaration\", node, opts);\n}\nexport function assertEnumBooleanBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBooleanBody {\n  assert(\"EnumBooleanBody\", node, opts);\n}\nexport function assertEnumNumberBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumNumberBody {\n  assert(\"EnumNumberBody\", node, opts);\n}\nexport function assertEnumStringBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumStringBody {\n  assert(\"EnumStringBody\", node, opts);\n}\nexport function assertEnumSymbolBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumSymbolBody {\n  assert(\"EnumSymbolBody\", node, opts);\n}\nexport function assertEnumBooleanMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBooleanMember {\n  assert(\"EnumBooleanMember\", node, opts);\n}\nexport function assertEnumNumberMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumNumberMember {\n  assert(\"EnumNumberMember\", node, opts);\n}\nexport function assertEnumStringMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumStringMember {\n  assert(\"EnumStringMember\", node, opts);\n}\nexport function assertEnumDefaultedMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumDefaultedMember {\n  assert(\"EnumDefaultedMember\", node, opts);\n}\nexport function assertIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.IndexedAccessType {\n  assert(\"IndexedAccessType\", node, opts);\n}\nexport function assertOptionalIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.OptionalIndexedAccessType {\n  assert(\"OptionalIndexedAccessType\", node, opts);\n}\nexport function assertJSXAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXAttribute {\n  assert(\"JSXAttribute\", node, opts);\n}\nexport function assertJSXClosingElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXClosingElement {\n  assert(\"JSXClosingElement\", node, opts);\n}\nexport function assertJSXElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXElement {\n  assert(\"JSXElement\", node, opts);\n}\nexport function assertJSXEmptyExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXEmptyExpression {\n  assert(\"JSXEmptyExpression\", node, opts);\n}\nexport function assertJSXExpressionContainer(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXExpressionContainer {\n  assert(\"JSXExpressionContainer\", node, opts);\n}\nexport function assertJSXSpreadChild(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXSpreadChild {\n  assert(\"JSXSpreadChild\", node, opts);\n}\nexport function assertJSXIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXIdentifier {\n  assert(\"JSXIdentifier\", node, opts);\n}\nexport function assertJSXMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXMemberExpression {\n  assert(\"JSXMemberExpression\", node, opts);\n}\nexport function assertJSXNamespacedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXNamespacedName {\n  assert(\"JSXNamespacedName\", node, opts);\n}\nexport function assertJSXOpeningElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXOpeningElement {\n  assert(\"JSXOpeningElement\", node, opts);\n}\nexport function assertJSXSpreadAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXSpreadAttribute {\n  assert(\"JSXSpreadAttribute\", node, opts);\n}\nexport function assertJSXText(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXText {\n  assert(\"JSXText\", node, opts);\n}\nexport function assertJSXFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXFragment {\n  assert(\"JSXFragment\", node, opts);\n}\nexport function assertJSXOpeningFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXOpeningFragment {\n  assert(\"JSXOpeningFragment\", node, opts);\n}\nexport function assertJSXClosingFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSXClosingFragment {\n  assert(\"JSXClosingFragment\", node, opts);\n}\nexport function assertPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Placeholder {\n  assert(\"Placeholder\", node, opts);\n}\nexport function assertV8IntrinsicIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.V8IntrinsicIdentifier {\n  assert(\"V8IntrinsicIdentifier\", node, opts);\n}\nexport function assertArgumentPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ArgumentPlaceholder {\n  assert(\"ArgumentPlaceholder\", node, opts);\n}\nexport function assertBindExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BindExpression {\n  assert(\"BindExpression\", node, opts);\n}\nexport function assertDecorator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Decorator {\n  assert(\"Decorator\", node, opts);\n}\nexport function assertDoExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.DoExpression {\n  assert(\"DoExpression\", node, opts);\n}\nexport function assertExportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDefaultSpecifier {\n  assert(\"ExportDefaultSpecifier\", node, opts);\n}\nexport function assertModuleExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ModuleExpression {\n  assert(\"ModuleExpression\", node, opts);\n}\nexport function assertTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TopicReference {\n  assert(\"TopicReference\", node, opts);\n}\nexport function assertPipelineTopicExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PipelineTopicExpression {\n  assert(\"PipelineTopicExpression\", node, opts);\n}\nexport function assertPipelineBareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PipelineBareFunction {\n  assert(\"PipelineBareFunction\", node, opts);\n}\nexport function assertPipelinePrimaryTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PipelinePrimaryTopicReference {\n  assert(\"PipelinePrimaryTopicReference\", node, opts);\n}\nexport function assertVoidPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.VoidPattern {\n  assert(\"VoidPattern\", node, opts);\n}\nexport function assertTSParameterProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSParameterProperty {\n  assert(\"TSParameterProperty\", node, opts);\n}\nexport function assertTSDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSDeclareFunction {\n  assert(\"TSDeclareFunction\", node, opts);\n}\nexport function assertTSDeclareMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSDeclareMethod {\n  assert(\"TSDeclareMethod\", node, opts);\n}\nexport function assertTSQualifiedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSQualifiedName {\n  assert(\"TSQualifiedName\", node, opts);\n}\nexport function assertTSCallSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSCallSignatureDeclaration {\n  assert(\"TSCallSignatureDeclaration\", node, opts);\n}\nexport function assertTSConstructSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConstructSignatureDeclaration {\n  assert(\"TSConstructSignatureDeclaration\", node, opts);\n}\nexport function assertTSPropertySignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSPropertySignature {\n  assert(\"TSPropertySignature\", node, opts);\n}\nexport function assertTSMethodSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSMethodSignature {\n  assert(\"TSMethodSignature\", node, opts);\n}\nexport function assertTSIndexSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIndexSignature {\n  assert(\"TSIndexSignature\", node, opts);\n}\nexport function assertTSAnyKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSAnyKeyword {\n  assert(\"TSAnyKeyword\", node, opts);\n}\nexport function assertTSBooleanKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBooleanKeyword {\n  assert(\"TSBooleanKeyword\", node, opts);\n}\nexport function assertTSBigIntKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBigIntKeyword {\n  assert(\"TSBigIntKeyword\", node, opts);\n}\nexport function assertTSIntrinsicKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIntrinsicKeyword {\n  assert(\"TSIntrinsicKeyword\", node, opts);\n}\nexport function assertTSNeverKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNeverKeyword {\n  assert(\"TSNeverKeyword\", node, opts);\n}\nexport function assertTSNullKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNullKeyword {\n  assert(\"TSNullKeyword\", node, opts);\n}\nexport function assertTSNumberKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNumberKeyword {\n  assert(\"TSNumberKeyword\", node, opts);\n}\nexport function assertTSObjectKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSObjectKeyword {\n  assert(\"TSObjectKeyword\", node, opts);\n}\nexport function assertTSStringKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSStringKeyword {\n  assert(\"TSStringKeyword\", node, opts);\n}\nexport function assertTSSymbolKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSSymbolKeyword {\n  assert(\"TSSymbolKeyword\", node, opts);\n}\nexport function assertTSUndefinedKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUndefinedKeyword {\n  assert(\"TSUndefinedKeyword\", node, opts);\n}\nexport function assertTSUnknownKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUnknownKeyword {\n  assert(\"TSUnknownKeyword\", node, opts);\n}\nexport function assertTSVoidKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSVoidKeyword {\n  assert(\"TSVoidKeyword\", node, opts);\n}\nexport function assertTSThisType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSThisType {\n  assert(\"TSThisType\", node, opts);\n}\nexport function assertTSFunctionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSFunctionType {\n  assert(\"TSFunctionType\", node, opts);\n}\nexport function assertTSConstructorType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConstructorType {\n  assert(\"TSConstructorType\", node, opts);\n}\nexport function assertTSTypeReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeReference {\n  assert(\"TSTypeReference\", node, opts);\n}\nexport function assertTSTypePredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypePredicate {\n  assert(\"TSTypePredicate\", node, opts);\n}\nexport function assertTSTypeQuery(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeQuery {\n  assert(\"TSTypeQuery\", node, opts);\n}\nexport function assertTSTypeLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeLiteral {\n  assert(\"TSTypeLiteral\", node, opts);\n}\nexport function assertTSArrayType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSArrayType {\n  assert(\"TSArrayType\", node, opts);\n}\nexport function assertTSTupleType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTupleType {\n  assert(\"TSTupleType\", node, opts);\n}\nexport function assertTSOptionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSOptionalType {\n  assert(\"TSOptionalType\", node, opts);\n}\nexport function assertTSRestType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSRestType {\n  assert(\"TSRestType\", node, opts);\n}\nexport function assertTSNamedTupleMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNamedTupleMember {\n  assert(\"TSNamedTupleMember\", node, opts);\n}\nexport function assertTSUnionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSUnionType {\n  assert(\"TSUnionType\", node, opts);\n}\nexport function assertTSIntersectionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIntersectionType {\n  assert(\"TSIntersectionType\", node, opts);\n}\nexport function assertTSConditionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSConditionalType {\n  assert(\"TSConditionalType\", node, opts);\n}\nexport function assertTSInferType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInferType {\n  assert(\"TSInferType\", node, opts);\n}\nexport function assertTSParenthesizedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSParenthesizedType {\n  assert(\"TSParenthesizedType\", node, opts);\n}\nexport function assertTSTypeOperator(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeOperator {\n  assert(\"TSTypeOperator\", node, opts);\n}\nexport function assertTSIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSIndexedAccessType {\n  assert(\"TSIndexedAccessType\", node, opts);\n}\nexport function assertTSMappedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSMappedType {\n  assert(\"TSMappedType\", node, opts);\n}\nexport function assertTSTemplateLiteralType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTemplateLiteralType {\n  assert(\"TSTemplateLiteralType\", node, opts);\n}\nexport function assertTSLiteralType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSLiteralType {\n  assert(\"TSLiteralType\", node, opts);\n}\nexport function assertTSClassImplements(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSClassImplements {\n  assert(\"TSClassImplements\", node, opts);\n}\nexport function assertTSInterfaceHeritage(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInterfaceHeritage {\n  assert(\"TSInterfaceHeritage\", node, opts);\n}\nexport function assertTSInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInterfaceDeclaration {\n  assert(\"TSInterfaceDeclaration\", node, opts);\n}\nexport function assertTSInterfaceBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInterfaceBody {\n  assert(\"TSInterfaceBody\", node, opts);\n}\nexport function assertTSTypeAliasDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAliasDeclaration {\n  assert(\"TSTypeAliasDeclaration\", node, opts);\n}\nexport function assertTSInstantiationExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSInstantiationExpression {\n  assert(\"TSInstantiationExpression\", node, opts);\n}\nexport function assertTSAsExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSAsExpression {\n  assert(\"TSAsExpression\", node, opts);\n}\nexport function assertTSSatisfiesExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSSatisfiesExpression {\n  assert(\"TSSatisfiesExpression\", node, opts);\n}\nexport function assertTSTypeAssertion(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAssertion {\n  assert(\"TSTypeAssertion\", node, opts);\n}\nexport function assertTSEnumBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEnumBody {\n  assert(\"TSEnumBody\", node, opts);\n}\nexport function assertTSEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEnumDeclaration {\n  assert(\"TSEnumDeclaration\", node, opts);\n}\nexport function assertTSEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEnumMember {\n  assert(\"TSEnumMember\", node, opts);\n}\nexport function assertTSModuleDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSModuleDeclaration {\n  assert(\"TSModuleDeclaration\", node, opts);\n}\nexport function assertTSModuleBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSModuleBlock {\n  assert(\"TSModuleBlock\", node, opts);\n}\nexport function assertTSImportType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSImportType {\n  assert(\"TSImportType\", node, opts);\n}\nexport function assertTSImportEqualsDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSImportEqualsDeclaration {\n  assert(\"TSImportEqualsDeclaration\", node, opts);\n}\nexport function assertTSExternalModuleReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSExternalModuleReference {\n  assert(\"TSExternalModuleReference\", node, opts);\n}\nexport function assertTSNonNullExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNonNullExpression {\n  assert(\"TSNonNullExpression\", node, opts);\n}\nexport function assertTSExportAssignment(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSExportAssignment {\n  assert(\"TSExportAssignment\", node, opts);\n}\nexport function assertTSNamespaceExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSNamespaceExportDeclaration {\n  assert(\"TSNamespaceExportDeclaration\", node, opts);\n}\nexport function assertTSTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeAnnotation {\n  assert(\"TSTypeAnnotation\", node, opts);\n}\nexport function assertTSTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameterInstantiation {\n  assert(\"TSTypeParameterInstantiation\", node, opts);\n}\nexport function assertTSTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameterDeclaration {\n  assert(\"TSTypeParameterDeclaration\", node, opts);\n}\nexport function assertTSTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeParameter {\n  assert(\"TSTypeParameter\", node, opts);\n}\nexport function assertStandardized(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Standardized {\n  assert(\"Standardized\", node, opts);\n}\nexport function assertExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Expression {\n  assert(\"Expression\", node, opts);\n}\nexport function assertBinary(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Binary {\n  assert(\"Binary\", node, opts);\n}\nexport function assertScopable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Scopable {\n  assert(\"Scopable\", node, opts);\n}\nexport function assertBlockParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.BlockParent {\n  assert(\"BlockParent\", node, opts);\n}\nexport function assertBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Block {\n  assert(\"Block\", node, opts);\n}\nexport function assertStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Statement {\n  assert(\"Statement\", node, opts);\n}\nexport function assertTerminatorless(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Terminatorless {\n  assert(\"Terminatorless\", node, opts);\n}\nexport function assertCompletionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.CompletionStatement {\n  assert(\"CompletionStatement\", node, opts);\n}\nexport function assertConditional(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Conditional {\n  assert(\"Conditional\", node, opts);\n}\nexport function assertLoop(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Loop {\n  assert(\"Loop\", node, opts);\n}\nexport function assertWhile(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.While {\n  assert(\"While\", node, opts);\n}\nexport function assertExpressionWrapper(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExpressionWrapper {\n  assert(\"ExpressionWrapper\", node, opts);\n}\nexport function assertFor(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.For {\n  assert(\"For\", node, opts);\n}\nexport function assertForXStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ForXStatement {\n  assert(\"ForXStatement\", node, opts);\n}\nexport function assertFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Function {\n  assert(\"Function\", node, opts);\n}\nexport function assertFunctionParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionParent {\n  assert(\"FunctionParent\", node, opts);\n}\nexport function assertPureish(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Pureish {\n  assert(\"Pureish\", node, opts);\n}\nexport function assertDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Declaration {\n  assert(\"Declaration\", node, opts);\n}\nexport function assertFunctionParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FunctionParameter {\n  assert(\"FunctionParameter\", node, opts);\n}\nexport function assertPatternLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.PatternLike {\n  assert(\"PatternLike\", node, opts);\n}\nexport function assertLVal(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.LVal {\n  assert(\"LVal\", node, opts);\n}\nexport function assertTSEntityName(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSEntityName {\n  assert(\"TSEntityName\", node, opts);\n}\nexport function assertLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Literal {\n  assert(\"Literal\", node, opts);\n}\nexport function assertImmutable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Immutable {\n  assert(\"Immutable\", node, opts);\n}\nexport function assertUserWhitespacable(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UserWhitespacable {\n  assert(\"UserWhitespacable\", node, opts);\n}\nexport function assertMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Method {\n  assert(\"Method\", node, opts);\n}\nexport function assertObjectMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ObjectMember {\n  assert(\"ObjectMember\", node, opts);\n}\nexport function assertProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Property {\n  assert(\"Property\", node, opts);\n}\nexport function assertUnaryLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.UnaryLike {\n  assert(\"UnaryLike\", node, opts);\n}\nexport function assertPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Pattern {\n  assert(\"Pattern\", node, opts);\n}\nexport function assertClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Class {\n  assert(\"Class\", node, opts);\n}\nexport function assertImportOrExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ImportOrExportDeclaration {\n  assert(\"ImportOrExportDeclaration\", node, opts);\n}\nexport function assertExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ExportDeclaration {\n  assert(\"ExportDeclaration\", node, opts);\n}\nexport function assertModuleSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.ModuleSpecifier {\n  assert(\"ModuleSpecifier\", node, opts);\n}\nexport function assertAccessor(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Accessor {\n  assert(\"Accessor\", node, opts);\n}\nexport function assertPrivate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Private {\n  assert(\"Private\", node, opts);\n}\nexport function assertFlow(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Flow {\n  assert(\"Flow\", node, opts);\n}\nexport function assertFlowType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowType {\n  assert(\"FlowType\", node, opts);\n}\nexport function assertFlowBaseAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowBaseAnnotation {\n  assert(\"FlowBaseAnnotation\", node, opts);\n}\nexport function assertFlowDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowDeclaration {\n  assert(\"FlowDeclaration\", node, opts);\n}\nexport function assertFlowPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.FlowPredicate {\n  assert(\"FlowPredicate\", node, opts);\n}\nexport function assertEnumBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumBody {\n  assert(\"EnumBody\", node, opts);\n}\nexport function assertEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.EnumMember {\n  assert(\"EnumMember\", node, opts);\n}\nexport function assertJSX(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.JSX {\n  assert(\"JSX\", node, opts);\n}\nexport function assertMiscellaneous(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.Miscellaneous {\n  assert(\"Miscellaneous\", node, opts);\n}\nexport function assertTypeScript(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TypeScript {\n  assert(\"TypeScript\", node, opts);\n}\nexport function assertTSTypeElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSTypeElement {\n  assert(\"TSTypeElement\", node, opts);\n}\nexport function assertTSType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSType {\n  assert(\"TSType\", node, opts);\n}\nexport function assertTSBaseType(\n  node: object | null | undefined,\n  opts?: object | null,\n): asserts node is t.TSBaseType {\n  assert(\"TSBaseType\", node, opts);\n}\nexport function assertNumberLiteral(node: any, opts: any): void {\n  deprecationWarning(\"assertNumberLiteral\", \"assertNumericLiteral\");\n  assert(\"NumberLiteral\", node, opts);\n}\nexport function assertRegexLiteral(node: any, opts: any): void {\n  deprecationWarning(\"assertRegexLiteral\", \"assertRegExpLiteral\");\n  assert(\"RegexLiteral\", node, opts);\n}\nexport function assertRestProperty(node: any, opts: any): void {\n  deprecationWarning(\"assertRestProperty\", \"assertRestElement\");\n  assert(\"RestProperty\", node, opts);\n}\nexport function assertSpreadProperty(node: any, opts: any): void {\n  deprecationWarning(\"assertSpreadProperty\", \"assertSpreadElement\");\n  assert(\"SpreadProperty\", node, opts);\n}\nexport function assertModuleDeclaration(node: any, opts: any): void {\n  deprecationWarning(\n    \"assertModuleDeclaration\",\n    \"assertImportOrExportDeclaration\",\n  );\n  assert(\"ModuleDeclaration\", node, opts);\n}\n","import {\n  anyTypeAnnotation,\n  stringTypeAnnotation,\n  numberTypeAnnotation,\n  voidTypeAnnotation,\n  booleanTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n} from \"../generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nexport default createTypeAnnotationBasedOnTypeof as {\n  (type: \"string\"): t.StringTypeAnnotation;\n  (type: \"number\"): t.NumberTypeAnnotation;\n  (type: \"undefined\"): t.VoidTypeAnnotation;\n  (type: \"boolean\"): t.BooleanTypeAnnotation;\n  (type: \"function\"): t.GenericTypeAnnotation;\n  (type: \"object\"): t.GenericTypeAnnotation;\n  (type: \"symbol\"): t.GenericTypeAnnotation;\n  (type: \"bigint\"): t.AnyTypeAnnotation;\n};\n\n/**\n * Create a type annotation based on typeof expression.\n */\nfunction createTypeAnnotationBasedOnTypeof(type: string): t.FlowType {\n  switch (type) {\n    case \"string\":\n      return stringTypeAnnotation();\n    case \"number\":\n      return numberTypeAnnotation();\n    case \"undefined\":\n      return voidTypeAnnotation();\n    case \"boolean\":\n      return booleanTypeAnnotation();\n    case \"function\":\n      return genericTypeAnnotation(identifier(\"Function\"));\n    case \"object\":\n      return genericTypeAnnotation(identifier(\"Object\"));\n    case \"symbol\":\n      return genericTypeAnnotation(identifier(\"Symbol\"));\n    case \"bigint\":\n      // todo: use BigInt annotation when Flow supports BigInt\n      // https://github.com/facebook/flow/issues/6639\n      return anyTypeAnnotation();\n  }\n  throw new Error(\"Invalid typeof value: \" + type);\n}\n","import {\n  isAnyTypeAnnotation,\n  isGenericTypeAnnotation,\n  isUnionTypeAnnotation,\n  isFlowBaseAnnotation,\n  isIdentifier,\n} from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nfunction getQualifiedName(node: t.GenericTypeAnnotation[\"id\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : `${node.id.name}.${getQualifiedName(node.qualification)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodesIn: readonly (t.FlowType | false | null | undefined)[],\n): t.FlowType[] {\n  const nodes = Array.from(nodesIn);\n\n  const generics = new Map<string, t.GenericTypeAnnotation>();\n  const bases = new Map<t.FlowBaseAnnotation[\"type\"], t.FlowBaseAnnotation>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.FlowType[]>();\n\n  const types: t.FlowType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.includes(node)) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    if (isFlowBaseAnnotation(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isUnionTypeAnnotation(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (isGenericTypeAnnotation(node)) {\n      const name = getQualifiedName(node.id);\n\n      if (generics.has(name)) {\n        let existing: t.Flow = generics.get(name);\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params.push(...node.typeParameters.params);\n            existing.typeParameters.params = removeTypeDuplicates(\n              existing.typeParameters.params,\n            );\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n","import { unionTypeAnnotation } from \"../generated/index.ts\";\nimport removeTypeDuplicates from \"../../modifications/flow/removeTypeDuplicates.ts\";\nimport type * as t from \"../../index.ts\";\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containing them.\n */\nexport default function createFlowUnionType<T extends t.FlowType>(\n  types: [T] | T[],\n): T | t.UnionTypeAnnotation {\n  const flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0] as T;\n  } else {\n    return unionTypeAnnotation(flattened);\n  }\n}\n","import {\n  isIdentifier,\n  isThisExpression,\n  isTSAnyKeyword,\n  isTSTypeReference,\n  isTSUnionType,\n  isTSBaseType,\n} from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\nfunction getQualifiedName(node: t.TSTypeReference[\"typeName\"]): string {\n  return isIdentifier(node)\n    ? node.name\n    : isThisExpression(node)\n      ? \"this\"\n      : `${node.right.name}.${getQualifiedName(node.left)}`;\n}\n\n/**\n * Dedupe type annotations.\n */\nexport default function removeTypeDuplicates(\n  nodesIn: readonly t.TSType[],\n): t.TSType[] {\n  const nodes = Array.from(nodesIn);\n\n  const generics = new Map<string, t.TSTypeReference>();\n  const bases = new Map<t.TSBaseType[\"type\"], t.TSBaseType>();\n\n  // store union type groups to circular references\n  const typeGroups = new Set<t.TSType[]>();\n\n  const types: t.TSType[] = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.includes(node)) {\n      continue;\n    }\n\n    // this type matches anything\n    if (isTSAnyKeyword(node)) {\n      return [node];\n    }\n\n    // Analogue of FlowBaseAnnotation\n    if (isTSBaseType(node)) {\n      bases.set(node.type, node);\n      continue;\n    }\n\n    if (isTSUnionType(node)) {\n      if (!typeGroups.has(node.types)) {\n        nodes.push(...node.types);\n        typeGroups.add(node.types);\n      }\n      continue;\n    }\n\n    // todo: support merging tuples: number[]\n    const typeArgumentsKey = \"typeArguments\";\n    if (isTSTypeReference(node) && node[typeArgumentsKey]) {\n      const typeArguments = node[typeArgumentsKey];\n      const name = getQualifiedName(node.typeName);\n\n      if (generics.has(name)) {\n        let existing: t.TypeScript = generics.get(name);\n\n        const existingTypeArguments = existing[typeArgumentsKey];\n        if (existingTypeArguments) {\n          existingTypeArguments.params.push(...typeArguments.params);\n          existingTypeArguments.params = removeTypeDuplicates(\n            existingTypeArguments.params,\n          );\n        } else {\n          existing = typeArguments;\n        }\n      } else {\n        generics.set(name, node);\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (const [, baseType] of bases) {\n    types.push(baseType);\n  }\n\n  // add back in generics\n  for (const [, genericName] of generics) {\n    types.push(genericName);\n  }\n\n  return types;\n}\n","import { tsUnionType } from \"../generated/index.ts\";\nimport removeTypeDuplicates from \"../../modifications/typescript/removeTypeDuplicates.ts\";\nimport { isTSTypeAnnotation } from \"../../validators/generated/index.ts\";\nimport type * as t from \"../../index.ts\";\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containing them.\n */\nexport default function createTSUnionType(\n  typeAnnotations: (t.TSTypeAnnotation | t.TSType)[],\n): t.TSType {\n  const types = typeAnnotations.map(type => {\n    return isTSTypeAnnotation(type) ? type.typeAnnotation : type;\n  });\n  const flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return tsUnionType(flattened);\n  }\n}\n","import { numericLiteral, unaryExpression } from \"./generated/index.ts\";\n\nexport function buildUndefinedNode() {\n  return unaryExpression(\"void\", numericLiteral(0), true);\n}\n","import { NODE_FIELDS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\nimport { isFile, isIdentifier } from \"../validators/generated/index.ts\";\n\nconst { hasOwn } = Object;\ntype CommentCache = Map<t.Comment, t.Comment>;\n\n// This function will never be called for comments, only for real nodes.\nfunction cloneIfNode(\n  obj: t.Node | undefined | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (obj && typeof obj.type === \"string\") {\n    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);\n  }\n\n  return obj;\n}\n\nfunction cloneIfNodeOrArray(\n  obj: t.Node | undefined | null | (t.Node | undefined | null)[],\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: CommentCache,\n) {\n  if (Array.isArray(obj)) {\n    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));\n  }\n  return cloneIfNode(obj, deep, withoutLoc, commentsCache);\n}\n\n/**\n * Create a clone of a `node` including only properties belonging to the node.\n * If the second parameter is `false`, cloneNode performs a shallow clone.\n * If the third parameter is true, the cloned nodes exclude location properties.\n */\nexport default function cloneNode<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n): T {\n  return cloneNodeInternal(node, deep, withoutLoc, new Map());\n}\n\nfunction cloneNodeInternal<T extends t.Node>(\n  node: T,\n  deep: boolean = true,\n  withoutLoc: boolean = false,\n  commentsCache: CommentCache,\n): T {\n  if (!node) return node;\n\n  const { type } = node;\n  const newNode: any = { type: node.type };\n\n  // Special-case identifiers since they are the most cloned nodes.\n  if (isIdentifier(node)) {\n    newNode.name = node.name;\n\n    if (hasOwn(node, \"optional\") && typeof node.optional === \"boolean\") {\n      newNode.optional = node.optional;\n    }\n\n    if (hasOwn(node, \"typeAnnotation\")) {\n      newNode.typeAnnotation = deep\n        ? cloneIfNodeOrArray(\n            node.typeAnnotation,\n            true,\n            withoutLoc,\n            commentsCache,\n          )\n        : node.typeAnnotation;\n    }\n\n    if (hasOwn(node, \"decorators\")) {\n      newNode.decorators = deep\n        ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache)\n        : node.decorators;\n    }\n  } else if (!hasOwn(NODE_FIELDS, type)) {\n    throw new Error(`Unknown node type: \"${type}\"`);\n  } else {\n    for (const field of Object.keys(NODE_FIELDS[type])) {\n      if (hasOwn(node, field)) {\n        if (deep) {\n          newNode[field] =\n            isFile(node) && field === \"comments\"\n              ? maybeCloneComments(\n                  node.comments,\n                  deep,\n                  withoutLoc,\n                  commentsCache,\n                )\n              : cloneIfNodeOrArray(\n                  // @ts-expect-error node[field] has been guarded by has check\n                  node[field],\n                  true,\n                  withoutLoc,\n                  commentsCache,\n                );\n        } else {\n          newNode[field] =\n            // @ts-expect-error node[field] has been guarded by has check\n            node[field];\n        }\n      }\n    }\n  }\n\n  if (hasOwn(node, \"loc\")) {\n    if (withoutLoc) {\n      newNode.loc = null;\n    } else {\n      newNode.loc = node.loc;\n    }\n  }\n  if (hasOwn(node, \"leadingComments\")) {\n    newNode.leadingComments = maybeCloneComments(\n      node.leadingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"innerComments\")) {\n    newNode.innerComments = maybeCloneComments(\n      node.innerComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"trailingComments\")) {\n    newNode.trailingComments = maybeCloneComments(\n      node.trailingComments,\n      deep,\n      withoutLoc,\n      commentsCache,\n    );\n  }\n  if (hasOwn(node, \"extra\")) {\n    newNode.extra = {\n      ...node.extra,\n    };\n  }\n\n  return newNode;\n}\n\nfunction maybeCloneComments<T extends t.Comment>(\n  comments: readonly T[] | null,\n  deep: boolean,\n  withoutLoc: boolean,\n  commentsCache: Map<T, T>,\n): readonly T[] | null {\n  if (!comments || !deep) {\n    return comments;\n  }\n  return comments.map(comment => {\n    const cache = commentsCache.get(comment);\n    if (cache) return cache;\n\n    const { type, value, loc } = comment;\n\n    const ret = { type, value, loc } as T;\n    if (withoutLoc) {\n      ret.loc = null;\n    }\n\n    commentsCache.set(comment, ret);\n\n    return ret;\n  });\n}\n","import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a shallow clone of a `node`, including only\n * properties belonging to the node.\n * @deprecated Use t.cloneNode instead.\n */\nexport default function clone<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ false);\n}\n","import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a deep clone of a `node` and all of it's child nodes\n * including only properties belonging to the node.\n * @deprecated Use t.cloneNode instead.\n */\nexport default function cloneDeep<T extends t.Node>(node: T): T {\n  return cloneNode(node);\n}\n","import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n/**\n * Create a deep clone of a `node` and all of it's child nodes\n * including only properties belonging to the node.\n * excluding `_private` and location properties.\n */\nexport default function cloneDeepWithoutLoc<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ true, /* withoutLoc */ true);\n}\n","import cloneNode from \"./cloneNode.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Create a shallow clone of a `node` excluding `_private` and location properties.\n */\nexport default function cloneWithoutLoc<T extends t.Node>(node: T): T {\n  return cloneNode(node, /* deep */ false, /* withoutLoc */ true);\n}\n","import type * as t from \"../index.ts\";\n\n/**\n * Add comments of certain type to a node.\n */\nexport default function addComments<T extends t.Node>(\n  node: T,\n  type: t.CommentTypeShorthand,\n  comments: t.Comment[],\n): T {\n  if (!comments || !node) return node;\n\n  const key = `${type}Comments` as const;\n\n  if (node[key]) {\n    if (type === \"leading\") {\n      node[key] = comments.concat(node[key]);\n    } else {\n      node[key].push(...comments);\n    }\n  } else {\n    node[key] = comments;\n  }\n\n  return node;\n}\n","import addComments from \"./addComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Add comment of certain type to a node.\n */\nexport default function addComment<T extends t.Node>(\n  node: T,\n  type: t.CommentTypeShorthand,\n  content: string,\n  line?: boolean,\n): T {\n  return addComments(node, type, [\n    {\n      type: line ? \"CommentLine\" : \"CommentBlock\",\n      value: content,\n    } as t.Comment,\n  ]);\n}\n","import type * as t from \"../index.ts\";\n\nexport default function inherit<\n  C extends t.Node | undefined,\n  P extends t.Node | undefined,\n>(key: keyof C & keyof P, child: C, parent: P): void {\n  if (child && parent) {\n    // @ts-expect-error Could further refine key definitions\n    child[key] = Array.from(\n      new Set([].concat(child[key], parent[key]).filter(Boolean)),\n    );\n  }\n}\n","import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritInnerComments(\n  child: t.Node,\n  parent: t.Node,\n): void {\n  inherit(\"innerComments\", child, parent);\n}\n","import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritLeadingComments(\n  child: t.Node,\n  parent: t.Node,\n): void {\n  inherit(\"leadingComments\", child, parent);\n}\n","import inherit from \"../utils/inherit.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function inheritTrailingComments(\n  child: t.Node,\n  parent: t.Node,\n): void {\n  inherit(\"trailingComments\", child, parent);\n}\n","import inheritTrailingComments from \"./inheritTrailingComments.ts\";\nimport inheritLeadingComments from \"./inheritLeadingComments.ts\";\nimport inheritInnerComments from \"./inheritInnerComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Inherit all unique comments from `parent` node to `child` node.\n */\nexport default function inheritsComments<T extends t.Node>(\n  child: T,\n  parent: t.Node,\n): T {\n  inheritTrailingComments(child, parent);\n  inheritLeadingComments(child, parent);\n  inheritInnerComments(child, parent);\n\n  return child;\n}\n","import { COMMENT_KEYS } from \"../constants/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Remove comment properties from a node.\n */\nexport default function removeComments<T extends t.Node>(node: T): T {\n  COMMENT_KEYS.forEach(key => {\n    node[key] = null;\n  });\n\n  return node;\n}\n","/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport { FLIPPED_ALIAS_KEYS } from \"../../definitions/index.ts\";\n\nexport const STANDARDIZED_TYPES = FLIPPED_ALIAS_KEYS[\"Standardized\"];\nexport const EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS[\"Expression\"];\nexport const BINARY_TYPES = FLIPPED_ALIAS_KEYS[\"Binary\"];\nexport const SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS[\"Scopable\"];\nexport const BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS[\"BlockParent\"];\nexport const BLOCK_TYPES = FLIPPED_ALIAS_KEYS[\"Block\"];\nexport const STATEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"Statement\"];\nexport const TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS[\"Terminatorless\"];\nexport const COMPLETIONSTATEMENT_TYPES =\n  FLIPPED_ALIAS_KEYS[\"CompletionStatement\"];\nexport const CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS[\"Conditional\"];\nexport const LOOP_TYPES = FLIPPED_ALIAS_KEYS[\"Loop\"];\nexport const WHILE_TYPES = FLIPPED_ALIAS_KEYS[\"While\"];\nexport const EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS[\"ExpressionWrapper\"];\nexport const FOR_TYPES = FLIPPED_ALIAS_KEYS[\"For\"];\nexport const FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"ForXStatement\"];\nexport const FUNCTION_TYPES = FLIPPED_ALIAS_KEYS[\"Function\"];\nexport const FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS[\"FunctionParent\"];\nexport const PUREISH_TYPES = FLIPPED_ALIAS_KEYS[\"Pureish\"];\nexport const DECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"Declaration\"];\nexport const FUNCTIONPARAMETER_TYPES = FLIPPED_ALIAS_KEYS[\"FunctionParameter\"];\nexport const PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS[\"PatternLike\"];\nexport const LVAL_TYPES = FLIPPED_ALIAS_KEYS[\"LVal\"];\nexport const TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS[\"TSEntityName\"];\nexport const LITERAL_TYPES = FLIPPED_ALIAS_KEYS[\"Literal\"];\nexport const IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS[\"Immutable\"];\nexport const USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS[\"UserWhitespacable\"];\nexport const METHOD_TYPES = FLIPPED_ALIAS_KEYS[\"Method\"];\nexport const OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS[\"ObjectMember\"];\nexport const PROPERTY_TYPES = FLIPPED_ALIAS_KEYS[\"Property\"];\nexport const UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS[\"UnaryLike\"];\nexport const PATTERN_TYPES = FLIPPED_ALIAS_KEYS[\"Pattern\"];\nexport const CLASS_TYPES = FLIPPED_ALIAS_KEYS[\"Class\"];\nexport const IMPORTOREXPORTDECLARATION_TYPES =\n  FLIPPED_ALIAS_KEYS[\"ImportOrExportDeclaration\"];\nexport const EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"ExportDeclaration\"];\nexport const MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS[\"ModuleSpecifier\"];\nexport const ACCESSOR_TYPES = FLIPPED_ALIAS_KEYS[\"Accessor\"];\nexport const PRIVATE_TYPES = FLIPPED_ALIAS_KEYS[\"Private\"];\nexport const FLOW_TYPES = FLIPPED_ALIAS_KEYS[\"Flow\"];\nexport const FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS[\"FlowType\"];\nexport const FLOWBASEANNOTATION_TYPES =\n  FLIPPED_ALIAS_KEYS[\"FlowBaseAnnotation\"];\nexport const FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS[\"FlowDeclaration\"];\nexport const FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS[\"FlowPredicate\"];\nexport const ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS[\"EnumBody\"];\nexport const ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS[\"EnumMember\"];\nexport const JSX_TYPES = FLIPPED_ALIAS_KEYS[\"JSX\"];\nexport const MISCELLANEOUS_TYPES = FLIPPED_ALIAS_KEYS[\"Miscellaneous\"];\nexport const TYPESCRIPT_TYPES = FLIPPED_ALIAS_KEYS[\"TypeScript\"];\nexport const TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS[\"TSTypeElement\"];\nexport const TSTYPE_TYPES = FLIPPED_ALIAS_KEYS[\"TSType\"];\nexport const TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS[\"TSBaseType\"];\n/**\n * @deprecated migrate to IMPORTOREXPORTDECLARATION_TYPES.\n */\nexport const MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;\n","import {\n  isBlockStatement,\n  isFunction,\n  isEmptyStatement,\n  isStatement,\n} from \"../validators/generated/index.ts\";\nimport {\n  returnStatement,\n  expressionStatement,\n  blockStatement,\n} from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toBlock(\n  node: t.Statement | t.Expression,\n  parent?: t.Node,\n): t.BlockStatement {\n  if (isBlockStatement(node)) {\n    return node;\n  }\n\n  let blockNodes: t.Statement[] = [];\n\n  if (isEmptyStatement(node)) {\n    blockNodes = [];\n  } else {\n    if (!isStatement(node)) {\n      if (isFunction(parent)) {\n        node = returnStatement(node);\n      } else {\n        node = expressionStatement(node);\n      }\n    }\n\n    blockNodes = [node];\n  }\n\n  return blockStatement(blockNodes);\n}\n","import toBlock from \"./toBlock.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Ensure the `key` (defaults to \"body\") of a `node` is a block.\n * Casting it to a block if it is not.\n *\n * Returns the BlockStatement\n */\nexport default function ensureBlock(\n  node: t.Node,\n  key: string = \"body\",\n): t.BlockStatement {\n  // @ts-expect-error Fixme: key may not exist in node, consider remove key = \"body\"\n  const result = toBlock(node[key], node);\n  // @ts-expect-error Fixme: key may not exist in node, consider remove key = \"body\"\n  node[key] = result;\n  return result;\n}\n","import isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport { isIdentifierChar } from \"@babel/helper-validator-identifier\";\n\nexport default function toIdentifier(input: string): string {\n  input = input + \"\";\n\n  // replace all non-valid identifiers with dashes\n  let name = \"\";\n  for (const c of input) {\n    name += isIdentifierChar(c.codePointAt(0)) ? c : \"-\";\n  }\n\n  // remove all dashes and numbers from start of name\n  name = name.replace(/^[-0-9]+/, \"\");\n\n  // camel case\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!isValidIdentifier(name)) {\n    name = `_${name}`;\n  }\n\n  return name || \"_\";\n}\n","import toIdentifier from \"./toIdentifier.ts\";\n\nexport default function toBindingIdentifierName(name: string): string {\n  name = toIdentifier(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n\n  return name;\n}\n","import { isIdentifier } from \"../validators/generated/index.ts\";\nimport { stringLiteral } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toComputedKey(\n  node:\n    | t.ObjectMember\n    | t.ObjectProperty\n    | t.ClassMethod\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.MemberExpression\n    | t.OptionalMemberExpression,\n  // @ts-expect-error todo(flow->ts): maybe check the type of node before accessing .key and .property\n  key: t.Expression | t.PrivateName = node.key || node.property,\n) {\n  if (!node.computed && isIdentifier(key)) key = stringLiteral(key.name);\n\n  return key;\n}\n","import {\n  isExpression,\n  isFunction,\n  isClass,\n  isExpressionStatement,\n} from \"../validators/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default toExpression as {\n  (node: t.Function): t.FunctionExpression;\n  (node: t.Class): t.ClassExpression;\n  (\n    node: t.ExpressionStatement | t.Expression | t.Class | t.Function,\n  ): t.Expression;\n};\n\nfunction toExpression(\n  node: t.ExpressionStatement | t.Expression | t.Class | t.Function,\n): t.Expression {\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  // return unmodified node\n  // important for things like ArrowFunctions where\n  // type change from ArrowFunction to FunctionExpression\n  // produces bugs like -> `()=>a` to `function () a`\n  // without generating a BlockStatement for it\n  // ref: https://github.com/babel/babili/issues/130\n  if (isExpression(node)) {\n    return node;\n  }\n\n  // convert all classes and functions\n  // ClassDeclaration -> ClassExpression\n  // FunctionDeclaration, ObjectMethod, ClassMethod -> FunctionExpression\n  if (isClass(node)) {\n    // @ts-expect-error todo(flow->ts): avoid type unsafe mutations\n    node.type = \"ClassExpression\";\n    // abstract modifiers are only allowed on class declarations\n    node.abstract = false;\n  } else if (isFunction(node)) {\n    // @ts-expect-error todo(flow->ts): avoid type unsafe mutations\n    node.type = \"FunctionExpression\";\n  }\n\n  // if it's still not an expression\n  if (!isExpression(node)) {\n    throw new Error(`cannot turn ${node.type} to an expression`);\n  }\n\n  return node;\n}\n","import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nconst _skip = Symbol();\nconst _stop = Symbol();\n\n/**\n * A prefix AST traversal implementation meant for simple searching and processing.\n * @param enter The callback can return `traverseFast.skip` to skip the subtree of the current node, or `traverseFast.stop` to stop the traversal.\n * @returns `true` if the traversal was stopped by callback, `false` otherwise.\n */\nexport default function traverseFast<Options = object>(\n  node: t.Node | null | undefined,\n  enter: (\n    node: t.Node,\n    opts?: Options,\n  ) => void | typeof traverseFast.skip | typeof traverseFast.stop,\n  opts?: Options,\n): boolean {\n  if (!node) return false;\n\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return false;\n\n  opts = opts || ({} as Options);\n  const ret = enter(node, opts);\n  if (ret !== undefined) {\n    switch (ret) {\n      case _skip:\n        return false;\n      case _stop:\n        return true;\n    }\n  }\n\n  for (const key of keys) {\n    const subNode: t.Node | undefined | null =\n      // @ts-expect-error key must present in node\n      node[key];\n\n    if (!subNode) continue;\n\n    if (Array.isArray(subNode)) {\n      for (const node of subNode) {\n        if (traverseFast(node, enter, opts)) return true;\n      }\n    } else {\n      if (traverseFast(subNode, enter, opts)) return true;\n    }\n  }\n  return false;\n}\n\ntraverseFast.skip = _skip;\ntraverseFast.stop = _stop;\n","import { COMMENT_KEYS } from \"../constants/index.ts\";\nimport type * as t from \"../index.ts\";\n\nconst CLEAR_KEYS = [\n  \"tokens\", // only exist in t.File\n  \"start\",\n  \"end\",\n  \"loc\",\n  // Fixme: should be extra.raw / extra.rawValue?\n  \"raw\",\n  \"rawValue\",\n] as const;\n\nconst CLEAR_KEYS_PLUS_COMMENTS = [\n  ...COMMENT_KEYS,\n  \"comments\",\n  ...CLEAR_KEYS,\n] as const;\n\nexport type Options = { preserveComments?: boolean };\n/**\n * Remove all of the _* properties from a node along with the additional metadata\n * properties like location data and raw token data.\n */\nexport default function removeProperties(\n  node: t.Node,\n  opts: Options = {},\n): void {\n  const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;\n  for (const key of map) {\n    // @ts-expect-error tokens only exist in t.File\n    if (node[key] != null) node[key] = undefined;\n  }\n\n  for (const key of Object.keys(node)) {\n    // @ts-expect-error string can not index node\n    if (key.startsWith(\"_\") && node[key] != null) node[key] = undefined;\n  }\n\n  const symbols: symbol[] = Object.getOwnPropertySymbols(node);\n  for (const sym of symbols) {\n    // @ts-expect-error Fixme: document symbol properties\n    node[sym] = null;\n  }\n}\n","import traverseFast from \"../traverse/traverseFast.ts\";\nimport removeProperties from \"./removeProperties.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function removePropertiesDeep<T extends t.Node>(\n  tree: T,\n  opts?: { preserveComments: boolean } | null,\n): T {\n  traverseFast(tree, removeProperties, opts);\n\n  return tree;\n}\n","import {\n  isIdentifier,\n  isStringLiteral,\n} from \"../validators/generated/index.ts\";\nimport cloneNode from \"../clone/cloneNode.ts\";\nimport removePropertiesDeep from \"../modifications/removePropertiesDeep.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default function toKeyAlias(\n  node: t.Method | t.Property,\n  key: t.Node = node.key,\n): string {\n  let alias;\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.kind`\n  if (node.kind === \"method\") {\n    return toKeyAlias.increment() + \"\";\n  } else if (isIdentifier(key)) {\n    alias = key.name;\n  } else if (isStringLiteral(key)) {\n    alias = JSON.stringify(key.value);\n  } else {\n    alias = JSON.stringify(removePropertiesDeep(cloneNode(key)));\n  }\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.computed`\n  if (node.computed) {\n    alias = `[${alias}]`;\n  }\n\n  // @ts-expect-error todo(flow->ts): maybe add node type check before checking `.static`\n  if (node.static) {\n    alias = `static:${alias}`;\n  }\n\n  return alias;\n}\n\ntoKeyAlias.uid = 0;\n\ntoKeyAlias.increment = function () {\n  if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {\n    return (toKeyAlias.uid = 0);\n  } else {\n    return toKeyAlias.uid++;\n  }\n};\n","import {\n  isStatement,\n  isFunction,\n  isClass,\n  isAssignmentExpression,\n} from \"../validators/generated/index.ts\";\nimport { expressionStatement } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default toStatement as {\n  (node: t.AssignmentExpression, ignore?: boolean): t.ExpressionStatement;\n\n  <T extends t.Statement>(node: T, ignore: false): T;\n  <T extends t.Statement>(node: T, ignore?: boolean): T | false;\n\n  (node: t.Class, ignore: false): t.ClassDeclaration;\n  (node: t.Class, ignore?: boolean): t.ClassDeclaration | false;\n\n  (node: t.Function, ignore: false): t.FunctionDeclaration;\n  (node: t.Function, ignore?: boolean): t.FunctionDeclaration | false;\n\n  (node: t.Node, ignore: false): t.Statement;\n  (node: t.Node, ignore?: boolean): t.Statement | false;\n};\n\nfunction toStatement(node: t.Node, ignore?: boolean): t.Statement | false {\n  if (isStatement(node)) {\n    return node;\n  }\n\n  let mustHaveId = false;\n  let newType;\n\n  if (isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\" as const;\n  } else if (isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\" as const;\n  } else if (isAssignmentExpression(node)) {\n    return expressionStatement(node);\n  }\n\n  // @ts-expect-error todo(flow->ts): node.id might be missing\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(`cannot turn ${node.type} to a statement`);\n    }\n  }\n\n  // @ts-expect-error manipulating node.type\n  node.type = newType;\n\n  // @ts-expect-error todo(flow->ts) refactor to avoid type unsafe mutations like reassigning node type above\n  return node;\n}\n","import isValidIdentifier from \"../validators/isValidIdentifier.ts\";\nimport {\n  identifier,\n  booleanLiteral,\n  nullLiteral,\n  stringLiteral,\n  numericLiteral,\n  bigIntLiteral,\n  regExpLiteral,\n  arrayExpression,\n  objectProperty,\n  objectExpression,\n  unaryExpression,\n  binaryExpression,\n} from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default valueToNode as {\n  (value: undefined): t.Identifier; // TODO: This should return \"void 0\"\n  (value: boolean): t.BooleanLiteral;\n  (value: null): t.NullLiteral;\n  (value: string): t.StringLiteral;\n  // Infinities and NaN need to use a BinaryExpression; negative values must be wrapped in UnaryExpression\n  (value: number): t.NumericLiteral | t.BinaryExpression | t.UnaryExpression;\n  (value: bigint): t.BigIntLiteral;\n  (value: RegExp): t.RegExpLiteral;\n  (value: readonly unknown[]): t.ArrayExpression;\n\n  // this throws with objects that are not plain objects,\n  // or if there are non-valueToNode-able values\n  (value: object): t.ObjectExpression;\n\n  (value: unknown): t.Expression;\n};\n\n// @ts-expect-error: Object.prototype.toString must return a string\nconst objectToString: (value: unknown) => string = Function.call.bind(\n  Object.prototype.toString,\n);\n\nfunction isRegExp(value: unknown): value is RegExp {\n  return objectToString(value) === \"[object RegExp]\";\n}\n\nfunction isPlainObject(value: unknown): value is object {\n  if (\n    typeof value !== \"object\" ||\n    value === null ||\n    Object.prototype.toString.call(value) !== \"[object Object]\"\n  ) {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  // Object.prototype's __proto__ is null. Every other class's __proto__.__proto__ is\n  // not null by default. We cannot check if proto === Object.prototype because it\n  // could come from another realm.\n  return proto === null || Object.getPrototypeOf(proto) === null;\n}\n\nfunction valueToNode(value: unknown): t.Expression {\n  // undefined\n  if (value === undefined) {\n    return identifier(\"undefined\");\n  }\n\n  // boolean\n  if (value === true || value === false) {\n    return booleanLiteral(value);\n  }\n\n  // null\n  if (value === null) {\n    return nullLiteral();\n  }\n\n  // strings\n  if (typeof value === \"string\") {\n    return stringLiteral(value);\n  }\n\n  // numbers\n  if (typeof value === \"number\") {\n    let result;\n    if (Number.isFinite(value)) {\n      result = numericLiteral(Math.abs(value));\n    } else {\n      let numerator;\n      if (Number.isNaN(value)) {\n        // NaN\n        numerator = numericLiteral(0);\n      } else {\n        // Infinity / -Infinity\n        numerator = numericLiteral(1);\n      }\n\n      result = binaryExpression(\"/\", numerator, numericLiteral(0));\n    }\n\n    if (value < 0 || Object.is(value, -0)) {\n      result = unaryExpression(\"-\", result);\n    }\n\n    return result;\n  }\n\n  // bigints\n  if (typeof value === \"bigint\") {\n    if (value < 0) {\n      return unaryExpression(\"-\", bigIntLiteral(-value));\n    } else {\n      return bigIntLiteral(value);\n    }\n  }\n\n  // regexes\n  if (isRegExp(value)) {\n    const pattern = value.source;\n    const flags = /\\/([a-z]*)$/.exec(value.toString())[1];\n    return regExpLiteral(pattern, flags);\n  }\n\n  // array\n  if (Array.isArray(value)) {\n    return arrayExpression(value.map(valueToNode));\n  }\n\n  // object\n  if (isPlainObject(value)) {\n    const props = [];\n    for (const key of Object.keys(value)) {\n      let nodeKey,\n        computed = false;\n      if (isValidIdentifier(key)) {\n        if (key === \"__proto__\") {\n          computed = true;\n          nodeKey = stringLiteral(key);\n        } else {\n          nodeKey = identifier(key);\n        }\n      } else {\n        nodeKey = stringLiteral(key);\n      }\n      props.push(\n        objectProperty(\n          nodeKey,\n          valueToNode(\n            // @ts-expect-error key must present in value\n            value[key],\n          ),\n          computed,\n        ),\n      );\n    }\n    return objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}\n","import { memberExpression } from \"../builders/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Append a node to a member expression.\n */\nexport default function appendToMemberExpression(\n  member: t.MemberExpression,\n  append: t.MemberExpression[\"property\"],\n  computed: boolean = false,\n): t.MemberExpression {\n  member.object = memberExpression(\n    member.object,\n    member.property,\n    member.computed,\n  );\n  member.property = append;\n  member.computed = !!computed;\n\n  return member;\n}\n","import { INHERIT_KEYS } from \"../constants/index.ts\";\nimport inheritsComments from \"../comments/inheritsComments.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Inherit all contextual properties from `parent` node to `child` node.\n */\nexport default function inherits<T extends t.Node | null | undefined>(\n  child: T,\n  parent: t.Node | null | undefined,\n): T {\n  if (!child || !parent) return child;\n\n  // optionally inherit specific properties if not null\n  for (const key of INHERIT_KEYS.optional) {\n    // @ts-expect-error Fixme: refine parent types\n    if (child[key] == null) {\n      // @ts-expect-error Fixme: refine parent types\n      child[key] = parent[key];\n    }\n  }\n\n  // force inherit \"private\" properties\n  for (const key of Object.keys(parent)) {\n    if (key.startsWith(\"_\") && key !== \"__clone\") {\n      // @ts-expect-error Fixme: refine parent types\n      child[key] = parent[key];\n    }\n  }\n\n  // force inherit select properties\n  for (const key of INHERIT_KEYS.force) {\n    // @ts-expect-error Fixme: refine parent types\n    child[key] = parent[key];\n  }\n\n  inheritsComments(child, parent);\n\n  return child;\n}\n","import { memberExpression } from \"../builders/generated/index.ts\";\nimport { isSuper } from \"../index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Prepend a node to a member expression.\n */\nexport default function prependToMemberExpression<\n  T extends Pick<t.MemberExpression, \"object\" | \"property\">,\n>(member: T, prepend: t.MemberExpression[\"object\"]): T {\n  if (isSuper(member.object)) {\n    throw new Error(\n      \"Cannot prepend node to super property access (`super.foo`).\",\n    );\n  }\n  member.object = memberExpression(prepend, member.object);\n\n  return member;\n}\n","import type * as t from \"../index.ts\";\n\n/**\n * For the given node, generate a map from assignment id names to the identifier node.\n * Unlike getBindingIdentifiers, this function does not handle declarations and imports.\n * @param node the assignment expression or forXstatement\n * @returns an object map\n * @see getBindingIdentifiers\n */\nexport default function getAssignmentIdentifiers(\n  node: t.Node | t.Node[],\n): Record<string, t.Identifier> {\n  // null represents holes in an array pattern\n  const search: (t.Node | null)[] = [].concat(node);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.pop();\n    if (!id) continue;\n\n    switch (id.type) {\n      case \"ArrayPattern\":\n        search.push(...id.elements);\n        break;\n\n      case \"AssignmentExpression\":\n      case \"AssignmentPattern\":\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        search.push(id.left);\n        break;\n\n      case \"ObjectPattern\":\n        search.push(...id.properties);\n        break;\n\n      case \"ObjectProperty\":\n        search.push(id.value);\n        break;\n\n      case \"RestElement\":\n      case \"UpdateExpression\":\n        search.push(id.argument);\n        break;\n\n      case \"UnaryExpression\":\n        if (id.operator === \"delete\") {\n          search.push(id.argument);\n        }\n        break;\n\n      case \"Identifier\":\n        ids[id.name] = id;\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  return ids;\n}\n","import {\n  isExportDeclaration,\n  isIdentifier,\n  isClassExpression,\n  isDeclaration,\n  isFunctionDeclaration,\n  isFunctionExpression,\n  isExportAllDeclaration,\n  isAssignmentExpression,\n  isUnaryExpression,\n  isUpdateExpression,\n} from \"../validators/generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport { getBindingIdentifiers as default };\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates: true,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier[]>;\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: false,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier>;\n\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: boolean,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier> | Record<string, t.Identifier[]>;\n\n/**\n * Return a list of binding identifiers associated with the input `node`.\n */\nfunction getBindingIdentifiers(\n  node: t.Node,\n  duplicates?: boolean,\n  outerOnly?: boolean,\n  newBindingsOnly?: boolean,\n): Record<string, t.Identifier> | Record<string, t.Identifier[]> {\n  const search: t.Node[] = [].concat(node);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n\n    if (\n      newBindingsOnly &&\n      // These nodes do not introduce _new_ bindings, but they are included\n      // in getBindingIdentifiers.keys for backwards compatibility.\n      // TODO(@nicolo-ribaudo): Check if we can remove them from .keys in a\n      // backward-compatible way, and if not what we need to do to remove them\n      // in Babel 8.\n      (isAssignmentExpression(id) ||\n        isUnaryExpression(id) ||\n        isUpdateExpression(id))\n    ) {\n      continue;\n    }\n\n    if (isIdentifier(id)) {\n      if (duplicates) {\n        const _ids = (ids[id.name] = ids[id.name] || []);\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n      continue;\n    }\n\n    if (isExportDeclaration(id) && !isExportAllDeclaration(id)) {\n      if (isDeclaration(id.declaration)) {\n        search.push(id.declaration);\n      }\n      continue;\n    }\n\n    if (outerOnly) {\n      if (isFunctionDeclaration(id)) {\n        search.push(id.id);\n        continue;\n      }\n\n      if (isFunctionExpression(id) || isClassExpression(id)) {\n        continue;\n      }\n    }\n\n    const keys = getBindingIdentifiers.keys[id.type];\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const nodes =\n          // @ts-expect-error key must present in id\n          id[key] as t.Node[] | t.Node | undefined | null;\n        if (nodes) {\n          if (Array.isArray(nodes)) {\n            search.push(...nodes);\n          } else {\n            search.push(nodes);\n          }\n        }\n      }\n    }\n  }\n  return ids;\n}\n\n/**\n * Mapping of types to their identifier keys.\n */\ntype KeysMap = {\n  [N in t.Node as N[\"type\"]]?: (keyof N)[];\n};\n\nconst keys: KeysMap = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  DeclareInterface: [\"id\"],\n  DeclareTypeAlias: [\"id\"],\n  DeclareOpaqueType: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n  OpaqueType: [\"id\"],\n\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n  TSImportEqualsDeclaration: [\"id\"],\n\n  ExportSpecifier: [\"exported\"],\n  ExportNamespaceSpecifier: [\"exported\"],\n  ExportDefaultSpecifier: [\"exported\"],\n\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n  ArrowFunctionExpression: [\"params\"],\n  ObjectMethod: [\"params\"],\n  ClassMethod: [\"params\"],\n  ClassPrivateMethod: [\"params\"],\n\n  ForInStatement: [\"left\"],\n  ForOfStatement: [\"left\"],\n\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n\n  ObjectProperty: [\"value\"],\n\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"],\n};\n\ngetBindingIdentifiers.keys = keys;\n","import getBindingIdentifiers from \"./getBindingIdentifiers.ts\";\nimport type * as t from \"../index.ts\";\n\nexport default getOuterBindingIdentifiers as {\n  (node: t.Node, duplicates: true): Record<string, t.Identifier[]>;\n  (node: t.Node, duplicates?: false): Record<string, t.Identifier>;\n  (\n    node: t.Node,\n    duplicates?: boolean,\n  ): Record<string, t.Identifier> | Record<string, t.Identifier[]>;\n};\n\nfunction getOuterBindingIdentifiers(\n  node: t.Node,\n  duplicates: boolean,\n): Record<string, t.Identifier> | Record<string, t.Identifier[]> {\n  return getBindingIdentifiers(node, duplicates, true);\n}\n","import type * as t from \"../index.ts\";\n\nimport {\n  isAssignmentExpression,\n  isClassMethod,\n  isIdentifier,\n  isLiteral,\n  isNullLiteral,\n  isObjectMethod,\n  isObjectProperty,\n  isPrivateName,\n  isRegExpLiteral,\n  isTemplateLiteral,\n  isVariableDeclarator,\n} from \"../validators/generated/index.ts\";\n\nfunction getNameFromLiteralId(id: t.Literal): string {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (isRegExpLiteral(id)) {\n    return `/${id.pattern}/${id.flags}`;\n  }\n\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return String(id.value);\n  }\n\n  return null;\n}\n\nfunction getObjectMemberKey(\n  node: t.ObjectProperty | t.ObjectMethod | t.ClassProperty | t.ClassMethod,\n): t.Expression | t.PrivateName {\n  if (!node.computed || isLiteral(node.key)) {\n    return node.key;\n  }\n}\n\ntype GetFunctionNameResult = {\n  name: string;\n  originalNode: t.Node;\n} | null;\n\nexport default function getFunctionName(\n  node: t.ObjectMethod | t.ClassMethod,\n): GetFunctionNameResult;\nexport default function getFunctionName(\n  node: t.Function | t.Class,\n  parent: t.Node,\n): GetFunctionNameResult;\nexport default function getFunctionName(\n  node: t.Function | t.Class,\n  parent?: t.Node,\n): GetFunctionNameResult {\n  if (\"id\" in node && node.id) {\n    return {\n      name: node.id.name,\n      originalNode: node.id,\n    };\n  }\n\n  let prefix = \"\";\n\n  let id;\n  if (isObjectProperty(parent, { value: node })) {\n    // { foo: () => {} };\n    id = getObjectMemberKey(parent);\n  } else if (isObjectMethod(node) || isClassMethod(node)) {\n    // { foo() {} };\n    id = getObjectMemberKey(node);\n    if (node.kind === \"get\") prefix = \"get \";\n    else if (node.kind === \"set\") prefix = \"set \";\n  } else if (isVariableDeclarator(parent, { init: node })) {\n    // let foo = function () {};\n    id = parent.id;\n  } else if (isAssignmentExpression(parent, { operator: \"=\", right: node })) {\n    // foo = function () {};\n    id = parent.left;\n  }\n\n  if (!id) return null;\n\n  const name = isLiteral(id)\n    ? getNameFromLiteralId(id)\n    : isIdentifier(id)\n      ? id.name\n      : isPrivateName(id)\n        ? id.id.name\n        : null;\n  if (name == null) return null;\n\n  return { name: prefix + name, originalNode: id };\n}\n","import { VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\nexport type TraversalAncestors = {\n  node: t.Node;\n  key: string;\n  index?: number;\n}[];\n\nexport type TraversalHandler<T> = (\n  this: undefined,\n  node: t.Node,\n  parent: TraversalAncestors,\n  state: T,\n) => void;\n\nexport type TraversalHandlers<T> = {\n  enter?: TraversalHandler<T>;\n  exit?: TraversalHandler<T>;\n};\n\n/**\n * A general AST traversal with both prefix and postfix handlers, and a\n * state object. Exposes ancestry data to each handler so that more complex\n * AST data can be taken into account.\n */\nexport default function traverse<T>(\n  node: t.Node,\n  handlers: TraversalHandler<T> | TraversalHandlers<T>,\n  state?: T,\n): void {\n  if (typeof handlers === \"function\") {\n    handlers = { enter: handlers };\n  }\n\n  const { enter, exit } = handlers;\n\n  traverseSimpleImpl(node, enter, exit, state, []);\n}\n\nfunction traverseSimpleImpl<T>(\n  node: any,\n  enter: Function | undefined,\n  exit: Function | undefined,\n  state: T | undefined,\n  ancestors: TraversalAncestors,\n) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  if (enter) enter(node, ancestors, state);\n\n  for (const key of keys) {\n    const subNode = node[key];\n\n    if (Array.isArray(subNode)) {\n      for (let i = 0; i < subNode.length; i++) {\n        const child = subNode[i];\n        if (!child) continue;\n\n        ancestors.push({\n          node,\n          key,\n          index: i,\n        });\n\n        traverseSimpleImpl(child, enter, exit, state, ancestors);\n\n        ancestors.pop();\n      }\n    } else if (subNode) {\n      ancestors.push({\n        node,\n        key,\n      });\n\n      traverseSimpleImpl(subNode, enter, exit, state, ancestors);\n\n      ancestors.pop();\n    }\n  }\n\n  if (exit) exit(node, ancestors, state);\n}\n","import getBindingIdentifiers from \"../retrievers/getBindingIdentifiers.ts\";\nimport type * as t from \"../index.ts\";\n/**\n * Check if the input `node` is a binding identifier.\n */\nexport default function isBinding(\n  node: t.Node,\n  parent: t.Node,\n  grandparent?: t.Node,\n): boolean {\n  if (\n    grandparent &&\n    node.type === \"Identifier\" &&\n    parent.type === \"ObjectProperty\" &&\n    grandparent.type === \"ObjectExpression\"\n  ) {\n    // We need to special-case this, because getBindingIdentifiers\n    // has an ObjectProperty->value entry for destructuring patterns.\n    return false;\n  }\n\n  const keys = getBindingIdentifiers.keys[parent.type];\n  if (keys) {\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val =\n        // @ts-expect-error key must present in parent\n        parent[key];\n      if (Array.isArray(val)) {\n        if (val.includes(node)) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}\n","import { isVariableDeclaration } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a `let` variable declaration.\n */\nexport default function isLet(node: t.Node): boolean {\n  return isVariableDeclaration(node) && node.kind !== \"var\";\n}\n","import {\n  isClassDeclaration,\n  isFunctionDeclaration,\n} from \"./generated/index.ts\";\nimport isLet from \"./isLet.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is block scoped.\n */\nexport default function isBlockScoped(\n  node: t.Node | null | undefined,\n): boolean {\n  return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);\n}\n","import isType from \"./isType.ts\";\nimport { isIdentifier } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is definitely immutable.\n */\nexport default function isImmutable(node: t.Node): boolean {\n  if (isType(node.type, \"Immutable\")) return true;\n\n  if (isIdentifier(node)) {\n    if (node.name === \"undefined\") {\n      // immutable!\n      return true;\n    } else {\n      // no idea...\n      return false;\n    }\n  }\n\n  return false;\n}\n","import { NODE_FIELDS, VISITOR_KEYS } from \"../definitions/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if two nodes are equivalent\n */\nexport default function isNodesEquivalent<T extends Partial<t.Node>>(\n  a: T,\n  b: any,\n): b is T {\n  if (\n    typeof a !== \"object\" ||\n    typeof b !== \"object\" ||\n    a == null ||\n    b == null\n  ) {\n    return a === b;\n  }\n\n  if (a.type !== b.type) {\n    return false;\n  }\n\n  const fields = Object.keys(NODE_FIELDS[a.type] || a.type);\n  const visitorKeys = VISITOR_KEYS[a.type];\n\n  for (const field of fields) {\n    const val_a =\n      // @ts-expect-error field must present in a\n      a[field];\n    const val_b = b[field];\n    if (typeof val_a !== typeof val_b) {\n      return false;\n    }\n    if (val_a == null && val_b == null) {\n      continue;\n    } else if (val_a == null || val_b == null) {\n      return false;\n    }\n\n    if (Array.isArray(val_a)) {\n      if (!Array.isArray(val_b)) {\n        return false;\n      }\n      if (val_a.length !== val_b.length) {\n        return false;\n      }\n\n      for (let i = 0; i < val_a.length; i++) {\n        if (!isNodesEquivalent(val_a[i], val_b[i])) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    if (typeof val_a === \"object\" && !visitorKeys?.includes(field)) {\n      for (const key of Object.keys(val_a)) {\n        if (val_a[key] !== val_b[key]) {\n          return false;\n        }\n      }\n      continue;\n    }\n\n    if (!isNodesEquivalent(val_a, val_b)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a reference to a bound variable.\n */\nexport default function isReferenced(\n  node: t.Node | null | undefined,\n  parent: t.Node,\n  grandparent?: t.Node,\n): boolean {\n  switch (parent.type) {\n    // yes: PARENT[NODE]\n    // yes: NODE.child\n    // no: parent.NODE\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n      if (parent.property === node) {\n        return !!parent.computed;\n      }\n      return parent.object === node;\n\n    case \"JSXMemberExpression\":\n      return parent.object === node;\n    // no: let NODE = init;\n    // yes: let id = NODE;\n    case \"VariableDeclarator\":\n      return parent.init === node;\n\n    // yes: () => NODE\n    // no: (NODE) => {}\n    case \"ArrowFunctionExpression\":\n      return parent.body === node;\n\n    // no: class { #NODE; }\n    // no: class { get #NODE() {} }\n    // no: class { #NODE() {} }\n    // no: class { fn() { return this.#NODE; } }\n    case \"PrivateName\":\n      return false;\n\n    // no: class { NODE() {} }\n    // yes: class { [NODE]() {} }\n    // no: class { foo(NODE) {} }\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"ObjectMethod\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return false;\n\n    // yes: { [NODE]: \"\" }\n    // no: { NODE: \"\" }\n    // depends: { NODE }\n    // depends: { key: NODE }\n    case \"ObjectProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      // parent.value === node\n      return grandparent?.type !== \"ObjectPattern\";\n    // no: class { NODE = value; }\n    // yes: class { [NODE] = value; }\n    // yes: class { key = NODE; }\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n      return true;\n    case \"ClassPrivateProperty\":\n      return parent.key !== node;\n\n    // no: class NODE {}\n    // yes: class Foo extends NODE {}\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.superClass === node;\n\n    // yes: left = NODE;\n    // no: NODE = right;\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    // no: [NODE = foo] = [];\n    // yes: [foo = NODE] = [];\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    // no: NODE: for (;;) {}\n    case \"LabeledStatement\":\n      return false;\n\n    // no: try {} catch (NODE) {}\n    case \"CatchClause\":\n      return false;\n\n    // no: function foo(...NODE) {}\n    case \"RestElement\":\n      return false;\n\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n      return false;\n\n    // no: function NODE() {}\n    // no: function foo(NODE) {}\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      return false;\n\n    // no: export NODE from \"foo\";\n    // no: export * as NODE from \"foo\";\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      return false;\n\n    // no: export { foo as NODE };\n    // yes: export { NODE as foo };\n    // no: export { NODE as foo } from \"foo\";\n    case \"ExportSpecifier\":\n      // @ts-expect-error todo(flow->ts): Property 'source' does not exist on type 'AnyTypeAnnotation'.\n      if (grandparent?.source) {\n        return false;\n      }\n      return parent.local === node;\n\n    // no: import NODE from \"foo\";\n    // no: import * as NODE from \"foo\";\n    // no: import { NODE as foo } from \"foo\";\n    // no: import { foo as NODE } from \"foo\";\n    // no: import NODE from \"bar\";\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    // no: import \"foo\" assert { NODE: \"json\" }\n    case \"ImportAttribute\":\n      return false;\n\n    // no: <div NODE=\"foo\" />\n    case \"JSXAttribute\":\n      return false;\n\n    // no: [NODE] = [];\n    // no: ({ NODE }) = [];\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n\n    // no: new.NODE\n    // no: NODE.target\n    case \"MetaProperty\":\n      return false;\n\n    // yes: type X = { someProperty: NODE }\n    // no: type X = { NODE: OtherType }\n    case \"ObjectTypeProperty\":\n      return parent.key !== node;\n\n    // yes: enum X { Foo = NODE }\n    // no: enum X { NODE }\n    case \"TSEnumMember\":\n      return parent.id !== node;\n\n    // yes: { [NODE]: value }\n    // no: { NODE: value }\n    case \"TSPropertySignature\":\n      if (parent.key === node) {\n        return !!parent.computed;\n      }\n\n      return true;\n  }\n\n  return true;\n}\n","import {\n  isFunction,\n  isCatchClause,\n  isBlockStatement,\n  isScopable,\n  isPattern,\n} from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a scope.\n */\nexport default function isScope(\n  node: t.Node | null | undefined,\n  parent: t.Node,\n): boolean {\n  // If a BlockStatement is an immediate descendent of a Function/CatchClause, it must be in the body.\n  // Hence we skipped the parentKey === \"params\" check\n  if (isBlockStatement(node) && (isFunction(parent) || isCatchClause(parent))) {\n    return false;\n  }\n\n  // If a Pattern is an immediate descendent of a Function/CatchClause, it must be in the params.\n  // Hence we skipped the parentKey === \"params\" check\n  if (isPattern(node) && (isFunction(parent) || isCatchClause(parent))) {\n    return true;\n  }\n\n  return isScopable(node);\n}\n","import { isIdentifier, isImportDefaultSpecifier } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `specifier` is a `default` import or export.\n */\nexport default function isSpecifierDefault(\n  specifier: t.ModuleSpecifier,\n): boolean {\n  return (\n    isImportDefaultSpecifier(specifier) ||\n    // @ts-expect-error todo(flow->ts): stricter type for specifier\n    isIdentifier(specifier.imported || specifier.exported, {\n      name: \"default\",\n    })\n  );\n}\n","import isValidIdentifier from \"./isValidIdentifier.ts\";\n\nconst RESERVED_WORDS_ES3_ONLY = new Set<string>([\n  \"abstract\",\n  \"boolean\",\n  \"byte\",\n  \"char\",\n  \"double\",\n  \"enum\",\n  \"final\",\n  \"float\",\n  \"goto\",\n  \"implements\",\n  \"int\",\n  \"interface\",\n  \"long\",\n  \"native\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"short\",\n  \"static\",\n  \"synchronized\",\n  \"throws\",\n  \"transient\",\n  \"volatile\",\n]);\n\n/**\n * Check if the input `name` is a valid identifier name according to the ES3 specification.\n *\n * Additional ES3 reserved words are\n */\nexport default function isValidES3Identifier(name: string): boolean {\n  return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);\n}\n","import { isVariableDeclaration } from \"./generated/index.ts\";\nimport type * as t from \"../index.ts\";\n\n/**\n * Check if the input `node` is a variable declaration.\n */\nexport default function isVar(node: t.Node | null | undefined): boolean {\n  return isVariableDeclaration(node) && node.kind === \"var\";\n}\n","import isReactComponent from \"./validators/react/isReactComponent.ts\";\nimport isCompatTag from \"./validators/react/isCompatTag.ts\";\nimport buildChildren from \"./builders/react/buildChildren.ts\";\n\n// asserts\nexport { default as assertNode } from \"./asserts/assertNode.ts\";\nexport * from \"./asserts/generated/index.ts\";\n\n// builders\nexport { default as createTypeAnnotationBasedOnTypeof } from \"./builders/flow/createTypeAnnotationBasedOnTypeof.ts\";\n/** @deprecated use createFlowUnionType instead */\nexport { default as createUnionTypeAnnotation } from \"./builders/flow/createFlowUnionType.ts\";\nexport { default as createFlowUnionType } from \"./builders/flow/createFlowUnionType.ts\";\nexport { default as createTSUnionType } from \"./builders/typescript/createTSUnionType.ts\";\nexport * from \"./builders/productions.ts\";\nexport * from \"./builders/generated/index.ts\"; // includes AST types\n\n// clone\nexport { default as cloneNode } from \"./clone/cloneNode.ts\";\nexport { default as clone } from \"./clone/clone.ts\";\nexport { default as cloneDeep } from \"./clone/cloneDeep.ts\";\nexport { default as cloneDeepWithoutLoc } from \"./clone/cloneDeepWithoutLoc.ts\";\nexport { default as cloneWithoutLoc } from \"./clone/cloneWithoutLoc.ts\";\n\n// comments\nexport { default as addComment } from \"./comments/addComment.ts\";\nexport { default as addComments } from \"./comments/addComments.ts\";\nexport { default as inheritInnerComments } from \"./comments/inheritInnerComments.ts\";\nexport { default as inheritLeadingComments } from \"./comments/inheritLeadingComments.ts\";\nexport { default as inheritsComments } from \"./comments/inheritsComments.ts\";\nexport { default as inheritTrailingComments } from \"./comments/inheritTrailingComments.ts\";\nexport { default as removeComments } from \"./comments/removeComments.ts\";\n\n// constants\nexport * from \"./constants/generated/index.ts\";\nexport * from \"./constants/index.ts\";\n\n// converters\nexport { default as ensureBlock } from \"./converters/ensureBlock.ts\";\nexport { default as toBindingIdentifierName } from \"./converters/toBindingIdentifierName.ts\";\nexport { default as toBlock } from \"./converters/toBlock.ts\";\nexport { default as toComputedKey } from \"./converters/toComputedKey.ts\";\nexport { default as toExpression } from \"./converters/toExpression.ts\";\nexport { default as toIdentifier } from \"./converters/toIdentifier.ts\";\nexport { default as toKeyAlias } from \"./converters/toKeyAlias.ts\";\nexport { default as toStatement } from \"./converters/toStatement.ts\";\nexport { default as valueToNode } from \"./converters/valueToNode.ts\";\n\n// definitions\nexport * from \"./definitions/index.ts\";\n\n// modifications\nexport { default as appendToMemberExpression } from \"./modifications/appendToMemberExpression.ts\";\nexport { default as inherits } from \"./modifications/inherits.ts\";\nexport { default as prependToMemberExpression } from \"./modifications/prependToMemberExpression.ts\";\nexport {\n  default as removeProperties,\n  type Options as RemovePropertiesOptions,\n} from \"./modifications/removeProperties.ts\";\nexport { default as removePropertiesDeep } from \"./modifications/removePropertiesDeep.ts\";\nexport { default as removeTypeDuplicates } from \"./modifications/flow/removeTypeDuplicates.ts\";\n\n// retrievers\nexport { default as getAssignmentIdentifiers } from \"./retrievers/getAssignmentIdentifiers.ts\";\nexport { default as getBindingIdentifiers } from \"./retrievers/getBindingIdentifiers.ts\";\nexport { default as getOuterBindingIdentifiers } from \"./retrievers/getOuterBindingIdentifiers.ts\";\nexport { default as getFunctionName } from \"./retrievers/getFunctionName.ts\";\n\n// traverse\nexport { default as traverse } from \"./traverse/traverse.ts\";\nexport * from \"./traverse/traverse.ts\";\nexport { default as traverseFast } from \"./traverse/traverseFast.ts\";\n\n// utils\nexport { default as shallowEqual } from \"./utils/shallowEqual.ts\";\n\n// validators\nexport { default as is } from \"./validators/is.ts\";\nexport { default as isBinding } from \"./validators/isBinding.ts\";\nexport { default as isBlockScoped } from \"./validators/isBlockScoped.ts\";\nexport { default as isImmutable } from \"./validators/isImmutable.ts\";\nexport { default as isLet } from \"./validators/isLet.ts\";\nexport { default as isNode } from \"./validators/isNode.ts\";\nexport { default as isNodesEquivalent } from \"./validators/isNodesEquivalent.ts\";\nexport { default as isPlaceholderType } from \"./validators/isPlaceholderType.ts\";\nexport { default as isReferenced } from \"./validators/isReferenced.ts\";\nexport { default as isScope } from \"./validators/isScope.ts\";\nexport { default as isSpecifierDefault } from \"./validators/isSpecifierDefault.ts\";\nexport { default as isType } from \"./validators/isType.ts\";\nexport { default as isValidES3Identifier } from \"./validators/isValidES3Identifier.ts\";\nexport { default as isValidIdentifier } from \"./validators/isValidIdentifier.ts\";\nexport { default as isVar } from \"./validators/isVar.ts\";\nexport { default as matchesPattern } from \"./validators/matchesPattern.ts\";\nexport { default as validate } from \"./validators/validate.ts\";\nexport { default as buildMatchMemberExpression } from \"./validators/buildMatchMemberExpression.ts\";\nexport * from \"./validators/generated/index.ts\";\n\n// react\nexport const react = {\n  isReactComponent,\n  isCompatTag,\n  buildChildren,\n};\n\n// this is used by @babel/traverse to warn about deprecated visitors\nexport { default as __internal__deprecationWarning } from \"./utils/deprecationWarning.ts\";\n"],"names":["shallowEqual","actual","expected","keys","Object","key","warnings","Set","deprecationWarning","oldName","newName","prefix","cacheKey","has","add","internal","trace","captureShortStackTrace","console","warn","skip","length","stackTraceLimit","prepareStackTrace","Error","stackTrace","err","stack","shortStackTrace","slice","test","getFileName","map","frame","join","isArrayExpression","node","opts","type","isAssignmentExpression","isBinaryExpression","isInterpreterDirective","isDirective","isDirectiveLiteral","isBlockStatement","isBreakStatement","isCallExpression","isCatchClause","isConditionalExpression","isContinueStatement","isDebuggerStatement","isDoWhileStatement","isEmptyStatement","isExpressionStatement","isFile","isForInStatement","isForStatement","isFunctionDeclaration","isFunctionExpression","isIdentifier","isIfStatement","isLabeledStatement","isStringLiteral","isNumericLiteral","isNullLiteral","isBooleanLiteral","isRegExpLiteral","isLogicalExpression","isMemberExpression","isNewExpression","isProgram","isObjectExpression","isObjectMethod","isObjectProperty","isRestElement","isReturnStatement","isSequenceExpression","isParenthesizedExpression","isSwitchCase","isSwitchStatement","isThisExpression","isThrowStatement","isTryStatement","isUnaryExpression","isUpdateExpression","isVariableDeclaration","isVariableDeclarator","isWhileStatement","isWithStatement","isAssignmentPattern","isArrayPattern","isArrowFunctionExpression","isClassBody","isClassExpression","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isExportSpecifier","isForOfStatement","isImportDeclaration","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","isImportExpression","isMetaProperty","isClassMethod","isObjectPattern","isSpreadElement","isSuper","isTaggedTemplateExpression","isTemplateElement","isTemplateLiteral","isYieldExpression","isAwaitExpression","isImport","isBigIntLiteral","isExportNamespaceSpecifier","isOptionalMemberExpression","isOptionalCallExpression","isClassProperty","isClassAccessorProperty","isClassPrivateProperty","isClassPrivateMethod","isPrivateName","isStaticBlock","isImportAttribute","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isBooleanLiteralTypeAnnotation","isNullLiteralTypeAnnotation","isClassImplements","isDeclareClass","isDeclareFunction","isDeclareInterface","isDeclareModule","isDeclareModuleExports","isDeclareTypeAlias","isDeclareOpaqueType","isDeclareVariable","isDeclareExportDeclaration","isDeclareExportAllDeclaration","isDeclaredPredicate","isExistsTypeAnnotation","isFunctionTypeAnnotation","isFunctionTypeParam","isGenericTypeAnnotation","isInferredPredicate","isInterfaceExtends","isInterfaceDeclaration","isInterfaceTypeAnnotation","isIntersectionTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isNullableTypeAnnotation","isNumberLiteralTypeAnnotation","isNumberTypeAnnotation","isObjectTypeAnnotation","isObjectTypeInternalSlot","isObjectTypeCallProperty","isObjectTypeIndexer","isObjectTypeProperty","isObjectTypeSpreadProperty","isOpaqueType","isQualifiedTypeIdentifier","isStringLiteralTypeAnnotation","isStringTypeAnnotation","isSymbolTypeAnnotation","isThisTypeAnnotation","isTupleTypeAnnotation","isTypeofTypeAnnotation","isTypeAlias","isTypeAnnotation","isTypeCastExpression","isTypeParameter","isTypeParameterDeclaration","isTypeParameterInstantiation","isUnionTypeAnnotation","isVariance","isVoidTypeAnnotation","isEnumDeclaration","isEnumBooleanBody","isEnumNumberBody","isEnumStringBody","isEnumSymbolBody","isEnumBooleanMember","isEnumNumberMember","isEnumStringMember","isEnumDefaultedMember","isIndexedAccessType","isOptionalIndexedAccessType","isJSXAttribute","isJSXClosingElement","isJSXElement","isJSXEmptyExpression","isJSXExpressionContainer","isJSXSpreadChild","isJSXIdentifier","isJSXMemberExpression","isJSXNamespacedName","isJSXOpeningElement","isJSXSpreadAttribute","isJSXText","isJSXFragment","isJSXOpeningFragment","isJSXClosingFragment","isPlaceholder","isV8IntrinsicIdentifier","isArgumentPlaceholder","isBindExpression","isDecorator","isDoExpression","isExportDefaultSpecifier","isModuleExpression","isTopicReference","isPipelineTopicExpression","isPipelineBareFunction","isPipelinePrimaryTopicReference","isVoidPattern","isTSParameterProperty","isTSDeclareFunction","isTSDeclareMethod","isTSQualifiedName","isTSCallSignatureDeclaration","isTSConstructSignatureDeclaration","isTSPropertySignature","isTSMethodSignature","isTSIndexSignature","isTSAnyKeyword","isTSBooleanKeyword","isTSBigIntKeyword","isTSIntrinsicKeyword","isTSNeverKeyword","isTSNullKeyword","isTSNumberKeyword","isTSObjectKeyword","isTSStringKeyword","isTSSymbolKeyword","isTSUndefinedKeyword","isTSUnknownKeyword","isTSVoidKeyword","isTSThisType","isTSFunctionType","isTSConstructorType","isTSTypeReference","isTSTypePredicate","isTSTypeQuery","isTSTypeLiteral","isTSArrayType","isTSTupleType","isTSOptionalType","isTSRestType","isTSNamedTupleMember","isTSUnionType","isTSIntersectionType","isTSConditionalType","isTSInferType","isTSParenthesizedType","isTSTypeOperator","isTSIndexedAccessType","isTSMappedType","isTSTemplateLiteralType","isTSLiteralType","isTSClassImplements","isTSInterfaceHeritage","isTSInterfaceDeclaration","isTSInterfaceBody","isTSTypeAliasDeclaration","isTSInstantiationExpression","isTSAsExpression","isTSSatisfiesExpression","isTSTypeAssertion","isTSEnumBody","isTSEnumDeclaration","isTSEnumMember","isTSModuleDeclaration","isTSModuleBlock","isTSImportType","isTSImportEqualsDeclaration","isTSExternalModuleReference","isTSNonNullExpression","isTSExportAssignment","isTSNamespaceExportDeclaration","isTSTypeAnnotation","isTSTypeParameterInstantiation","isTSTypeParameterDeclaration","isTSTypeParameter","isStandardized","expectedNode","isExpression","isBinary","isScopable","isBlockParent","isBlock","isStatement","isTerminatorless","isCompletionStatement","isConditional","isLoop","isWhile","isExpressionWrapper","isFor","isForXStatement","isFunction","isFunctionParent","isPureish","isDeclaration","isFunctionParameter","isPatternLike","isLVal","isTSEntityName","isLiteral","isUserWhitespacable","isMethod","isObjectMember","isProperty","isUnaryLike","isPattern","isClass","isImportOrExportDeclaration","isExportDeclaration","isModuleSpecifier","isAccessor","isPrivate","isFlow","isFlowType","isFlowBaseAnnotation","isFlowDeclaration","isFlowPredicate","isEnumBody","isEnumMember","isJSX","isMiscellaneous","isTypeScript","isTSTypeElement","isTSType","isTSBaseType","isNumberLiteral","isRegexLiteral","isRestProperty","isSpreadProperty","isModuleDeclaration","isMemberExpressionLike","matchesPattern","member","match","allowPartial","parts","Array","isArray","split","nodes","object","meta","push","property","i","j","value","name","id","buildMatchMemberExpression","isReactComponent","isCompatTag","tagName","isType","nodeType","targetType","ALIAS_KEYS","aliases","FLIPPED_ALIAS_KEYS","includes","isPlaceholderType","placeholderType","PLACEHOLDERS_ALIAS","is","matches","undefined","isValidIdentifier","reserved","isKeyword","isStrictReservedWord","isIdentifierName","STATEMENT_OR_BLOCK_KEYS","FLATTENABLE_KEYS","FOR_INIT_KEYS","COMMENT_KEYS","LOGICAL_OPERATORS","UPDATE_OPERATORS","BOOLEAN_NUMBER_BINARY_OPERATORS","EQUALITY_BINARY_OPERATORS","COMPARISON_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","NUMBER_BINARY_OPERATORS","BINARY_OPERATORS","ASSIGNMENT_OPERATORS","op","BOOLEAN_UNARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","UNARY_OPERATORS","INHERIT_KEYS","optional","force","VISITOR_KEYS","NODE_FIELDS","BUILDER_KEYS","DEPRECATED_KEYS","NODE_PARENT_VALIDATIONS","NODE_UNION_SHAPES__PRIVATE","getType","val","validate","validateType","typeNames","assertNodeType","validateOptional","validateOptionalType","arrayOf","elementType","chain","assertValueType","assertEach","arrayOfType","validateArrayOfType","callback","childValidator","validateChild","validator","subKey","toString","v","each","assertOneOf","values","TypeError","JSON","stringify","oneOf","allExpandedTypes","types","expandedTypes","set","valType","oneOfNodeTypes","assertNodeOrValueType","primitiveType","oneOfNodeOrValueTypes","assertShape","shape","errors","validateField","error","message","shapeOf","assertOptionalChainStart","current","callee","fns","args","fn","chainOf","validTypeOpts","validFieldKeys","store","defineAliasedType","defined","inherits","additional","filter","a","unshift","defineType","fields","getOwnPropertyNames","field","def","default","deprecated","visitor","builder","k","deprecatedAlias","concat","forEach","alias","unionShape","classMethodOrPropertyUnionShapeCommon","allowPrivateName","discriminator","shapes","properties","elements","operator","assign","identifier","pattern","left","right","expression","inOp","directives","body","label","arguments","typeArguments","param","consequent","alternate","program","comments","tokens","init","update","functionCommon","params","generator","async","functionTypeAnnotationCommon","returnType","typeParameters","functionDeclarationCommon","declare","predicate","parent","patternLikeCommon","typeAnnotation","decorators","exec","parentKey","nonComp","computed","imported","isReservedWord","Number","isFinite","flags","invalid","normal","sourceType","interpreter","kind","shorthand","argument","listKey","index","expressions","discriminant","cases","block","handler","finalizer","declarations","withoutInit","constOrLetOrVar","usingOrAwaitUsing","parentIsForX","decl","definite","superClass","implements","mixins","abstract","importAttributes","attributes","source","exportKind","declaration","specifiers","sourced","sourceless","local","exported","lval","await","module","phase","importKind","options","classMethodOrPropertyCommon","accessibility","static","override","classMethodOrDeclareMethodCommon","access","tag","quasi","raw","cooked","templateElementCookedValidator","unterminatedCalled","str","firstInvalidLoc","readStringContents","unterminated","strictNumericEscape","invalidEscapeSequence","numericSeparatorInEscapeSequence","unexpectedNumericSeparator","invalidDigit","invalidCodePoint","tail","quasis","delegate","readonly","variance","defineInterfaceishType","extends","supertype","impltype","rest","this","indexers","callProperties","internalSlots","exact","inexact","method","proto","qualification","bound","explicitType","members","hasUnknownMembers","objectType","indexType","openingElement","closingElement","children","namespace","selfClosing","openingFragment","closingFragment","PLACEHOLDERS","Declaration","Pattern","PLACEHOLDERS_FLIPPED_ALIAS","hasOwn","bool","tSFunctionTypeAnnotationCommon","parameter","signatureDeclarationCommon","callConstructSignatureDeclaration","namedTypeElementCommon","parameters","tsKeywordTypes","fnOrCtrBase","typeName","parameterName","asserts","exprName","elementTypes","unionOrIntersection","checkType","extendsType","trueType","falseType","typeParameter","constraint","nameType","literal","unaryExpression","unaryOperator","TSTypeExpression","const","initializer","qualifier","moduleReference","in","out","DEPRECATED_ALIASES","ModuleDeclaration","TYPES","validateInternal","maybeNode","_validate","utils","arrayExpression","defs","ArrayExpression","assignmentExpression","AssignmentExpression","binaryExpression","BinaryExpression","interpreterDirective","InterpreterDirective","directive","Directive","directiveLiteral","DirectiveLiteral","blockStatement","BlockStatement","breakStatement","BreakStatement","callExpression","_arguments","CallExpression","catchClause","CatchClause","conditionalExpression","ConditionalExpression","continueStatement","ContinueStatement","debuggerStatement","doWhileStatement","DoWhileStatement","emptyStatement","expressionStatement","ExpressionStatement","file","File","forInStatement","ForInStatement","forStatement","ForStatement","functionDeclaration","FunctionDeclaration","functionExpression","FunctionExpression","Identifier","ifStatement","IfStatement","labeledStatement","LabeledStatement","stringLiteral","StringLiteral","numericLiteral","NumericLiteral","nullLiteral","booleanLiteral","BooleanLiteral","regExpLiteral","RegExpLiteral","logicalExpression","LogicalExpression","memberExpression","MemberExpression","newExpression","NewExpression","Program","objectExpression","ObjectExpression","objectMethod","ObjectMethod","objectProperty","ObjectProperty","restElement","RestElement","returnStatement","ReturnStatement","sequenceExpression","SequenceExpression","parenthesizedExpression","ParenthesizedExpression","switchCase","SwitchCase","switchStatement","SwitchStatement","thisExpression","throwStatement","ThrowStatement","tryStatement","TryStatement","UnaryExpression","updateExpression","UpdateExpression","variableDeclaration","VariableDeclaration","variableDeclarator","VariableDeclarator","whileStatement","WhileStatement","withStatement","WithStatement","assignmentPattern","AssignmentPattern","arrayPattern","ArrayPattern","arrowFunctionExpression","ArrowFunctionExpression","classBody","ClassBody","classExpression","ClassExpression","classDeclaration","ClassDeclaration","exportAllDeclaration","assertions","ExportAllDeclaration","exportDefaultDeclaration","ExportDefaultDeclaration","exportNamedDeclaration","ExportNamedDeclaration","exportSpecifier","ExportSpecifier","forOfStatement","_await","ForOfStatement","importDeclaration","ImportDeclaration","importDefaultSpecifier","ImportDefaultSpecifier","importNamespaceSpecifier","ImportNamespaceSpecifier","importSpecifier","ImportSpecifier","importExpression","ImportExpression","metaProperty","MetaProperty","classMethod","_static","ClassMethod","objectPattern","ObjectPattern","spreadElement","SpreadElement","_super","taggedTemplateExpression","TaggedTemplateExpression","templateElement","TemplateElement","templateLiteral","TemplateLiteral","yieldExpression","YieldExpression","awaitExpression","AwaitExpression","_import","bigIntLiteral","BigIntLiteral","exportNamespaceSpecifier","ExportNamespaceSpecifier","optionalMemberExpression","OptionalMemberExpression","optionalCallExpression","OptionalCallExpression","classProperty","ClassProperty","classAccessorProperty","ClassAccessorProperty","classPrivateProperty","ClassPrivateProperty","classPrivateMethod","ClassPrivateMethod","privateName","PrivateName","staticBlock","StaticBlock","importAttribute","ImportAttribute","anyTypeAnnotation","arrayTypeAnnotation","ArrayTypeAnnotation","booleanTypeAnnotation","booleanLiteralTypeAnnotation","BooleanLiteralTypeAnnotation","nullLiteralTypeAnnotation","classImplements","ClassImplements","declareClass","_extends","DeclareClass","declareFunction","DeclareFunction","declareInterface","DeclareInterface","declareModule","DeclareModule","declareModuleExports","DeclareModuleExports","declareTypeAlias","DeclareTypeAlias","declareOpaqueType","DeclareOpaqueType","declareVariable","DeclareVariable","declareExportDeclaration","DeclareExportDeclaration","declareExportAllDeclaration","DeclareExportAllDeclaration","declaredPredicate","DeclaredPredicate","existsTypeAnnotation","functionTypeAnnotation","FunctionTypeAnnotation","functionTypeParam","FunctionTypeParam","genericTypeAnnotation","GenericTypeAnnotation","inferredPredicate","interfaceExtends","InterfaceExtends","interfaceDeclaration","InterfaceDeclaration","interfaceTypeAnnotation","InterfaceTypeAnnotation","intersectionTypeAnnotation","IntersectionTypeAnnotation","mixedTypeAnnotation","emptyTypeAnnotation","nullableTypeAnnotation","NullableTypeAnnotation","numberLiteralTypeAnnotation","NumberLiteralTypeAnnotation","numberTypeAnnotation","objectTypeAnnotation","ObjectTypeAnnotation","objectTypeInternalSlot","ObjectTypeInternalSlot","objectTypeCallProperty","ObjectTypeCallProperty","objectTypeIndexer","ObjectTypeIndexer","objectTypeProperty","ObjectTypeProperty","objectTypeSpreadProperty","ObjectTypeSpreadProperty","opaqueType","OpaqueType","qualifiedTypeIdentifier","QualifiedTypeIdentifier","stringLiteralTypeAnnotation","StringLiteralTypeAnnotation","stringTypeAnnotation","symbolTypeAnnotation","thisTypeAnnotation","tupleTypeAnnotation","TupleTypeAnnotation","typeofTypeAnnotation","TypeofTypeAnnotation","typeAlias","TypeAlias","TypeAnnotation","typeCastExpression","TypeCastExpression","_default","TypeParameter","typeParameterDeclaration","TypeParameterDeclaration","typeParameterInstantiation","TypeParameterInstantiation","unionTypeAnnotation","UnionTypeAnnotation","Variance","voidTypeAnnotation","enumDeclaration","EnumDeclaration","enumBooleanBody","EnumBooleanBody","enumNumberBody","EnumNumberBody","enumStringBody","EnumStringBody","enumSymbolBody","EnumSymbolBody","enumBooleanMember","EnumBooleanMember","enumNumberMember","EnumNumberMember","enumStringMember","EnumStringMember","enumDefaultedMember","EnumDefaultedMember","indexedAccessType","IndexedAccessType","optionalIndexedAccessType","OptionalIndexedAccessType","jsxAttribute","JSXAttribute","jsxClosingElement","JSXClosingElement","jsxElement","JSXElement","jsxEmptyExpression","jsxExpressionContainer","JSXExpressionContainer","jsxSpreadChild","JSXSpreadChild","jsxIdentifier","JSXIdentifier","jsxMemberExpression","JSXMemberExpression","jsxNamespacedName","JSXNamespacedName","jsxOpeningElement","JSXOpeningElement","jsxSpreadAttribute","JSXSpreadAttribute","jsxText","JSXText","jsxFragment","JSXFragment","jsxOpeningFragment","jsxClosingFragment","placeholder","Placeholder","v8IntrinsicIdentifier","V8IntrinsicIdentifier","argumentPlaceholder","bindExpression","BindExpression","decorator","Decorator","doExpression","DoExpression","exportDefaultSpecifier","ExportDefaultSpecifier","moduleExpression","ModuleExpression","topicReference","pipelineTopicExpression","PipelineTopicExpression","pipelineBareFunction","PipelineBareFunction","pipelinePrimaryTopicReference","voidPattern","tsParameterProperty","TSParameterProperty","tsDeclareFunction","TSDeclareFunction","tsDeclareMethod","TSDeclareMethod","tsQualifiedName","TSQualifiedName","tsCallSignatureDeclaration","TSCallSignatureDeclaration","tsConstructSignatureDeclaration","TSConstructSignatureDeclaration","tsPropertySignature","TSPropertySignature","tsMethodSignature","TSMethodSignature","tsIndexSignature","TSIndexSignature","tsAnyKeyword","tsBooleanKeyword","tsBigIntKeyword","tsIntrinsicKeyword","tsNeverKeyword","tsNullKeyword","tsNumberKeyword","tsObjectKeyword","tsStringKeyword","tsSymbolKeyword","tsUndefinedKeyword","tsUnknownKeyword","tsVoidKeyword","tsThisType","tsFunctionType","TSFunctionType","tsConstructorType","TSConstructorType","tsTypeReference","TSTypeReference","tsTypePredicate","TSTypePredicate","tsTypeQuery","TSTypeQuery","tsTypeLiteral","TSTypeLiteral","tsArrayType","TSArrayType","tsTupleType","TSTupleType","tsOptionalType","TSOptionalType","tsRestType","TSRestType","tsNamedTupleMember","TSNamedTupleMember","tsUnionType","TSUnionType","tsIntersectionType","TSIntersectionType","tsConditionalType","TSConditionalType","tsInferType","TSInferType","tsParenthesizedType","TSParenthesizedType","tsTypeOperator","TSTypeOperator","tsIndexedAccessType","TSIndexedAccessType","tsMappedType","TSMappedType","tsTemplateLiteralType","TSTemplateLiteralType","tsLiteralType","TSLiteralType","tsClassImplements","TSClassImplements","tsInterfaceHeritage","TSInterfaceHeritage","tsInterfaceDeclaration","TSInterfaceDeclaration","tsInterfaceBody","TSInterfaceBody","tsTypeAliasDeclaration","TSTypeAliasDeclaration","tsInstantiationExpression","TSInstantiationExpression","tsAsExpression","TSAsExpression","tsSatisfiesExpression","TSSatisfiesExpression","tsTypeAssertion","TSTypeAssertion","tsEnumBody","TSEnumBody","tsEnumDeclaration","TSEnumDeclaration","tsEnumMember","TSEnumMember","tsModuleDeclaration","TSModuleDeclaration","tsModuleBlock","TSModuleBlock","tsImportType","TSImportType","tsImportEqualsDeclaration","TSImportEqualsDeclaration","tsExternalModuleReference","TSExternalModuleReference","tsNonNullExpression","TSNonNullExpression","tsExportAssignment","TSExportAssignment","tsNamespaceExportDeclaration","TSNamespaceExportDeclaration","tsTypeAnnotation","TSTypeAnnotation","tsTypeParameterInstantiation","TSTypeParameterInstantiation","tsTypeParameterDeclaration","TSTypeParameterDeclaration","tsTypeParameter","TSTypeParameter","NumberLiteral","RegexLiteral","RestProperty","SpreadProperty","lowercase","replace","x","toUpperCase","b","DebuggerStatement","EmptyStatement","NullLiteral","ThisExpression","Super","Import","AnyTypeAnnotation","BooleanTypeAnnotation","NullLiteralTypeAnnotation","ExistsTypeAnnotation","InferredPredicate","MixedTypeAnnotation","EmptyTypeAnnotation","NumberTypeAnnotation","StringTypeAnnotation","SymbolTypeAnnotation","ThisTypeAnnotation","VoidTypeAnnotation","JSXEmptyExpression","JSXOpeningFragment","JSXClosingFragment","ArgumentPlaceholder","TopicReference","PipelinePrimaryTopicReference","VoidPattern","TSAnyKeyword","TSBooleanKeyword","TSBigIntKeyword","TSIntrinsicKeyword","TSNeverKeyword","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSStringKeyword","TSSymbolKeyword","TSUndefinedKeyword","TSUnknownKeyword","TSVoidKeyword","TSThisType","cleanJSXElementLiteralChild","child","lines","lastNonEmptyLine","line","isFirstLine","isLastLine","isLastNonEmptyLine","trimmedLine","buildChildren","isNode","assertNode","assert","assertArrayExpression","assertAssignmentExpression","assertBinaryExpression","assertInterpreterDirective","assertDirective","assertDirectiveLiteral","assertBlockStatement","assertBreakStatement","assertCallExpression","assertCatchClause","assertConditionalExpression","assertContinueStatement","assertDebuggerStatement","assertDoWhileStatement","assertEmptyStatement","assertExpressionStatement","assertFile","assertForInStatement","assertForStatement","assertFunctionDeclaration","assertFunctionExpression","assertIdentifier","assertIfStatement","assertLabeledStatement","assertStringLiteral","assertNumericLiteral","assertNullLiteral","assertBooleanLiteral","assertRegExpLiteral","assertLogicalExpression","assertMemberExpression","assertNewExpression","assertProgram","assertObjectExpression","assertObjectMethod","assertObjectProperty","assertRestElement","assertReturnStatement","assertSequenceExpression","assertParenthesizedExpression","assertSwitchCase","assertSwitchStatement","assertThisExpression","assertThrowStatement","assertTryStatement","assertUnaryExpression","assertUpdateExpression","assertVariableDeclaration","assertVariableDeclarator","assertWhileStatement","assertWithStatement","assertAssignmentPattern","assertArrayPattern","assertArrowFunctionExpression","assertClassBody","assertClassExpression","assertClassDeclaration","assertExportAllDeclaration","assertExportDefaultDeclaration","assertExportNamedDeclaration","assertExportSpecifier","assertForOfStatement","assertImportDeclaration","assertImportDefaultSpecifier","assertImportNamespaceSpecifier","assertImportSpecifier","assertImportExpression","assertMetaProperty","assertClassMethod","assertObjectPattern","assertSpreadElement","assertSuper","assertTaggedTemplateExpression","assertTemplateElement","assertTemplateLiteral","assertYieldExpression","assertAwaitExpression","assertImport","assertBigIntLiteral","assertExportNamespaceSpecifier","assertOptionalMemberExpression","assertOptionalCallExpression","assertClassProperty","assertClassAccessorProperty","assertClassPrivateProperty","assertClassPrivateMethod","assertPrivateName","assertStaticBlock","assertImportAttribute","assertAnyTypeAnnotation","assertArrayTypeAnnotation","assertBooleanTypeAnnotation","assertBooleanLiteralTypeAnnotation","assertNullLiteralTypeAnnotation","assertClassImplements","assertDeclareClass","assertDeclareFunction","assertDeclareInterface","assertDeclareModule","assertDeclareModuleExports","assertDeclareTypeAlias","assertDeclareOpaqueType","assertDeclareVariable","assertDeclareExportDeclaration","assertDeclareExportAllDeclaration","assertDeclaredPredicate","assertExistsTypeAnnotation","assertFunctionTypeAnnotation","assertFunctionTypeParam","assertGenericTypeAnnotation","assertInferredPredicate","assertInterfaceExtends","assertInterfaceDeclaration","assertInterfaceTypeAnnotation","assertIntersectionTypeAnnotation","assertMixedTypeAnnotation","assertEmptyTypeAnnotation","assertNullableTypeAnnotation","assertNumberLiteralTypeAnnotation","assertNumberTypeAnnotation","assertObjectTypeAnnotation","assertObjectTypeInternalSlot","assertObjectTypeCallProperty","assertObjectTypeIndexer","assertObjectTypeProperty","assertObjectTypeSpreadProperty","assertOpaqueType","assertQualifiedTypeIdentifier","assertStringLiteralTypeAnnotation","assertStringTypeAnnotation","assertSymbolTypeAnnotation","assertThisTypeAnnotation","assertTupleTypeAnnotation","assertTypeofTypeAnnotation","assertTypeAlias","assertTypeAnnotation","assertTypeCastExpression","assertTypeParameter","assertTypeParameterDeclaration","assertTypeParameterInstantiation","assertUnionTypeAnnotation","assertVariance","assertVoidTypeAnnotation","assertEnumDeclaration","assertEnumBooleanBody","assertEnumNumberBody","assertEnumStringBody","assertEnumSymbolBody","assertEnumBooleanMember","assertEnumNumberMember","assertEnumStringMember","assertEnumDefaultedMember","assertIndexedAccessType","assertOptionalIndexedAccessType","assertJSXAttribute","assertJSXClosingElement","assertJSXElement","assertJSXEmptyExpression","assertJSXExpressionContainer","assertJSXSpreadChild","assertJSXIdentifier","assertJSXMemberExpression","assertJSXNamespacedName","assertJSXOpeningElement","assertJSXSpreadAttribute","assertJSXText","assertJSXFragment","assertJSXOpeningFragment","assertJSXClosingFragment","assertPlaceholder","assertV8IntrinsicIdentifier","assertArgumentPlaceholder","assertBindExpression","assertDecorator","assertDoExpression","assertExportDefaultSpecifier","assertModuleExpression","assertTopicReference","assertPipelineTopicExpression","assertPipelineBareFunction","assertPipelinePrimaryTopicReference","assertVoidPattern","assertTSParameterProperty","assertTSDeclareFunction","assertTSDeclareMethod","assertTSQualifiedName","assertTSCallSignatureDeclaration","assertTSConstructSignatureDeclaration","assertTSPropertySignature","assertTSMethodSignature","assertTSIndexSignature","assertTSAnyKeyword","assertTSBooleanKeyword","assertTSBigIntKeyword","assertTSIntrinsicKeyword","assertTSNeverKeyword","assertTSNullKeyword","assertTSNumberKeyword","assertTSObjectKeyword","assertTSStringKeyword","assertTSSymbolKeyword","assertTSUndefinedKeyword","assertTSUnknownKeyword","assertTSVoidKeyword","assertTSThisType","assertTSFunctionType","assertTSConstructorType","assertTSTypeReference","assertTSTypePredicate","assertTSTypeQuery","assertTSTypeLiteral","assertTSArrayType","assertTSTupleType","assertTSOptionalType","assertTSRestType","assertTSNamedTupleMember","assertTSUnionType","assertTSIntersectionType","assertTSConditionalType","assertTSInferType","assertTSParenthesizedType","assertTSTypeOperator","assertTSIndexedAccessType","assertTSMappedType","assertTSTemplateLiteralType","assertTSLiteralType","assertTSClassImplements","assertTSInterfaceHeritage","assertTSInterfaceDeclaration","assertTSInterfaceBody","assertTSTypeAliasDeclaration","assertTSInstantiationExpression","assertTSAsExpression","assertTSSatisfiesExpression","assertTSTypeAssertion","assertTSEnumBody","assertTSEnumDeclaration","assertTSEnumMember","assertTSModuleDeclaration","assertTSModuleBlock","assertTSImportType","assertTSImportEqualsDeclaration","assertTSExternalModuleReference","assertTSNonNullExpression","assertTSExportAssignment","assertTSNamespaceExportDeclaration","assertTSTypeAnnotation","assertTSTypeParameterInstantiation","assertTSTypeParameterDeclaration","assertTSTypeParameter","assertStandardized","assertExpression","assertBinary","assertScopable","assertBlockParent","assertBlock","assertStatement","assertTerminatorless","assertCompletionStatement","assertConditional","assertLoop","assertWhile","assertExpressionWrapper","assertFor","assertForXStatement","assertFunction","assertFunctionParent","assertPureish","assertDeclaration","assertFunctionParameter","assertPatternLike","assertLVal","assertTSEntityName","assertLiteral","assertImmutable","assertUserWhitespacable","assertMethod","assertObjectMember","assertProperty","assertUnaryLike","assertPattern","assertClass","assertImportOrExportDeclaration","assertExportDeclaration","assertModuleSpecifier","assertAccessor","assertPrivate","assertFlow","assertFlowType","assertFlowBaseAnnotation","assertFlowDeclaration","assertFlowPredicate","assertEnumBody","assertEnumMember","assertJSX","assertMiscellaneous","assertTypeScript","assertTSTypeElement","assertTSType","assertTSBaseType","assertNumberLiteral","assertRegexLiteral","assertRestProperty","assertSpreadProperty","assertModuleDeclaration","createTypeAnnotationBasedOnTypeof","getQualifiedName","removeTypeDuplicates","nodesIn","from","generics","Map","bases","typeGroups","existing","get","baseType","genericName","createFlowUnionType","flattened","typeArgumentsKey","existingTypeArguments","createTSUnionType","typeAnnotations","buildUndefinedNode","cloneIfNode","obj","deep","withoutLoc","commentsCache","cloneNodeInternal","cloneIfNodeOrArray","cloneNode","newNode","maybeCloneComments","loc","leadingComments","innerComments","trailingComments","extra","comment","cache","ret","clone","cloneDeep","cloneDeepWithoutLoc","cloneWithoutLoc","addComments","addComment","content","inherit","Boolean","inheritInnerComments","inheritLeadingComments","inheritTrailingComments","inheritsComments","removeComments","STANDARDIZED_TYPES","EXPRESSION_TYPES","BINARY_TYPES","SCOPABLE_TYPES","BLOCKPARENT_TYPES","BLOCK_TYPES","STATEMENT_TYPES","TERMINATORLESS_TYPES","COMPLETIONSTATEMENT_TYPES","CONDITIONAL_TYPES","LOOP_TYPES","WHILE_TYPES","EXPRESSIONWRAPPER_TYPES","FOR_TYPES","FORXSTATEMENT_TYPES","FUNCTION_TYPES","FUNCTIONPARENT_TYPES","PUREISH_TYPES","DECLARATION_TYPES","FUNCTIONPARAMETER_TYPES","PATTERNLIKE_TYPES","LVAL_TYPES","TSENTITYNAME_TYPES","LITERAL_TYPES","IMMUTABLE_TYPES","USERWHITESPACABLE_TYPES","METHOD_TYPES","OBJECTMEMBER_TYPES","PROPERTY_TYPES","UNARYLIKE_TYPES","PATTERN_TYPES","CLASS_TYPES","IMPORTOREXPORTDECLARATION_TYPES","EXPORTDECLARATION_TYPES","MODULESPECIFIER_TYPES","ACCESSOR_TYPES","PRIVATE_TYPES","FLOW_TYPES","FLOWTYPE_TYPES","FLOWBASEANNOTATION_TYPES","FLOWDECLARATION_TYPES","FLOWPREDICATE_TYPES","ENUMBODY_TYPES","ENUMMEMBER_TYPES","JSX_TYPES","MISCELLANEOUS_TYPES","TYPESCRIPT_TYPES","TSTYPEELEMENT_TYPES","TSTYPE_TYPES","TSBASETYPE_TYPES","MODULEDECLARATION_TYPES","toBlock","blockNodes","ensureBlock","result","toIdentifier","input","c","isIdentifierChar","codePointAt","toBindingIdentifierName","toComputedKey","toExpression","_skip","Symbol","_stop","traverseFast","enter","subNode","stop","CLEAR_KEYS","CLEAR_KEYS_PLUS_COMMENTS","removeProperties","preserveComments","startsWith","symbols","getOwnPropertySymbols","sym","removePropertiesDeep","tree","toKeyAlias","increment","uid","MAX_SAFE_INTEGER","toStatement","ignore","mustHaveId","newType","objectToString","Function","call","bind","prototype","isRegExp","isPlainObject","getPrototypeOf","valueToNode","Math","abs","numerator","isNaN","props","nodeKey","appendToMemberExpression","append","prependToMemberExpression","prepend","getAssignmentIdentifiers","search","ids","create","pop","getBindingIdentifiers","duplicates","outerOnly","newBindingsOnly","shift","_ids","getOuterBindingIdentifiers","getNameFromLiteralId","String","getObjectMemberKey","getFunctionName","originalNode","traverse","handlers","state","exit","traverseSimpleImpl","ancestors","isBinding","grandparent","isLet","isBlockScoped","isImmutable","isNodesEquivalent","visitorKeys","val_a","val_b","isReferenced","isScope","isSpecifierDefault","specifier","RESERVED_WORDS_ES3_ONLY","isValidES3Identifier","isVar","react"],"mappings":"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"}