{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["import type {\n  Aliases,\n  Args,\n  BooleanType,\n  Collectable,\n  NestedMapping,\n  ParseOptions,\n  StringType,\n  Values,\n} from \"./types.js\";\nexport { ParseOptions, Args } from \"./types.js\";\n\nconst BOOL_RE = /^(true|false)$/;\nconst QUOTED_RE = /^('|\").*\\1$/;\n\nconst set = (obj: NestedMapping, key: string, value: any, type?: string) => {\n  if (key.includes(\".\")) {\n    const parts = key.split(\".\");\n    for (let i = 0; i < parts.length - 1; i++) {\n      const k = parts[i];\n      const tmp = {};\n      set(obj, k, tmp);\n      obj = tmp;\n    }\n    key = parts[parts.length - 1];\n  }\n  if (type === \"array\" && obj[key] !== undefined) {\n    if (Array.isArray(obj[key])) {\n      (obj[key] as any[]).push(value);\n    } else {\n      obj[key] = [obj[key], value];\n    }\n  } else {\n    obj[key] = type === \"array\" ? [value] : value;\n  }\n};\n\nconst type = (\n  key: string,\n  opts: Record<\"boolean\" | \"string\" | \"array\", string[]>\n): \"boolean\" | \"string\" | \"array\" | undefined => {\n  if (opts.array && opts.array.length > 0 && opts.array.includes(key))\n    return \"array\";\n  if (opts.string && opts.string.length > 0 && opts.string.includes(key))\n    return \"string\";\n  if (opts.boolean && opts.boolean.length > 0 && opts.boolean.includes(key))\n    return \"boolean\";\n  return;\n};\n\nconst defaultValue = (type?: \"boolean\" | \"string\" | \"array\") => {\n  if (type === \"string\") return \"\";\n  if (type === \"array\") return [];\n  return true;\n};\n\nconst coerce = (value?: string, type?: \"string\" | \"boolean\" | \"array\") => {\n  if (type === \"string\") return value;\n  if (type === \"boolean\") return value === undefined ? true : value === 'true';\n\n  if (!value) return value;\n  if (value.length > 3 && BOOL_RE.test(value)) return value === \"true\";\n  if (value.length > 2 && QUOTED_RE.test(value)) return value.slice(1, -1);\n  if (value[0] === '.' && /\\d/.test(value[1]) || /\\d/.test(value[0])) return Number(value);\n  return value;\n};\n\nexport function parse<\n  TArgs extends Values<\n    TBooleans,\n    TStrings,\n    TCollectable,\n    undefined,\n    TDefaults,\n    TAliases\n  >,\n  TBooleans extends BooleanType = undefined,\n  TStrings extends StringType = undefined,\n  TCollectable extends Collectable = undefined,\n  TDefaults extends Record<string, unknown> | undefined = undefined,\n  TAliases extends Aliases<TAliasArgNames, TAliasNames> | undefined = undefined,\n  TAliasArgNames extends string = string,\n  TAliasNames extends string = string\n>(\n  argv: string[],\n  {\n    default: defaults,\n    alias: aliases,\n    ...types\n  }: ParseOptions<TBooleans, TStrings, TCollectable, TDefaults, TAliases> = {}\n): Args<TArgs> {\n  const obj = { ...defaults, _: [] } as unknown as Args<TArgs>;\n  if (argv.length === 0) return obj;\n\n  for (let i = 0; i < argv.length; i++) {\n    const curr = argv[i];\n    const next = argv[i + 1];\n\n    let t: 'string' | 'boolean' | 'array' | undefined;\n    let key = '';\n    let value: string | undefined;\n\n    if (curr.length > 1 && curr[0] === \"-\") {\n      if (curr[1] !== \"-\" && curr.length > 2 && !curr.includes('=')) {\n        if (curr.includes('.')) {\n          key = curr.slice(1, 2);\n          value = curr.slice(2);\n        } else {\n          const keys = curr.slice(1, -1);\n          for (let key of keys) {\n            if (aliases && (aliases as Record<string, any>)[key] !== undefined) {\n              key = aliases[key as keyof typeof aliases] as string;\n            }\n            set(obj, key, defaultValue(t), t)\n          }\n          key = curr.slice(-1)\n          if (next && next[0] !== '-') {\n            value = next;\n            i++;\n          }\n        }\n      } else if (!curr.includes(\"=\") && next && next[0] !== \"-\") {\n        key = curr.replace(/^-{1,2}/, '');\n        t = type(key, types as any);\n        // treat boolean as flag without parameter\n        if (t === 'boolean') {\n          value = 'true';\n        } else {\n          value = next;\n          i++;\n        }\n      } else {\n        const eq = curr.indexOf('=');\n        if (eq === -1) {\n          key = curr.replace(/^-{1,2}/, '');\n        } else {\n          key = curr.slice(0, eq).replace(/^-{1,2}/, '');\n          value = curr.slice(eq + 1);\n        }\n        t = type(key, types as any);\n      }\n\n      if ((!t || t === \"boolean\") && key.length > 3 && key.startsWith('no-')) {\n        set(obj, key.slice(3), false)\n      } else {\n        if (aliases && (aliases as Record<string, any>)[key] !== undefined) {\n          key = aliases[key as keyof typeof aliases] as string;\n        }\n        set(obj, key, coerce(value, t) ?? defaultValue(t), t)\n      }\n    } else if (curr) {\n      (obj as any)._.push(coerce(curr));\n      continue;\n    }\n  }\n\n  return obj;\n}\n"],
  "mappings": "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",
  "names": ["BOOL_RE", "QUOTED_RE", "set", "obj", "key", "value", "type", "parts", "i", "k", "tmp", "opts", "defaultValue", "coerce", "parse", "argv", "defaults", "aliases", "types", "curr", "next", "t", "keys", "eq"]
}
