{"version":3,"file":"index.js","sources":["../src/source-map.ts","../src/buffer.ts","../src/node/whitespace.ts","../src/node/parentheses.ts","../src/node/index.ts","../src/token-map.ts","../src/generators/template-literals.ts","../src/generators/expressions.ts","../src/generators/statements.ts","../src/generators/classes.ts","../src/generators/methods.ts","../src/generators/modules.ts","../src/generators/types.ts","../src/generators/flow.ts","../src/generators/base.ts","../src/generators/jsx.ts","../src/generators/typescript.ts","../src/printer.ts","../src/index.ts"],"sourcesContent":["import {\n  GenMapping,\n  maybeAddMapping,\n  setSourceContent,\n  allMappings,\n  toEncodedMap,\n  toDecodedMap,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\nimport type {\n  InvalidOriginalMapping,\n  OriginalMapping,\n  SourceMapInput,\n} from \"@jridgewell/trace-mapping\";\nimport { originalPositionFor, TraceMap } from \"@jridgewell/trace-mapping\";\n\n/**\n * Build a sourcemap.\n */\n\nexport default class SourceMap {\n  private _map: GenMapping;\n  private _rawMappings: Mapping[] | undefined;\n  private _sourceFileName: string | undefined;\n\n  // Any real line is > 0, so init to 0 is fine.\n  private _lastGenLine = 0;\n  private _lastSourceLine = 0;\n\n  // Source columns can be 0, but we only check in unison with sourceLine, which\n  // inits to an impossible value. So init to 0 is fine.\n  private _lastSourceColumn = 0;\n\n  public _inputMap: TraceMap | null = null;\n\n  constructor(\n    opts: {\n      sourceFileName?: string;\n      sourceRoot?: string;\n      inputSourceMap?: SourceMapInput;\n    },\n    code: string | Record<string, string> | null | undefined,\n  ) {\n    const map = (this._map = new GenMapping({ sourceRoot: opts.sourceRoot }));\n    this._sourceFileName = opts.sourceFileName?.replace(/\\\\/g, \"/\");\n    this._rawMappings = undefined;\n\n    if (opts.inputSourceMap) {\n      this._inputMap = new TraceMap(opts.inputSourceMap);\n      const resolvedSources = this._inputMap.resolvedSources;\n      if (resolvedSources.length) {\n        for (let i = 0; i < resolvedSources.length; i++) {\n          setSourceContent(\n            map,\n            resolvedSources[i],\n            // @ts-expect-error FIXME: this._inputMap.sourcesContent?.[i] may be undefined, which is not acceptable by setSourceContent\n            this._inputMap.sourcesContent?.[i],\n          );\n        }\n      }\n    }\n\n    if (typeof code === \"string\" && !opts.inputSourceMap) {\n      setSourceContent(map, this._sourceFileName!, code);\n    } else if (typeof code === \"object\") {\n      for (const sourceFileName of Object.keys(code!)) {\n        setSourceContent(\n          map,\n          sourceFileName.replace(/\\\\/g, \"/\"),\n          code![sourceFileName],\n        );\n      }\n    }\n  }\n\n  /**\n   * Get the sourcemap.\n   */\n  get(): EncodedSourceMap {\n    return toEncodedMap(this._map);\n  }\n\n  getDecoded(): DecodedSourceMap {\n    return toDecodedMap(this._map);\n  }\n\n  getRawMappings(): Mapping[] {\n    return (this._rawMappings ||= allMappings(this._map));\n  }\n\n  /**\n   * Mark the current generated position with a source position. May also be passed null line/column\n   * values to insert a mapping to nothing.\n   */\n\n  mark(\n    generated: { line: number; column: number },\n    line: number | undefined,\n    column: number | undefined,\n    identifierName?: string | null,\n    identifierNamePos?: { line: number; column: number },\n    filename?: string | null,\n  ) {\n    this._rawMappings = undefined;\n\n    let originalMapping: OriginalMapping | InvalidOriginalMapping | undefined;\n\n    if (line != null) {\n      if (this._inputMap) {\n        // This is the lookup for this mark\n        originalMapping = originalPositionFor(this._inputMap, {\n          line,\n          column: column!,\n        });\n\n        // If the we found a name, nothing else needs to be done\n        // Maybe we're marking a `(` and the input map already had a name attached there,\n        // or we're marking a `(` and the sourcemap spanned a `foo(`,\n        // or we're marking an identifier, etc.\n        if (!originalMapping.name && identifierNamePos) {\n          // We're trying to mark a `(` (as that's the only thing that provides\n          // an identifierNamePos currently), and we the AST had an identifier attached.\n          // Lookup it's original name.\n          const originalIdentifierMapping = originalPositionFor(\n            this._inputMap,\n            identifierNamePos,\n          );\n          if (originalIdentifierMapping.name) {\n            identifierName = originalIdentifierMapping.name;\n          }\n        }\n      } else {\n        originalMapping = {\n          name: null,\n          source: filename?.replace(/\\\\/g, \"/\") || this._sourceFileName!,\n          line: line,\n          column: column!,\n        };\n      }\n    }\n\n    // @ts-expect-error FIXME: original cannot be InvalidOriginalMapping\n    maybeAddMapping(this._map, {\n      name: identifierName,\n      generated,\n      source: originalMapping?.source,\n      original: originalMapping,\n    });\n  }\n}\n","import type SourceMap from \"./source-map.ts\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charcodes from \"charcodes\";\n\nexport type Pos = {\n  line: number;\n  column: number;\n  index: number;\n};\nexport type Loc = {\n  start?: Pos;\n  end?: Pos;\n  filename?: string;\n};\ntype SourcePos = {\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: string | undefined;\n  filename: string | undefined;\n};\ntype InternalSourcePos = SourcePos & { identifierNamePos: Pos | undefined };\n\ntype QueueItem = {\n  char: number;\n  repeat: number;\n  line: number | undefined;\n  column: number | undefined;\n  identifierName: undefined; // Not used, it always undefined.\n  identifierNamePos: undefined; // Not used, it always undefined.\n  filename: string | undefined;\n};\n\nexport default class Buffer {\n  constructor(map: SourceMap | null, indentChar: string) {\n    this._map = map;\n    this._indentChar = indentChar;\n\n    for (let i = 0; i < 64; i++) {\n      this._fastIndentations.push(indentChar.repeat(i));\n    }\n\n    this._allocQueue();\n  }\n\n  _map: SourceMap | null = null;\n  _buf = \"\";\n  _str = \"\";\n  _appendCount = 0;\n  _last = 0;\n  _queue: QueueItem[] = [];\n  _queueCursor = 0;\n  _canMarkIdName = true;\n  _indentChar = \"\";\n  _fastIndentations: string[] = [];\n\n  _position = {\n    line: 1,\n    column: 0,\n  };\n  _sourcePosition: InternalSourcePos = {\n    identifierName: undefined,\n    identifierNamePos: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined,\n  };\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        identifierNamePos: undefined,\n        filename: \"\",\n      });\n    }\n  }\n\n  _pushQueue(\n    char: number,\n    repeat: number,\n    line: number | undefined,\n    column: number | undefined,\n    filename: string | undefined,\n  ) {\n    const cursor = this._queueCursor;\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.filename = filename;\n\n    this._queueCursor++;\n  }\n\n  _popQueue(): QueueItem {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n    return this._queue[--this._queueCursor];\n  }\n\n  /**\n   * Get the final string output from the buffer, along with the sourcemap if one exists.\n   */\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      // Whatever trim is used here should not execute a regex against the\n      // source string since it may be arbitrarily large after all transformations\n      code: (this._buf + this._str).trimRight(),\n      // Decoded sourcemap is free to generate.\n      decodedMap: map?.getDecoded(),\n      // Used as a marker for backwards compatibility. We moved input map merging\n      // into the generator. We cannot merge the input map a second time, so the\n      // presence of this field tells us we've already done the work.\n      get __mergedMap() {\n        return this.map;\n      },\n      // Encoding the sourcemap is moderately CPU expensive.\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n      set map(value) {\n        Object.defineProperty(result, \"map\", { value, writable: true });\n      },\n      // Retrieving the raw mappings is very memory intensive.\n      get rawMappings() {\n        const mappings = map?.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", { value, writable: true });\n      },\n    };\n\n    return result;\n  }\n\n  /**\n   * Add a string to the buffer that cannot be reverted.\n   */\n\n  append(str: string, maybeNewline: boolean): void {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char: number): void {\n    this._flush();\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  /**\n   * Add a string to the buffer than can be reverted.\n   */\n  queue(char: number): void {\n    // Drop trailing spaces when a newline is inserted.\n    if (char === charcodes.lineFeed) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n        if (char !== charcodes.space && char !== charcodes.tab) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n    this._pushQueue(\n      char,\n      1,\n      sourcePosition.line,\n      sourcePosition.column,\n      sourcePosition.filename,\n    );\n  }\n\n  /**\n   * Same as queue, but this indentation will never have a sourcemap marker.\n   */\n  queueIndentation(repeat: number): void {\n    if (repeat === 0) return;\n    this._pushQueue(-1, repeat, undefined, undefined, undefined);\n  }\n\n  _flush(): void {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n    for (let i = 0; i < queueCursor; i++) {\n      const item: QueueItem = queue[i];\n      this._appendChar(item.char, item.repeat, item);\n    }\n    this._queueCursor = 0;\n  }\n\n  _appendChar(\n    char: number,\n    repeat: number,\n    sourcePos: InternalSourcePos,\n  ): void {\n    this._last = char;\n\n    if (char === -1) {\n      const fastIndentation = this._fastIndentations[repeat];\n      if (fastIndentation !== undefined) {\n        this._str += fastIndentation;\n      } else {\n        this._str +=\n          repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;\n      }\n    } else {\n      this._str +=\n        repeat > 1\n          ? String.fromCharCode(char).repeat(repeat)\n          : String.fromCharCode(char);\n    }\n\n    if (char !== charcodes.lineFeed) {\n      this._mark(\n        sourcePos.line,\n        sourcePos.column,\n        sourcePos.identifierName,\n        sourcePos.identifierNamePos,\n        sourcePos.filename,\n      );\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n\n    if (this._canMarkIdName) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n  }\n\n  _append(\n    str: string,\n    sourcePos: InternalSourcePos,\n    maybeNewline: boolean,\n  ): void {\n    const len = str.length;\n    const position = this._position;\n\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n      +this._str; // Unexplainable huge performance boost. Ref: https://github.com/davidmarkclements/flatstr License: MIT\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      position.column += len;\n      return;\n    }\n\n    const { column, identifierName, identifierNamePos, filename } = sourcePos;\n    let line = sourcePos.line;\n\n    if (\n      (identifierName != null || identifierNamePos != null) &&\n      this._canMarkIdName\n    ) {\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n\n    // Search for newline chars. We search only for `\\n`, since both `\\r` and\n    // `\\r\\n` are normalized to `\\n` during parse. We exclude `\\u2028` and\n    // `\\u2029` for performance reasons, they're so uncommon that it's probably\n    // ok. It's also unclear how other sourcemap utilities handle them...\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    // If the string starts with a newline char, then adding a mark is redundant.\n    // This catches both \"no newlines\" and \"newline after several chars\".\n    if (i !== 0) {\n      this._mark(line, column, identifierName, identifierNamePos, filename);\n    }\n\n    // Now, find each remaining newline char in the string.\n    while (i !== -1) {\n      position.line++;\n      position.column = 0;\n      last = i + 1;\n\n      // We mark the start of each line, which happens directly after this newline char\n      // unless this is the last char.\n      // When manually adding multi-line content (such as a comment), `line` will be `undefined`.\n      if (last < len && line !== undefined) {\n        this._mark(++line, 0, undefined, undefined, filename);\n      }\n      i = str.indexOf(\"\\n\", last);\n    }\n    position.column += len - last;\n  }\n\n  _mark(\n    line: number | undefined,\n    column: number | undefined,\n    identifierName: string | undefined,\n    identifierNamePos: Pos | undefined,\n    filename: string | undefined,\n  ): void {\n    this._map?.mark(\n      this._position,\n      line,\n      column,\n      identifierName,\n      identifierNamePos,\n      filename,\n    );\n  }\n\n  removeTrailingNewline(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.lineFeed\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon(): void {\n    const queueCursor = this._queueCursor;\n    if (\n      queueCursor !== 0 &&\n      this._queue[queueCursor - 1].char === charcodes.semicolon\n    ) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar(): number {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  /**\n   * This will only detect at most 1 newline after a call to `flush()`,\n   * but this has not been found so far, and an accurate count can be achieved if needed later.\n   */\n  getNewlineCount(): number {\n    const queueCursor = this._queueCursor;\n    let count = 0;\n    if (queueCursor === 0) return this._last === charcodes.lineFeed ? 1 : 0;\n    for (let i = queueCursor - 1; i >= 0; i--) {\n      if (this._queue[i].char !== charcodes.lineFeed) {\n        break;\n      }\n      count++;\n    }\n    return count === queueCursor && this._last === charcodes.lineFeed\n      ? count + 1\n      : count;\n  }\n\n  /**\n   * check if current _last + queue ends with newline, return the character before newline\n   */\n  endsWithCharAndNewline(): number | undefined {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n    if (queueCursor !== 0) {\n      // every element in queue is one-length whitespace string\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== charcodes.lineFeed) return;\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n    // We assume that everything being matched is at most a single token plus some whitespace,\n    // which everything currently is, but otherwise we'd have to expand _last or check _buf.\n  }\n\n  hasContent(): boolean {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  /**\n   * Certain sourcemap usecases expect mappings to be more accurate than\n   * Babel's generic sourcemap handling allows. For now, we special-case\n   * identifiers to allow for the primary cases to work.\n   * The goal of this line is to ensure that the map output from Babel will\n   * have an exact range on identifiers in the output code. Without this\n   * line, Babel would potentially include some number of trailing tokens\n   * that are printed after the identifier, but before another location has\n   * been assigned.\n   * This allows tooling like Rollup and Webpack to more accurately perform\n   * their own transformations. Most importantly, this allows the import/export\n   * transformations performed by those tools to loose less information when\n   * applying their own transformations on top of the code and map results\n   * generated by Babel itself.\n   *\n   * The primary example of this is the snippet:\n   *\n   *   import mod from \"mod\";\n   *   mod();\n   *\n   * With this line, there will be one mapping range over \"mod\" and another\n   * over \"();\", where previously it would have been a single mapping.\n   */\n  exactSource(loc: Loc, cb: () => void) {\n    if (!this._map) {\n      cb();\n      return;\n    }\n\n    this.source(\"start\", loc);\n    // @ts-expect-error identifierName is not defined\n    const identifierName = loc.identifierName;\n    const sourcePos = this._sourcePosition;\n    if (identifierName) {\n      this._canMarkIdName = false;\n      sourcePos.identifierName = identifierName;\n    }\n    cb();\n\n    if (identifierName) {\n      this._canMarkIdName = true;\n      sourcePos.identifierName = undefined;\n      sourcePos.identifierNamePos = undefined;\n    }\n    this.source(\"end\", loc);\n  }\n\n  /**\n   * Sets a given position as the current source location so generated code after this call\n   * will be given this position in the sourcemap.\n   */\n\n  source(prop: \"start\" | \"end\", loc: Loc): void {\n    if (!this._map) return;\n\n    // Since this is called extremely often, we reuse the same _sourcePosition\n    // object for the whole lifetime of the buffer.\n    this._normalizePosition(prop, loc, 0);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc,\n    columnOffset: number,\n  ): void {\n    if (!this._map) return;\n\n    this._normalizePosition(prop, loc, columnOffset);\n  }\n\n  _normalizePosition(prop: \"start\" | \"end\", loc: Loc, columnOffset: number) {\n    const pos = loc[prop];\n    const target = this._sourcePosition;\n\n    if (pos) {\n      target.line = pos.line;\n      // TODO: Fix https://github.com/babel/babel/issues/15712 in downstream\n      target.column = Math.max(pos.column + columnOffset, 0);\n      target.filename = loc.filename;\n    }\n  }\n\n  getCurrentColumn(): number {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    let lastIndex = -1;\n    let len = 0;\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n      if (item.char === charcodes.lineFeed) {\n        lastIndex = len;\n      }\n      len += item.repeat;\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine(): number {\n    let count = 0;\n\n    const queue = this._queue;\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === charcodes.lineFeed) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n}\n","import {\n  FLIPPED_ALIAS_KEYS,\n  isArrayExpression,\n  isAssignmentExpression,\n  isBinary,\n  isBlockStatement,\n  isCallExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isMemberExpression,\n  isObjectExpression,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isStringLiteral,\n} from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nimport type { NodeHandlers } from \"./index.ts\";\n\nimport type * as t from \"@babel/types\";\n\nconst enum WhitespaceFlag {\n  none = 0,\n  before = 1 << 0,\n  after = 1 << 1,\n}\n\nexport type { WhitespaceFlag };\n\nfunction crawlInternal(\n  node: t.Node,\n  state: { hasCall: boolean; hasFunction: boolean; hasHelper: boolean },\n) {\n  if (!node) return state;\n\n  if (isMemberExpression(node) || isOptionalMemberExpression(node)) {\n    crawlInternal(node.object, state);\n    if (node.computed) crawlInternal(node.property, state);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    crawlInternal(node.left, state);\n    crawlInternal(node.right, state);\n  } else if (isCallExpression(node) || isOptionalCallExpression(node)) {\n    state.hasCall = true;\n    crawlInternal(node.callee, state);\n  } else if (isFunction(node)) {\n    state.hasFunction = true;\n  } else if (isIdentifier(node)) {\n    state.hasHelper =\n      // @ts-expect-error todo(flow->ts): node.callee is not really expected hereâ€¦\n      state.hasHelper || (node.callee && isHelper(node.callee));\n  }\n\n  return state;\n}\n\n/**\n * Crawl a node to test if it contains a CallExpression, a Function, or a Helper.\n *\n * @example\n * crawl(node)\n * // { hasCall: false, hasFunction: true, hasHelper: false }\n */\n\nfunction crawl(node: t.Node) {\n  return crawlInternal(node, {\n    hasCall: false,\n    hasFunction: false,\n    hasHelper: false,\n  });\n}\n\n/**\n * Test if a node is or has a helper.\n */\n\nfunction isHelper(node: t.Node): boolean {\n  if (!node) return false;\n\n  if (isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (isIdentifier(node)) {\n    return (\n      node.name === \"require\" ||\n      node.name.charCodeAt(0) === charCodes.underscore\n    );\n  } else if (isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (isBinary(node) || isAssignmentExpression(node)) {\n    return (\n      (isIdentifier(node.left) && isHelper(node.left)) || isHelper(node.right)\n    );\n  } else {\n    return false;\n  }\n}\n\nfunction isType(node: t.Node | null | undefined) {\n  return (\n    isLiteral(node) ||\n    isObjectExpression(node) ||\n    isArrayExpression(node) ||\n    isIdentifier(node) ||\n    isMemberExpression(node)\n  );\n}\n\n/**\n * Tests for node types that need whitespace.\n */\n\nexport const nodes: NodeHandlers<WhitespaceFlag> = {\n  /**\n   * Test if AssignmentExpression needs whitespace.\n   */\n\n  AssignmentExpression(node: t.AssignmentExpression): WhitespaceFlag {\n    const state = crawl(node.right);\n    if ((state.hasCall && state.hasHelper) || state.hasFunction) {\n      return state.hasFunction\n        ? WhitespaceFlag.before | WhitespaceFlag.after\n        : WhitespaceFlag.after;\n    }\n    return WhitespaceFlag.none;\n  },\n\n  /**\n   * Test if SwitchCase needs whitespace.\n   */\n\n  SwitchCase(node: t.SwitchCase, parent: t.SwitchStatement): WhitespaceFlag {\n    return (\n      (!!node.consequent.length || parent.cases[0] === node\n        ? WhitespaceFlag.before\n        : WhitespaceFlag.none) |\n      (!node.consequent.length && parent.cases[parent.cases.length - 1] === node\n        ? WhitespaceFlag.after\n        : WhitespaceFlag.none)\n    );\n  },\n\n  /**\n   * Test if LogicalExpression needs whitespace.\n   */\n\n  LogicalExpression(node: t.LogicalExpression): WhitespaceFlag {\n    if (isFunction(node.left) || isFunction(node.right)) {\n      return WhitespaceFlag.after;\n    }\n    return WhitespaceFlag.none;\n  },\n\n  /**\n   * Test if Literal needs whitespace.\n   */\n\n  Literal(node: t.Literal): WhitespaceFlag {\n    if (isStringLiteral(node) && node.value === \"use strict\") {\n      return WhitespaceFlag.after;\n    }\n    return WhitespaceFlag.none;\n  },\n\n  /**\n   * Test if CallExpressionish needs whitespace.\n   */\n\n  CallExpression(node: t.CallExpression): WhitespaceFlag {\n    if (isFunction(node.callee) || isHelper(node)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n    return WhitespaceFlag.none;\n  },\n\n  OptionalCallExpression(node: t.OptionalCallExpression): WhitespaceFlag {\n    if (isFunction(node.callee)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n    return WhitespaceFlag.none;\n  },\n\n  /**\n   * Test if VariableDeclaration needs whitespace.\n   */\n\n  VariableDeclaration(node: t.VariableDeclaration): WhitespaceFlag {\n    for (let i = 0; i < node.declarations.length; i++) {\n      const declar = node.declarations[i];\n\n      let enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled && declar.init) {\n        const state = crawl(declar.init);\n        enabled = (isHelper(declar.init) && state.hasCall) || state.hasFunction;\n      }\n\n      if (enabled) {\n        return WhitespaceFlag.before | WhitespaceFlag.after;\n      }\n    }\n    return WhitespaceFlag.none;\n  },\n\n  /**\n   * Test if IfStatement needs whitespace.\n   */\n\n  IfStatement(node: t.IfStatement): WhitespaceFlag {\n    if (isBlockStatement(node.consequent)) {\n      return WhitespaceFlag.before | WhitespaceFlag.after;\n    }\n    return WhitespaceFlag.none;\n  },\n};\n\n/**\n * Test if Property needs whitespace.\n */\n\nnodes.ObjectProperty =\n  nodes.ObjectTypeProperty =\n  nodes.ObjectMethod =\n    function (\n      node: t.ObjectProperty | t.ObjectTypeProperty | t.ObjectMethod,\n      parent: t.ObjectExpression,\n    ): WhitespaceFlag {\n      if (parent.properties[0] === node) {\n        return WhitespaceFlag.before;\n      }\n      return WhitespaceFlag.none;\n    };\n\nnodes.ObjectTypeCallProperty = function (\n  node: t.ObjectTypeCallProperty,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (parent.callProperties[0] === node && !parent.properties?.length) {\n    return WhitespaceFlag.before;\n  }\n  return WhitespaceFlag.none;\n};\n\nnodes.ObjectTypeIndexer = function (\n  node: t.ObjectTypeIndexer,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.indexers[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n  return WhitespaceFlag.none;\n};\n\nnodes.ObjectTypeInternalSlot = function (\n  node: t.ObjectTypeInternalSlot,\n  parent: t.ObjectTypeAnnotation,\n): WhitespaceFlag {\n  if (\n    parent.internalSlots[0] === node &&\n    !parent.properties?.length &&\n    !parent.callProperties?.length &&\n    !parent.indexers?.length\n  ) {\n    return WhitespaceFlag.before;\n  }\n  return WhitespaceFlag.none;\n};\n\n/**\n * Add whitespace tests for nodes and their aliases.\n */\n\n(\n  [\n    [\"Function\", true],\n    [\"Class\", true],\n    [\"Loop\", true],\n    [\"LabeledStatement\", true],\n    [\"SwitchStatement\", true],\n    [\"TryStatement\", true],\n  ] as const\n).forEach(function ([type, amounts]) {\n  [type as string]\n    .concat(FLIPPED_ALIAS_KEYS[type] || [])\n    .forEach(function (type) {\n      const ret = amounts ? WhitespaceFlag.before | WhitespaceFlag.after : 0;\n      nodes[type] = () => ret;\n    });\n});\n","import {\n  isArrayTypeAnnotation,\n  isBinaryExpression,\n  isCallExpression,\n  isForOfStatement,\n  isIndexedAccessType,\n  isMemberExpression,\n  isObjectPattern,\n  isOptionalMemberExpression,\n  isYieldExpression,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport { TokenContext } from \"./index.ts\";\n\nconst PRECEDENCE = new Map([\n  [\"||\", 0],\n  [\"??\", 0],\n  [\"|>\", 0],\n  [\"&&\", 1],\n  [\"|\", 2],\n  [\"^\", 3],\n  [\"&\", 4],\n  [\"==\", 5],\n  [\"===\", 5],\n  [\"!=\", 5],\n  [\"!==\", 5],\n  [\"<\", 6],\n  [\">\", 6],\n  [\"<=\", 6],\n  [\">=\", 6],\n  [\"in\", 6],\n  [\"instanceof\", 6],\n  [\">>\", 7],\n  [\"<<\", 7],\n  [\">>>\", 7],\n  [\"+\", 8],\n  [\"-\", 8],\n  [\"*\", 9],\n  [\"/\", 9],\n  [\"%\", 9],\n  [\"**\", 10],\n]);\n\nfunction getBinaryPrecedence(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  nodeType: string,\n): number;\nfunction getBinaryPrecedence(\n  node: t.Node,\n  nodeType: string,\n): number | undefined;\nfunction getBinaryPrecedence(node: t.Node, nodeType: string) {\n  if (nodeType === \"BinaryExpression\" || nodeType === \"LogicalExpression\") {\n    return PRECEDENCE.get((node as t.Binary).operator);\n  }\n  if (nodeType === \"TSAsExpression\" || nodeType === \"TSSatisfiesExpression\") {\n    return PRECEDENCE.get(\"in\");\n  }\n}\n\nfunction isTSTypeExpression(nodeType: string) {\n  return (\n    nodeType === \"TSAsExpression\" ||\n    nodeType === \"TSSatisfiesExpression\" ||\n    nodeType === \"TSTypeAssertion\"\n  );\n}\n\nconst isClassExtendsClause = (\n  node: t.Node,\n  parent: t.Node,\n): parent is t.Class => {\n  const parentType = parent.type;\n  return (\n    (parentType === \"ClassDeclaration\" || parentType === \"ClassExpression\") &&\n    parent.superClass === node\n  );\n};\n\nconst hasPostfixPart = (node: t.Node, parent: t.Node) => {\n  const parentType = parent.type;\n  return (\n    ((parentType === \"MemberExpression\" ||\n      parentType === \"OptionalMemberExpression\") &&\n      parent.object === node) ||\n    ((parentType === \"CallExpression\" ||\n      parentType === \"OptionalCallExpression\" ||\n      parentType === \"NewExpression\") &&\n      parent.callee === node) ||\n    (parentType === \"TaggedTemplateExpression\" && parent.tag === node) ||\n    parentType === \"TSNonNullExpression\"\n  );\n};\n\nexport function NullableTypeAnnotation(\n  node: t.NullableTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  return isArrayTypeAnnotation(parent);\n}\n\nexport function FunctionTypeAnnotation(\n  node: t.FunctionTypeAnnotation,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  const parentType = parent.type;\n  return (\n    // (() => A) | (() => B)\n    parentType === \"UnionTypeAnnotation\" ||\n    // (() => A) & (() => B)\n    parentType === \"IntersectionTypeAnnotation\" ||\n    // (() => A)[]\n    parentType === \"ArrayTypeAnnotation\" ||\n    Boolean(tokenContext & TokenContext.arrowFlowReturnType)\n  );\n}\n\nexport function UpdateExpression(\n  node: t.UpdateExpression,\n  parent: t.Node,\n): boolean {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction needsParenBeforeExpressionBrace(tokenContext: number) {\n  return Boolean(\n    tokenContext & (TokenContext.expressionStatement | TokenContext.arrowBody),\n  );\n}\n\nexport function ObjectExpression(\n  node: t.ObjectExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return needsParenBeforeExpressionBrace(tokenContext);\n}\n\nexport function DoExpression(\n  node: t.DoExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  // `async do` can start an expression statement\n  return (\n    !node.async && Boolean(tokenContext & TokenContext.expressionStatement)\n  );\n}\n\nexport function Binary(\n  node: t.Binary | t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: t.Node,\n): boolean | undefined {\n  const parentType = parent.type;\n  if (\n    node.type === \"BinaryExpression\" &&\n    node.operator === \"**\" &&\n    parentType === \"BinaryExpression\" &&\n    parent.operator === \"**\"\n  ) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (\n    hasPostfixPart(node, parent) ||\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    parentType === \"AwaitExpression\"\n  ) {\n    return true;\n  }\n\n  const parentPos = getBinaryPrecedence(parent, parentType);\n  if (parentPos != null) {\n    const nodePos = getBinaryPrecedence(node, node.type);\n    if (\n      // Logical expressions with the same precedence don't need parens.\n      (parentPos === nodePos &&\n        parentType === \"BinaryExpression\" &&\n        parent.right === node) ||\n      parentPos > nodePos\n    ) {\n      return true;\n    }\n  }\n}\n\nexport function UnionTypeAnnotation(\n  node: t.UnionTypeAnnotation,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"ArrayTypeAnnotation\" ||\n    parentType === \"NullableTypeAnnotation\" ||\n    parentType === \"IntersectionTypeAnnotation\" ||\n    parentType === \"UnionTypeAnnotation\"\n  );\n}\n\nexport { UnionTypeAnnotation as IntersectionTypeAnnotation };\n\nexport function OptionalIndexedAccessType(\n  node: t.OptionalIndexedAccessType,\n  parent: t.Node,\n): boolean {\n  return isIndexedAccessType(parent) && parent.objectType === node;\n}\n\nexport function TSAsExpression(\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n  parent: t.Node,\n): boolean | undefined {\n  if (\n    (parent.type === \"AssignmentExpression\" ||\n      parent.type === \"AssignmentPattern\") &&\n    parent.left === node\n  ) {\n    return true;\n  }\n  if (\n    parent.type === \"BinaryExpression\" &&\n    (parent.operator === \"|\" || parent.operator === \"&\") &&\n    node === parent.left\n  ) {\n    return true;\n  }\n  return Binary(node, parent);\n}\n\nexport { TSAsExpression as TSSatisfiesExpression };\n\nexport { UnaryLike as TSTypeAssertion };\n\nexport function TSConditionalType(\n  node: t.TSConditionalType,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\" ||\n    parentType === \"TSTypeOperator\" ||\n    // for `infer K extends (L extends M ? M : ...)`\n    parentType === \"TSTypeParameter\"\n  ) {\n    return true;\n  }\n  if (\n    (parentType === \"TSIntersectionType\" || parentType === \"TSUnionType\") &&\n    parent.types[0] === node\n  ) {\n    return true;\n  }\n  if (\n    parentType === \"TSConditionalType\" &&\n    (parent.checkType === node || parent.extendsType === node)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function TSUnionType(node: t.TSUnionType, parent: t.Node): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSIntersectionType\" ||\n    parentType === \"TSTypeOperator\" ||\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\"\n  );\n}\n\nexport function TSIntersectionType(\n  node: t.TSUnionType,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSTypeOperator\" ||\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\"\n  );\n}\n\nexport function TSInferType(node: t.TSInferType, parent: t.Node): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\"\n  ) {\n    return true;\n  }\n  if (node.typeParameter.constraint) {\n    if (\n      (parentType === \"TSIntersectionType\" || parentType === \"TSUnionType\") &&\n      parent.types[0] === node\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function TSTypeOperator(\n  node: t.TSTypeOperator,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    parentType === \"TSOptionalType\"\n  );\n}\n\nexport function TSInstantiationExpression(\n  node: t.TSInstantiationExpression,\n  parent: t.Node,\n) {\n  const parentType = parent.type;\n  return (\n    (parentType === \"CallExpression\" ||\n      parentType === \"OptionalCallExpression\" ||\n      parentType === \"NewExpression\" ||\n      parentType === \"TSInstantiationExpression\") &&\n    !!parent.typeArguments\n  );\n}\n\nexport function TSFunctionType(\n  node: t.TSFunctionType,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"TSIntersectionType\" ||\n    parentType === \"TSUnionType\" ||\n    parentType === \"TSTypeOperator\" ||\n    parentType === \"TSOptionalType\" ||\n    parentType === \"TSArrayType\" ||\n    (parentType === \"TSIndexedAccessType\" && parent.objectType === node) ||\n    (parentType === \"TSConditionalType\" &&\n      (parent.checkType === node || parent.extendsType === node))\n  );\n}\n\nexport { TSFunctionType as TSConstructorType };\n\nexport function BinaryExpression(\n  node: t.BinaryExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  // for ((1 in []);;);\n  // for (var x = (1 in []) in 2);\n  return (\n    node.operator === \"in\" &&\n    Boolean(tokenContext & TokenContext.forInOrInitHeadAccumulate)\n  );\n}\n\nexport function SequenceExpression(\n  node: t.SequenceExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"SequenceExpression\" ||\n    parentType === \"ParenthesizedExpression\" ||\n    (parentType === \"MemberExpression\" && parent.property === node) ||\n    (parentType === \"OptionalMemberExpression\" && parent.property === node) ||\n    parentType === \"TemplateLiteral\"\n  ) {\n    return false;\n  }\n  if (parentType === \"ClassDeclaration\") {\n    return true;\n  }\n  if (parentType === \"ForOfStatement\") {\n    return parent.right === node;\n  }\n  if (parentType === \"ExportDefaultDeclaration\") {\n    return true;\n  }\n\n  return !isStatement(parent);\n}\n\nexport function YieldExpression(\n  node: t.YieldExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  return (\n    parentType === \"BinaryExpression\" ||\n    parentType === \"LogicalExpression\" ||\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    hasPostfixPart(node, parent) ||\n    (parentType === \"AwaitExpression\" && isYieldExpression(node)) ||\n    (parentType === \"ConditionalExpression\" && node === parent.test) ||\n    isClassExtendsClause(node, parent) ||\n    isTSTypeExpression(parentType)\n  );\n}\n\nexport { YieldExpression as AwaitExpression };\n\nexport function ClassExpression(\n  node: t.ClassExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return Boolean(\n    tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault),\n  );\n}\n\nexport function UnaryLike(\n  node:\n    | t.UnaryLike\n    | t.TSTypeAssertion\n    | t.ArrowFunctionExpression\n    | t.ConditionalExpression\n    | t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    hasPostfixPart(node, parent) ||\n    (isBinaryExpression(parent) &&\n      parent.operator === \"**\" &&\n      parent.left === node) ||\n    isClassExtendsClause(node, parent)\n  );\n}\n\nexport function FunctionExpression(\n  node: t.FunctionExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  return Boolean(\n    tokenContext &\n      (TokenContext.expressionStatement | TokenContext.exportDefault),\n  );\n}\n\nexport function ConditionalExpression(\n  node:\n    | t.ConditionalExpression\n    | t.ArrowFunctionExpression\n    | t.AssignmentExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (\n    parentType === \"UnaryExpression\" ||\n    parentType === \"SpreadElement\" ||\n    parentType === \"BinaryExpression\" ||\n    parentType === \"LogicalExpression\" ||\n    (parentType === \"ConditionalExpression\" && parent.test === node) ||\n    parentType === \"AwaitExpression\" ||\n    isTSTypeExpression(parentType)\n  ) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nexport { ConditionalExpression as ArrowFunctionExpression };\n\nexport function OptionalMemberExpression(\n  node: t.OptionalMemberExpression,\n  parent: t.Node,\n): boolean {\n  return (\n    (isCallExpression(parent) && parent.callee === node) ||\n    (isMemberExpression(parent) && parent.object === node)\n  );\n}\n\nexport { OptionalMemberExpression as OptionalCallExpression };\n\nexport function AssignmentExpression(\n  node: t.AssignmentExpression,\n  parent: t.Node,\n  tokenContext: number,\n): boolean {\n  if (\n    needsParenBeforeExpressionBrace(tokenContext) &&\n    isObjectPattern(node.left)\n  ) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nexport function LogicalExpression(\n  node: t.LogicalExpression,\n  parent: t.Node,\n): boolean {\n  const parentType = parent.type;\n  if (isTSTypeExpression(parentType)) return true;\n  if (parentType !== \"LogicalExpression\") return false;\n  switch (node.operator) {\n    case \"||\":\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n    case \"&&\":\n      return parent.operator === \"??\";\n    case \"??\":\n      return parent.operator !== \"??\";\n  }\n}\n\nexport function Identifier(\n  node: t.Identifier,\n  parent: t.Node,\n  tokenContext: number,\n  getRawIdentifier: (node: t.Identifier) => string,\n): boolean {\n  const parentType = parent.type;\n  // 13.15.2 AssignmentExpression RS: Evaluation\n  // (fn) = function () {};\n  if (\n    node.extra?.parenthesized &&\n    parentType === \"AssignmentExpression\" &&\n    parent.left === node\n  ) {\n    const rightType = parent.right.type;\n    if (\n      (rightType === \"FunctionExpression\" || rightType === \"ClassExpression\") &&\n      parent.right.id == null\n    ) {\n      return true;\n    }\n  }\n\n  if (getRawIdentifier && getRawIdentifier(node) !== node.name) {\n    return false;\n  }\n\n  // Non-strict code allows the identifier `let`, but it cannot occur as-is in\n  // certain contexts to avoid ambiguity with contextual keyword `let`.\n  if (node.name === \"let\") {\n    // Some contexts only forbid `let [`, so check if the next token would\n    // be the left bracket of a computed member expression.\n    const isFollowedByBracket =\n      isMemberExpression(parent, {\n        object: node,\n        computed: true,\n      }) ||\n      isOptionalMemberExpression(parent, {\n        object: node,\n        computed: true,\n        optional: false,\n      });\n    if (\n      isFollowedByBracket &&\n      tokenContext &\n        (TokenContext.expressionStatement |\n          TokenContext.forInitHead |\n          TokenContext.forInHead)\n    ) {\n      return true;\n    }\n    return Boolean(tokenContext & TokenContext.forOfHead);\n  }\n\n  // ECMAScript specifically forbids a for-of loop from starting with the\n  // token sequence `for (async of`, because it would be ambiguous with\n  // `for (async of => {};;)`, so we need to add extra parentheses.\n  return (\n    node.name === \"async\" &&\n    isForOfStatement(parent, { left: node, await: false })\n  );\n}\n","import * as whitespace from \"./whitespace.ts\";\nimport * as parens from \"./parentheses.ts\";\nimport {\n  FLIPPED_ALIAS_KEYS,\n  VISITOR_KEYS,\n  isCallExpression,\n  isDecorator,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n  isParenthesizedExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { WhitespaceFlag } from \"./whitespace.ts\";\n\nexport const enum TokenContext {\n  normal = 0,\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  arrowFlowReturnType = 1 << 3,\n  forInitHead = 1 << 4,\n  forInHead = 1 << 5,\n  forOfHead = 1 << 6,\n  // This flag lives across the token boundary, and will\n  // be reset after forIn or forInit head is printed\n  forInOrInitHeadAccumulate = 1 << 7,\n  forInOrInitHeadAccumulatePassThroughMask = 0x80,\n}\n\ntype NodeHandler<R> = (\n  node: t.Node,\n  // todo:\n  // node: K extends keyof typeof t\n  //   ? Extract<typeof t[K], { type: \"string\" }>\n  //   : t.Node,\n  parent: t.Node,\n  tokenContext?: number,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) => R | undefined;\n\nexport type NodeHandlers<R> = Partial<Record<string, NodeHandler<R>>>;\n\nfunction expandAliases<R>(obj: NodeHandlers<R>) {\n  const map = new Map<string, NodeHandler<R>>();\n\n  function add(type: string, func: NodeHandler<R>) {\n    const fn = map.get(type);\n    map.set(\n      type,\n      fn\n        ? function (node, parent, stack, getRawIdentifier) {\n            return (\n              fn(node, parent, stack, getRawIdentifier) ??\n              func(node, parent, stack, getRawIdentifier)\n            );\n          }\n        : func,\n    );\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]!);\n      }\n    } else {\n      add(type, obj[type]!);\n    }\n  }\n\n  return map;\n}\n\n// Rather than using `t.is` on each object property, we pre-expand any type aliases\n// into concrete types so that the 'find' call below can be as fast as possible.\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nexport function needsWhitespace(\n  node: t.Node,\n  parent: t.Node,\n  type: WhitespaceFlag,\n): boolean {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = expandedWhitespaceNodes.get(node.type)?.(node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nexport function needsWhitespaceBefore(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 1);\n}\n\nexport function needsWhitespaceAfter(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 2);\n}\n\nexport function needsParens(\n  node: t.Node,\n  parent: t.Node | null,\n  tokenContext?: number,\n  getRawIdentifier?: (node: t.Identifier) => string,\n): boolean {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  if (isDecorator(parent)) {\n    return (\n      !isDecoratorMemberExpression(node) &&\n      !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) &&\n      !isParenthesizedExpression(node)\n    );\n  }\n\n  return (\n    expandedParens.get(node.type)?.(\n      node,\n      parent,\n      tokenContext,\n      getRawIdentifier,\n    ) || false\n  );\n}\n\nfunction isDecoratorMemberExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\n\nexport function isLastChild(parent: t.Node, child: t.Node) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = (parent as any)[visitorKeys[i]] as t.Node | t.Node[] | null;\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n","import type * as t from \"@babel/types\";\nimport type { Token } from \"@babel/parser\";\n\nimport { traverseFast, VISITOR_KEYS } from \"@babel/types\";\n\nexport class TokenMap {\n  _tokens: Token[];\n  _source: string;\n\n  _nodesToTokenIndexes = new Map<t.Node, number[]>();\n  _nodesOccurrencesCountCache = new Map<\n    t.Node,\n    { test: string; count: number; i: number }\n  >();\n\n  _tokensCache = new Map<t.Node, { first: number; last: number }>();\n\n  constructor(ast: t.Node, tokens: Token[], source: string) {\n    this._tokens = tokens;\n    this._source = source;\n\n    traverseFast(ast, node => {\n      const indexes = this._getTokensIndexesOfNode(node);\n      if (indexes.length > 0) this._nodesToTokenIndexes.set(node, indexes);\n    });\n\n    this._tokensCache.clear();\n  }\n\n  has(node: t.Node): boolean {\n    return this._nodesToTokenIndexes.has(node);\n  }\n\n  getIndexes(node: t.Node): readonly number[] | undefined {\n    return this._nodesToTokenIndexes.get(node);\n  }\n\n  find(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = 0; k < indexes.length; k++) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return tok;\n      }\n    }\n    return null;\n  }\n\n  findLastIndex(\n    node: t.Node,\n    condition: (token: Token, index: number) => boolean,\n  ): number {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      for (let k = indexes.length - 1; k >= 0; k--) {\n        const index = indexes[k];\n        const tok = this._tokens[index];\n        if (condition(tok, index)) return index;\n      }\n    }\n    return -1;\n  }\n\n  findMatching(\n    node: t.Node,\n    test: string,\n    occurrenceCount: number = 0,\n  ): Token | null {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (indexes) {\n      let i = 0;\n      const count = occurrenceCount;\n\n      // To avoid O(n^2) search when printing lists (such as arrays), we\n      // cache the last index of a given token for a given occurrence count.\n      // If then we are asked to find the next occurrence of the same token,\n      // we start from the index of the previously found token.\n      // This cache only kicks in after 2 tokens of the same type, to avoid\n      // overhead in the simple case of having unique tokens per node.\n      if (count > 1) {\n        const cache = this._nodesOccurrencesCountCache.get(node);\n        if (cache?.test === test && cache.count < count) {\n          i = cache.i + 1;\n          occurrenceCount -= cache.count + 1;\n        }\n      }\n\n      for (; i < indexes.length; i++) {\n        const tok = this._tokens[indexes[i]];\n        if (this.matchesOriginal(tok, test)) {\n          if (occurrenceCount === 0) {\n            if (count > 0) {\n              this._nodesOccurrencesCountCache.set(node, { test, count, i });\n            }\n            return tok;\n          }\n          occurrenceCount--;\n        }\n      }\n    }\n    return null;\n  }\n\n  matchesOriginal(token: Token, test: string) {\n    if (token.end - token.start !== test.length) return false;\n    if (token.value != null) return token.value === test;\n    return this._source.startsWith(test, token.start);\n  }\n\n  startMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[0]];\n    if (tok.start !== node.start) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  endMatches(node: t.Node, test: string): boolean {\n    const indexes = this._nodesToTokenIndexes.get(node);\n    if (!indexes) return false;\n    const tok = this._tokens[indexes[indexes.length - 1]];\n    if (tok.end !== node.end) return false;\n    return this.matchesOriginal(tok, test);\n  }\n\n  _getTokensIndexesOfNode(node: t.Node): number[] {\n    if (node.start == null || node.end == null) return [];\n\n    const { first, last } = this._findTokensOfNode(\n      node,\n      0,\n      this._tokens.length - 1,\n    );\n\n    let low = first;\n\n    const children = childrenIterator(node);\n\n    if (\n      (node.type === \"ExportNamedDeclaration\" ||\n        node.type === \"ExportDefaultDeclaration\") &&\n      node.declaration?.type === \"ClassDeclaration\"\n    ) {\n      // Exported class declarations can be not properly nested inside\n      // the export declaration that contains them. For example, in\n      // `@dec export class Foo {}` the `export` is covered by the\n      // ClassDeclaration range. Skip the class declaration from the list\n      // of children to skip, so that when looking for `export` we also\n      // traverse its tokens.\n      children.next();\n    }\n\n    const indexes = [];\n\n    for (const child of children) {\n      if (child == null) continue;\n      if (child.start == null || child.end == null) continue;\n\n      const childTok = this._findTokensOfNode(child, low, last);\n\n      const high = childTok.first;\n      for (let k = low; k < high; k++) indexes.push(k);\n\n      low = childTok.last + 1;\n    }\n\n    for (let k = low; k <= last; k++) indexes.push(k);\n\n    return indexes;\n  }\n\n  _findTokensOfNode(node: t.Node, low: number, high: number) {\n    const cached = this._tokensCache.get(node);\n    if (cached) return cached;\n\n    const first = this._findFirstTokenOfNode(node.start!, low, high);\n    const last = this._findLastTokenOfNode(node.end!, first, high);\n\n    this._tokensCache.set(node, { first, last });\n    return { first, last };\n  }\n\n  _findFirstTokenOfNode(start: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (start < this._tokens[mid].start) {\n        high = mid - 1;\n      } else if (start > this._tokens[mid].start) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return low;\n  }\n\n  _findLastTokenOfNode(end: number, low: number, high: number): number {\n    while (low <= high) {\n      const mid = (high + low) >> 1;\n      if (end < this._tokens[mid].end) {\n        high = mid - 1;\n      } else if (end > this._tokens[mid].end) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n    return high;\n  }\n}\n\nfunction* childrenIterator(node: t.Node) {\n  // We need special handling to iterate TemplateLiteral\n  // children in order, since the two lists are interleaved.\n  if (node.type === \"TemplateLiteral\") {\n    yield node.quasis[0];\n    for (let i = 1; i < node.quasis.length; i++) {\n      yield node.expressions[i - 1];\n      yield node.quasis[i];\n    }\n    return;\n  }\n\n  const keys = VISITOR_KEYS[node.type];\n  for (const key of keys) {\n    const child = (node as any)[key];\n    if (!child) continue;\n    if (Array.isArray(child)) {\n      yield* child;\n    } else {\n      yield child;\n    }\n  }\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TaggedTemplateExpression(\n  this: Printer,\n  node: t.TaggedTemplateExpression,\n) {\n  this.print(node.tag);\n\n  this.print(node.typeArguments);\n\n  this.print(node.quasi);\n}\n\nexport function TemplateElement(this: Printer) {\n  throw new Error(\"TemplateElement printing is handled in TemplateLiteral\");\n}\n\nexport type TemplateLiteralBase = t.Node & {\n  quasis: t.TemplateElement[];\n};\n\nexport function _printTemplate<T extends t.Node>(\n  this: Printer,\n  node: TemplateLiteralBase,\n  substitutions: T[],\n) {\n  const quasis = node.quasis;\n  let partRaw = \"`\";\n  for (let i = 0; i < quasis.length - 1; i++) {\n    partRaw += quasis[i].value.raw;\n    this.token(partRaw + \"${\", true);\n    this.print(substitutions[i]);\n    partRaw = \"}\";\n  }\n\n  partRaw += quasis[quasis.length - 1].value.raw;\n  this.token(partRaw + \"`\", true);\n}\n\nexport function TemplateLiteral(this: Printer, node: t.TemplateLiteral) {\n  this._printTemplate(node, node.expressions);\n}\n","import type Printer from \"../printer.ts\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n  isPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  const { operator } = node;\n  if (\n    operator === \"void\" ||\n    operator === \"delete\" ||\n    operator === \"typeof\" ||\n    // throwExpressions\n    operator === \"throw\"\n  ) {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n\n  this.print(node.argument);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.print(node.expression);\n  exit();\n  this.rightParens(node);\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument);\n  } else {\n    this.print(node.argument, true);\n    this.token(node.operator);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments);\n\n  if (\n    node.arguments.length === 0 &&\n    this.tokenMap &&\n    !this.tokenMap.endMatches(node, \")\")\n  ) {\n    return;\n  }\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  this.print(node.expression);\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  let { computed } = node;\n  const { optional, property } = node;\n\n  this.print(node.object);\n\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(property);\n    this.token(\"]\");\n  } else {\n    if (!optional) {\n      this.token(\".\");\n    }\n    this.print(property);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments);\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments);\n  exit();\n  this.rightParens(node);\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee);\n\n  this.print(node.typeArguments);\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  if (node.delegate) {\n    this.word(\"yield\", true);\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument);\n    }\n  } else if (node.argument) {\n    this.word(\"yield\", true);\n    this.space();\n    this.print(node.argument);\n  } else {\n    this.word(\"yield\");\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.tokenContext |= TokenContext.expressionStatement;\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left);\n  if (node.left.type === \"Identifier\" || isPattern(node.left)) {\n    if (node.left.optional) this.token(\"?\");\n    this.print(node.left.typeAnnotation);\n  }\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression | t.BinaryExpression | t.LogicalExpression,\n) {\n  this.print(node.left);\n\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n    this._endsWithDiv = node.operator === \"/\";\n  }\n  this.space();\n\n  this.print(node.right);\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object);\n  this.token(\"::\");\n  this.print(node.callee);\n}\n\nexport {\n  AssignmentExpression as BinaryExpression,\n  AssignmentExpression as LogicalExpression,\n};\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    const exit = this.enterDelimited();\n    this.token(\"[\");\n    this.print(node.property);\n    this.token(\"]\");\n    exit();\n  } else {\n    this.token(\".\");\n    this.print(node.property);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body);\n  this.dedent();\n  this.rightBrace(node);\n}\n","import type Printer from \"../printer.ts\";\nimport {\n  isFor,\n  isForStatement,\n  isIfStatement,\n  isStatement,\n  isVoidPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nexport function WithStatement(this: Printer, node: t.WithStatement) {\n  this.word(\"with\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.object);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function IfStatement(this: Printer, node: t.IfStatement) {\n  this.word(\"if\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.space();\n\n  const needsBlock =\n    node.alternate && isIfStatement(getLastStatement(node.consequent));\n  if (needsBlock) {\n    this.token(\"{\");\n    this.newline();\n    this.indent();\n  }\n\n  this.printAndIndentOnComments(node.consequent);\n\n  if (needsBlock) {\n    this.dedent();\n    this.newline();\n    this.token(\"}\");\n  }\n\n  if (node.alternate) {\n    if (this.endsWith(charCodes.rightCurlyBrace)) this.space();\n    this.word(\"else\");\n    this.space();\n    this.printAndIndentOnComments(node.alternate);\n  }\n}\n\n// Recursively get the last statement.\nfunction getLastStatement(statement: t.Statement): t.Statement {\n  // @ts-expect-error: If statement.body is empty or not a Node, isStatement will return false\n  const { body } = statement;\n  if (isStatement(body) === false) {\n    return statement;\n  }\n\n  return getLastStatement(body);\n}\n\nexport function ForStatement(this: Printer, node: t.ForStatement) {\n  this.word(\"for\");\n  this.space();\n  this.token(\"(\");\n\n  {\n    const exit = this.enterForStatementInit();\n    this.print(node.init);\n    exit();\n  }\n\n  this.token(\";\");\n\n  if (node.test) {\n    this.space();\n    this.print(node.test);\n  }\n  this.token(\";\", false, 1);\n\n  if (node.update) {\n    this.space();\n    this.print(node.update);\n  }\n\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport function WhileStatement(this: Printer, node: t.WhileStatement) {\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nfunction ForXStatement(this: Printer, node: t.ForXStatement) {\n  this.word(\"for\");\n  this.space();\n  const isForOf = node.type === \"ForOfStatement\";\n  if (isForOf && node.await) {\n    this.word(\"await\");\n    this.space();\n  }\n  this.noIndentInnerCommentsHere();\n  this.token(\"(\");\n  {\n    const exit = this.enterForXStatementInit(isForOf);\n    this.print(node.left);\n    exit?.();\n  }\n  this.space();\n  this.word(isForOf ? \"of\" : \"in\");\n  this.space();\n  this.print(node.right);\n  this.token(\")\");\n  this.printBlock(node);\n}\n\nexport const ForInStatement = ForXStatement;\nexport const ForOfStatement = ForXStatement;\n\nexport function DoWhileStatement(this: Printer, node: t.DoWhileStatement) {\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n  this.space();\n  this.word(\"while\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.test);\n  this.token(\")\");\n  this.semicolon();\n}\n\nfunction printStatementAfterKeyword(\n  printer: Printer,\n  node: t.Node | null | undefined,\n) {\n  if (node) {\n    printer.space();\n    printer.printTerminatorless(node);\n  }\n\n  printer.semicolon();\n}\n\nexport function BreakStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"break\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ContinueStatement(this: Printer, node: t.ContinueStatement) {\n  this.word(\"continue\");\n  printStatementAfterKeyword(this, node.label);\n}\n\nexport function ReturnStatement(this: Printer, node: t.ReturnStatement) {\n  this.word(\"return\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function ThrowStatement(this: Printer, node: t.ThrowStatement) {\n  this.word(\"throw\");\n  printStatementAfterKeyword(this, node.argument);\n}\n\nexport function LabeledStatement(this: Printer, node: t.LabeledStatement) {\n  this.print(node.label);\n  this.token(\":\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function TryStatement(this: Printer, node: t.TryStatement) {\n  this.word(\"try\");\n  this.space();\n  this.print(node.block);\n  this.space();\n\n  // Esprima bug puts the catch clause in a `handlers` array.\n  // see https://code.google.com/p/esprima/issues/detail?id=433\n  // We run into this from regenerator generated ast.\n  // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n  if (node.handlers) {\n    // @ts-expect-error todo(flow->ts) should ast node type be updated to support this?\n    this.print(node.handlers[0]);\n  } else {\n    this.print(node.handler);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.word(\"finally\");\n    this.space();\n    this.print(node.finalizer);\n  }\n}\n\nexport function CatchClause(this: Printer, node: t.CatchClause) {\n  this.word(\"catch\");\n  this.space();\n  if (node.param) {\n    this.token(\"(\");\n    this.print(node.param);\n    this.print(node.param.typeAnnotation);\n    this.token(\")\");\n    this.space();\n  }\n  this.print(node.body);\n}\n\nexport function SwitchStatement(this: Printer, node: t.SwitchStatement) {\n  this.word(\"switch\");\n  this.space();\n  this.token(\"(\");\n  this.print(node.discriminant);\n  this.token(\")\");\n  this.space();\n  this.token(\"{\");\n\n  this.printSequence(node.cases, true);\n\n  this.rightBrace(node);\n}\n\nexport function SwitchCase(this: Printer, node: t.SwitchCase) {\n  if (node.test) {\n    this.word(\"case\");\n    this.space();\n    this.print(node.test);\n    this.token(\":\");\n  } else {\n    this.word(\"default\");\n    this.token(\":\");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    this.printSequence(node.consequent, true);\n  }\n}\n\nexport function DebuggerStatement(this: Printer) {\n  this.word(\"debugger\");\n  this.semicolon();\n}\n\nexport function VariableDeclaration(\n  this: Printer,\n  node: t.VariableDeclaration,\n  parent: t.Node,\n) {\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  const { kind } = node;\n  if (kind === \"await using\") {\n    this.word(\"await\");\n    this.space();\n    this.word(\"using\", true);\n  } else {\n    this.word(kind, kind === \"using\");\n  }\n  this.space();\n\n  let hasInits = false;\n  // don't add whitespace to loop heads\n  if (!isFor(parent)) {\n    for (const declar of node.declarations) {\n      if (declar.init) {\n        // has an init so let's split it up over multiple lines\n        hasInits = true;\n      }\n    }\n  }\n\n  //\n  // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on\n  // this will format declarations like:\n  //\n  //   let foo = \"bar\", bar = \"foo\";\n  //\n  // into\n  //\n  //   let foo = \"bar\",\n  //       bar = \"foo\";\n  //\n\n  this.printList(\n    node.declarations,\n    undefined,\n    undefined,\n    node.declarations.length > 1,\n    hasInits\n      ? function (this: Printer, occurrenceCount: number) {\n          this.token(\",\", false, occurrenceCount);\n          this.newline();\n        }\n      : undefined,\n  );\n\n  if (isFor(parent)) {\n    // don't give semicolons to these nodes since they'll be inserted in the parent generator\n    if (isForStatement(parent)) {\n      if (parent.init === node) return;\n    } else {\n      if (parent.left === node) return;\n    }\n  }\n\n  this.semicolon();\n}\n\nexport function VariableDeclarator(this: Printer, node: t.VariableDeclarator) {\n  this.print(node.id);\n  if (node.definite) this.token(\"!\"); // TS\n\n  if (!isVoidPattern(node.id)) {\n    this.print(node.id.typeAnnotation);\n  }\n\n  if (node.init) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.init);\n  }\n}\n","import type Printer from \"../printer.ts\";\nimport {\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nexport function ClassDeclaration(\n  this: Printer,\n  node: t.ClassDeclaration,\n  parent: t.Node,\n) {\n  const inExport =\n    isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);\n\n  if (\n    !inExport ||\n    !this._shouldPrintDecoratorsBeforeExport(\n      parent as t.ExportDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    this.printJoin(node.decorators);\n  }\n\n  if (node.declare) {\n    // TS\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    // TS\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"class\");\n\n  if (node.id) {\n    this.space();\n    this.print(node.id);\n  }\n\n  this.print(node.typeParameters);\n\n  if (node.superClass) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.superClass);\n    this.print(node.superTypeArguments);\n  }\n\n  if (node.implements) {\n    this.space();\n    this.word(\"implements\");\n    this.space();\n    this.printList(node.implements);\n  }\n\n  this.space();\n  this.print(node.body);\n}\n\nexport { ClassDeclaration as ClassExpression };\n\nexport function ClassBody(this: Printer, node: t.ClassBody) {\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n\n    const separator = classBodyEmptySemicolonsPrinter(this, node);\n    separator?.(-1); // print leading semicolons in preserveFormat mode\n\n    const exit = this.enterDelimited();\n    this.printJoin(node.body, true, true, separator, true);\n    exit();\n\n    if (!this.endsWith(charCodes.lineFeed)) this.newline();\n\n    this.rightBrace(node);\n  }\n}\n\nfunction classBodyEmptySemicolonsPrinter(printer: Printer, node: t.ClassBody) {\n  if (!printer.tokenMap || node.start == null || node.end == null) {\n    return null;\n  }\n\n  // \"empty statements\" in class bodies are not represented in the AST.\n  // Print them by checking if there are any ; tokens between the current AST\n  // member and the next one.\n\n  const indexes = printer.tokenMap.getIndexes(node);\n  if (!indexes) return null;\n\n  let k = 1; // start from 1 to skip '{'\n\n  let occurrenceCount = 0;\n\n  let nextLocIndex = 0;\n  const advanceNextLocIndex = () => {\n    while (\n      nextLocIndex < node.body.length &&\n      node.body[nextLocIndex].start == null\n    ) {\n      nextLocIndex++;\n    }\n  };\n  advanceNextLocIndex();\n\n  return (i: number) => {\n    if (nextLocIndex <= i) {\n      nextLocIndex = i + 1;\n      advanceNextLocIndex();\n    }\n\n    const end =\n      nextLocIndex === node.body.length\n        ? node.end\n        : node.body[nextLocIndex].start;\n\n    let tok;\n    while (\n      k < indexes.length &&\n      printer.tokenMap!.matchesOriginal(\n        (tok = printer._tokens![indexes[k]]),\n        \";\",\n      ) &&\n      tok.start < end!\n    ) {\n      printer.token(\";\", undefined, occurrenceCount++);\n      k++;\n    }\n  };\n}\n\nexport function ClassProperty(this: Printer, node: t.ClassProperty) {\n  this.printJoin(node.decorators);\n\n  if (!node.static && !this.format.preserveFormat) {\n    // catch up to property key, avoid line break\n    // between member TS modifiers and the property key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  this.tsPrintClassMemberModifiers(node);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    this._variance(node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassAccessorProperty(\n  this: Printer,\n  node: t.ClassAccessorProperty,\n) {\n  this.printJoin(node.decorators);\n\n  // catch up to property key, avoid line break\n  // between member modifiers and the property key.\n  const endLine = node.key.loc?.end?.line;\n  if (endLine) this.catchUp(endLine);\n\n  // TS does not support class accessor property yet\n  this.tsPrintClassMemberModifiers(node);\n\n  this.word(\"accessor\", true);\n  this.space();\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // Todo: Flow does not support class accessor property yet.\n    this._variance(node);\n    this.print(node.key);\n  }\n\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassPrivateProperty(\n  this: Printer,\n  node: t.ClassPrivateProperty,\n) {\n  this.printJoin(node.decorators);\n  this.tsPrintClassMemberModifiers(node);\n  this.print(node.key);\n  // TS\n  if (node.optional) {\n    this.token(\"?\");\n  }\n  if (node.definite) {\n    this.token(\"!\");\n  }\n  this.print(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.value);\n  }\n  this.semicolon();\n}\n\nexport function ClassMethod(this: Printer, node: t.ClassMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ClassPrivateMethod(this: Printer, node: t.ClassPrivateMethod) {\n  this._classMethodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function _classMethodHead(\n  this: Printer,\n  node: t.ClassMethod | t.ClassPrivateMethod | t.TSDeclareMethod,\n) {\n  this.printJoin(node.decorators);\n\n  if (!this.format.preserveFormat) {\n    // catch up to method key, avoid line break\n    // between member modifiers/method heads and the method key.\n    const endLine = node.key.loc?.end?.line;\n    if (endLine) this.catchUp(endLine);\n  }\n\n  this.tsPrintClassMemberModifiers(node);\n  this._methodHead(node);\n}\n\nexport function StaticBlock(this: Printer, node: t.StaticBlock) {\n  this.word(\"static\");\n  this.space();\n  this.token(\"{\");\n  if (node.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.printSequence(node.body, true);\n    this.rightBrace(node);\n  }\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\nimport { isIdentifier, type ParentMaps } from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\ntype ParentsOf<T extends t.Node> = ParentMaps[T[\"type\"]];\n\nexport function _params(\n  this: Printer,\n  node: t.Function | t.TSDeclareMethod | t.TSDeclareFunction,\n  idNode: t.Expression | t.PrivateName | null | undefined,\n  parentNode?: ParentsOf<typeof node>,\n) {\n  this.print(node.typeParameters);\n\n  const nameInfo = _getFuncIdName.call(this, idNode, parentNode);\n  if (nameInfo) {\n    this.sourceIdentifierName(nameInfo.name, nameInfo.pos);\n  }\n\n  this.token(\"(\");\n  this._parameters(node.params, \")\");\n\n  const noLineTerminator = node.type === \"ArrowFunctionExpression\";\n  this.print(node.returnType, noLineTerminator);\n\n  this._noLineTerminator = noLineTerminator;\n}\n\nexport function _parameters(\n  this: Printer,\n  parameters: t.Function[\"params\"],\n  endToken: string,\n) {\n  const exit = this.enterDelimited();\n\n  const trailingComma = this.shouldPrintTrailingComma(endToken);\n\n  const paramLength = parameters.length;\n  for (let i = 0; i < paramLength; i++) {\n    this._param(parameters[i]);\n\n    if (trailingComma || i < paramLength - 1) {\n      this.token(\",\", undefined, i);\n      this.space();\n    }\n  }\n\n  this.token(endToken);\n  exit();\n}\n\nexport function _param(\n  this: Printer,\n  parameter: t.Identifier | t.RestElement | t.Pattern | t.TSParameterProperty,\n) {\n  // @ts-expect-error decorators is not in VoidPattern\n  this.printJoin(parameter.decorators);\n  this.print(parameter);\n  if (\n    // @ts-expect-error optional is not in TSParameterProperty\n    parameter.optional\n  ) {\n    this.token(\"?\"); // TS / flow\n  }\n\n  this.print(\n    // @ts-expect-error typeAnnotation is not in TSParameterProperty\n    parameter.typeAnnotation,\n  ); // TS / flow\n}\n\nexport function _methodHead(this: Printer, node: t.Method | t.TSDeclareMethod) {\n  const kind = node.kind;\n  const key = node.key;\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.word(kind);\n    this.space();\n  }\n\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (\n    kind === \"method\" ||\n    // @ts-expect-error Fixme: kind: \"init\" is not defined\n    kind === \"init\"\n  ) {\n    if (node.generator) {\n      this.token(\"*\");\n    }\n  }\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(key);\n    this.token(\"]\");\n  } else {\n    this.print(key);\n  }\n\n  if (\n    // @ts-expect-error optional is not in ObjectMethod\n    node.optional\n  ) {\n    // TS\n    this.token(\"?\");\n  }\n\n  this._params(\n    node,\n    node.computed && node.key.type !== \"StringLiteral\" ? undefined : node.key,\n  );\n}\n\nexport function _predicate(\n  this: Printer,\n  node:\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.ArrowFunctionExpression,\n  noLineTerminatorAfter?: boolean,\n) {\n  if (node.predicate) {\n    if (!node.returnType) {\n      this.token(\":\");\n    }\n    this.space();\n    this.print(node.predicate, noLineTerminatorAfter);\n  }\n}\n\nexport function _functionHead(\n  this: Printer,\n  node: t.FunctionDeclaration | t.FunctionExpression | t.TSDeclareFunction,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\");\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._endsWithInnerRaw = false;\n    }\n    this.space();\n  }\n  this.word(\"function\");\n  if (node.generator) {\n    if (!this.format.preserveFormat) {\n      // We prevent inner comments from being printed here,\n      // so that they are always consistently printed in the\n      // same place regardless of the function type.\n      this._endsWithInnerRaw = false;\n    }\n    this.token(\"*\");\n  }\n\n  this.space();\n  if (node.id) {\n    this.print(node.id);\n  }\n\n  this._params(node, node.id, parent);\n  if (node.type !== \"TSDeclareFunction\") {\n    this._predicate(node);\n  }\n}\n\nexport function FunctionExpression(\n  this: Printer,\n  node: t.FunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  this._functionHead(node, parent);\n  this.space();\n  this.print(node.body);\n}\n\nexport { FunctionExpression as FunctionDeclaration };\n\nexport function ArrowFunctionExpression(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n  parent: ParentsOf<typeof node>,\n) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n\n  if (this._shouldPrintArrowParamsParens(node)) {\n    this._params(node, undefined, parent);\n  } else {\n    this.print(node.params[0], true);\n  }\n\n  this._predicate(node, true);\n  this.space();\n  // When printing (x)/*1*/=>{}, we remove the parentheses\n  // and thus there aren't two contiguous inner tokens.\n  // We forcefully print inner comments here.\n  this.printInnerComments();\n  this.token(\"=>\");\n\n  this.space();\n\n  this.tokenContext |= TokenContext.arrowBody;\n  this.print(node.body);\n}\n\n// Try to avoid printing parens in simple cases, but only if we're pretty\n// sure that they aren't needed by type annotations or potential newlines.\nexport function _shouldPrintArrowParamsParens(\n  this: Printer,\n  node: t.ArrowFunctionExpression,\n): boolean {\n  if (node.params.length !== 1) return true;\n\n  if (node.typeParameters || node.returnType || node.predicate) {\n    return true;\n  }\n\n  const firstParam = node.params[0];\n  if (\n    !isIdentifier(firstParam) ||\n    firstParam.typeAnnotation ||\n    firstParam.optional ||\n    // Flow does not support `foo /*: string*/ => {};`\n    firstParam.leadingComments?.length ||\n    firstParam.trailingComments?.length\n  ) {\n    return true;\n  }\n\n  if (this.tokenMap) {\n    if (node.loc == null) return true;\n    if (this.tokenMap.findMatching(node, \"(\") !== null) return true;\n    const arrowToken = this.tokenMap.findMatching(node, \"=>\");\n    if (arrowToken?.loc == null) return true;\n    return arrowToken.loc.start.line !== node.loc.start.line;\n  }\n\n  if (this.format.retainLines) return true;\n\n  return false;\n}\n\nfunction _getFuncIdName(\n  this: Printer,\n  idNode: t.Expression | t.PrivateName,\n  parent: ParentsOf<t.Function | t.TSDeclareMethod | t.TSDeclareFunction>,\n) {\n  let id: t.Expression | t.PrivateName | t.LVal | t.VoidPattern = idNode;\n\n  if (!id && parent) {\n    const parentType = parent.type;\n\n    if (parentType === \"VariableDeclarator\") {\n      id = parent.id;\n    } else if (\n      parentType === \"AssignmentExpression\" ||\n      parentType === \"AssignmentPattern\"\n    ) {\n      id = parent.left;\n    } else if (\n      parentType === \"ObjectProperty\" ||\n      parentType === \"ClassProperty\"\n    ) {\n      if (!parent.computed || parent.key.type === \"StringLiteral\") {\n        id = parent.key;\n      }\n    } else if (\n      parentType === \"ClassPrivateProperty\" ||\n      parentType === \"ClassAccessorProperty\"\n    ) {\n      id = parent.key;\n    }\n  }\n\n  if (!id) return;\n\n  let nameInfo;\n\n  if (id.type === \"Identifier\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.loc?.identifierName || id.name,\n    };\n  } else if (id.type === \"PrivateName\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: \"#\" + id.id.name,\n    };\n  } else if (id.type === \"StringLiteral\") {\n    nameInfo = {\n      pos: id.loc?.start,\n      name: id.value,\n    };\n  }\n\n  return nameInfo;\n}\n","import type Printer from \"../printer.ts\";\nimport {\n  isClassDeclaration,\n  isExportDefaultSpecifier,\n  isExportNamespaceSpecifier,\n  isImportDefaultSpecifier,\n  isImportNamespaceSpecifier,\n  isStatement,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function ImportSpecifier(this: Printer, node: t.ImportSpecifier) {\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.word(node.importKind);\n    this.space();\n  }\n\n  this.print(node.imported);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.local && node.local.name !== node.imported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.local);\n  }\n}\n\nexport function ImportDefaultSpecifier(\n  this: Printer,\n  node: t.ImportDefaultSpecifier,\n) {\n  this.print(node.local);\n}\n\nexport function ExportDefaultSpecifier(\n  this: Printer,\n  node: t.ExportDefaultSpecifier,\n) {\n  this.print(node.exported);\n}\n\nexport function ExportSpecifier(this: Printer, node: t.ExportSpecifier) {\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n\n  this.print(node.local);\n  // @ts-expect-error todo(flow-ts) maybe check node type instead of relying on name to be undefined on t.StringLiteral\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(node.exported);\n  }\n}\n\nexport function ExportNamespaceSpecifier(\n  this: Printer,\n  node: t.ExportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.exported);\n}\n\nexport function _printAttributes(\n  this: Printer,\n  node: Extract<t.Node, { attributes?: t.ImportAttribute[] | null }>,\n  hasPreviousBrace: boolean,\n) {\n  const { attributes } = node;\n\n  this.word(\"with\");\n  this.space();\n\n  const occurrenceCount = hasPreviousBrace ? 1 : 0;\n\n  this.token(\"{\", undefined, occurrenceCount);\n  this.space();\n  this.printList(attributes, this.shouldPrintTrailingComma(\"}\"));\n  this.space();\n  this.token(\"}\", undefined, occurrenceCount);\n}\n\nexport function ExportAllDeclaration(\n  this: Printer,\n  node: t.ExportAllDeclaration | t.DeclareExportAllDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  if (node.exportKind === \"type\") {\n    this.word(\"type\");\n    this.space();\n  }\n  this.token(\"*\");\n  this.space();\n  this.word(\"from\");\n  this.space();\n  if (node.attributes?.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, false);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nfunction maybePrintDecoratorsBeforeExport(\n  printer: Printer,\n  node: t.ExportNamedDeclaration | t.ExportDefaultDeclaration,\n) {\n  if (\n    isClassDeclaration(node.declaration) &&\n    printer._shouldPrintDecoratorsBeforeExport(\n      node as t.ExportNamedDeclaration & { declaration: t.ClassDeclaration },\n    )\n  ) {\n    printer.printJoin(node.declaration.decorators);\n  }\n}\n\nexport function ExportNamedDeclaration(\n  this: Printer,\n  node: t.ExportNamedDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.space();\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    if (node.exportKind === \"type\") {\n      this.word(\"type\");\n      this.space();\n    }\n\n    const specifiers = node.specifiers.slice(0);\n\n    // print \"special\" specifiers first\n    let hasSpecial = false;\n    for (;;) {\n      const first = specifiers[0];\n      if (\n        isExportDefaultSpecifier(first) ||\n        isExportNamespaceSpecifier(first)\n      ) {\n        hasSpecial = true;\n        this.print(specifiers.shift());\n        if (specifiers.length) {\n          this.token(\",\");\n          this.space();\n        }\n      } else {\n        break;\n      }\n    }\n\n    let hasBrace = false;\n    if (specifiers.length || (!specifiers.length && !hasSpecial)) {\n      hasBrace = true;\n      this.token(\"{\");\n      if (specifiers.length) {\n        this.space();\n        this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n        this.space();\n      }\n      this.token(\"}\");\n    }\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      if (node.attributes?.length) {\n        this.print(node.source, true);\n        this.space();\n        this._printAttributes(node, hasBrace);\n      } else {\n        this.print(node.source);\n      }\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExportDefaultDeclaration(\n  this: Printer,\n  node: t.ExportDefaultDeclaration,\n) {\n  maybePrintDecoratorsBeforeExport(this, node);\n\n  this.word(\"export\");\n  this.noIndentInnerCommentsHere();\n  this.space();\n  this.word(\"default\");\n  this.space();\n  this.tokenContext |= TokenContext.exportDefault;\n  const declar = node.declaration;\n  this.print(declar);\n  if (!isStatement(declar)) this.semicolon();\n}\n\nexport function ImportDeclaration(this: Printer, node: t.ImportDeclaration) {\n  this.word(\"import\");\n  this.space();\n\n  const isTypeKind = node.importKind === \"type\" || node.importKind === \"typeof\";\n  if (isTypeKind) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.importKind!);\n    this.space();\n  } else if (node.module) {\n    this.noIndentInnerCommentsHere();\n    this.word(\"module\");\n    this.space();\n  } else if (node.phase) {\n    this.noIndentInnerCommentsHere();\n    this.word(node.phase);\n    this.space();\n  }\n\n  const specifiers = node.specifiers.slice(0);\n  const hasSpecifiers = !!specifiers.length;\n  // print \"special\" specifiers first. The loop condition is constant,\n  // but there is a \"break\" in the body.\n  while (hasSpecifiers) {\n    const first = specifiers[0];\n    if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {\n      this.print(specifiers.shift());\n      if (specifiers.length) {\n        this.token(\",\");\n        this.space();\n      }\n    } else {\n      break;\n    }\n  }\n\n  let hasBrace = false;\n  if (specifiers.length) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.space();\n    this.printList(specifiers, this.shouldPrintTrailingComma(\"}\"));\n    this.space();\n    this.token(\"}\");\n  } else if (isTypeKind && !hasSpecifiers) {\n    hasBrace = true;\n    this.token(\"{\");\n    this.token(\"}\");\n  }\n\n  if (hasSpecifiers || isTypeKind) {\n    this.space();\n    this.word(\"from\");\n    this.space();\n  }\n\n  if (node.attributes?.length) {\n    this.print(node.source, true);\n    this.space();\n    this._printAttributes(node, hasBrace);\n  } else {\n    this.print(node.source);\n  }\n\n  this.semicolon();\n}\n\nexport function ImportAttribute(this: Printer, node: t.ImportAttribute) {\n  this.print(node.key);\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ImportNamespaceSpecifier(\n  this: Printer,\n  node: t.ImportNamespaceSpecifier,\n) {\n  this.token(\"*\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(node.local);\n}\n\nexport function ImportExpression(this: Printer, node: t.ImportExpression) {\n  this.word(\"import\");\n  if (node.phase) {\n    this.token(\".\");\n    this.word(node.phase);\n  }\n  this.token(\"(\");\n  const shouldPrintTrailingComma = this.shouldPrintTrailingComma(\")\");\n  this.print(node.source);\n  if (node.options != null) {\n    this.token(\",\");\n    this.space();\n    this.print(node.options);\n  }\n  if (shouldPrintTrailingComma) {\n    this.token(\",\");\n  }\n  this.rightParens(node);\n}\n","import type Printer from \"../printer.ts\";\nimport { isAssignmentPattern, isIdentifier } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport jsesc from \"jsesc\";\n\nlet lastRawIdentNode: t.Identifier | null = null;\nlet lastRawIdentResult: string = \"\";\nexport function _getRawIdentifier(this: Printer, node: t.Identifier) {\n  if (node === lastRawIdentNode) return lastRawIdentResult;\n  lastRawIdentNode = node;\n\n  const { name } = node;\n  const token = this.tokenMap!.find(node, tok => tok.value === name);\n  if (token) {\n    lastRawIdentResult = this._originalCode!.slice(token.start, token.end);\n    return lastRawIdentResult;\n  }\n  return (lastRawIdentResult = node.name);\n}\n\nexport function Identifier(this: Printer, node: t.Identifier) {\n  this.sourceIdentifierName(node.loc?.identifierName || node.name);\n\n  this.word(this.tokenMap ? this._getRawIdentifier(node) : node.name);\n}\n\nexport function ArgumentPlaceholder(this: Printer) {\n  this.token(\"?\");\n}\n\nexport function RestElement(this: Printer, node: t.RestElement) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport { RestElement as SpreadElement };\n\nexport function ObjectExpression(this: Printer, node: t.ObjectExpression) {\n  const props = node.properties;\n\n  this.token(\"{\");\n\n  if (props.length) {\n    const exit = this.enterDelimited();\n    this.space();\n    this.printList(props, this.shouldPrintTrailingComma(\"}\"), true, true);\n    this.space();\n    exit();\n  }\n\n  this.sourceWithOffset(\"end\", node.loc, -1);\n\n  this.token(\"}\");\n}\n\nexport { ObjectExpression as ObjectPattern };\n\nexport function ObjectMethod(this: Printer, node: t.ObjectMethod) {\n  this.printJoin(node.decorators);\n  this._methodHead(node);\n  this.space();\n  this.print(node.body);\n}\n\nexport function ObjectProperty(this: Printer, node: t.ObjectProperty) {\n  this.printJoin(node.decorators);\n\n  if (node.computed) {\n    this.token(\"[\");\n    this.print(node.key);\n    this.token(\"]\");\n  } else {\n    // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n    if (\n      isAssignmentPattern(node.value) &&\n      isIdentifier(node.key) &&\n      // @ts-expect-error todo(flow->ts) `.name` does not exist on some types in union\n      node.key.name === node.value.left.name\n    ) {\n      this.print(node.value);\n      return;\n    }\n\n    this.print(node.key);\n\n    // shorthand!\n    if (\n      node.shorthand &&\n      isIdentifier(node.key) &&\n      isIdentifier(node.value) &&\n      node.key.name === node.value.name\n    ) {\n      return;\n    }\n  }\n\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ArrayExpression(this: Printer, node: t.ArrayExpression) {\n  const elems = node.elements;\n  const len = elems.length;\n\n  this.token(\"[\");\n\n  const exit = this.enterDelimited();\n\n  for (let i = 0; i < elems.length; i++) {\n    const elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      this.print(elem);\n      if (i < len - 1 || this.shouldPrintTrailingComma(\"]\")) {\n        this.token(\",\", false, i);\n      }\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.token(\",\", false, i);\n    }\n  }\n\n  exit();\n\n  this.token(\"]\");\n}\n\nexport { ArrayExpression as ArrayPattern };\n\nexport function RegExpLiteral(this: Printer, node: t.RegExpLiteral) {\n  this.word(`/${node.pattern}/${node.flags}`);\n}\n\nexport function BooleanLiteral(this: Printer, node: t.BooleanLiteral) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteral(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function NumericLiteral(this: Printer, node: t.NumericLiteral) {\n  const raw = this.getPossibleRaw(node);\n  const opts = this.format.jsescOption;\n  const value = node.value;\n  const str = value + \"\";\n  if (opts.numbers) {\n    this.number(jsesc(value, opts), value);\n  } else if (raw == null) {\n    this.number(str, value); // normalize\n  } else if (this.format.minified) {\n    this.number(raw.length < str.length ? raw : str, value);\n  } else {\n    this.number(raw, value);\n  }\n}\n\nexport function StringLiteral(this: Printer, node: t.StringLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const val = jsesc(node.value, this.format.jsescOption);\n\n  this.token(val);\n}\n\nexport function BigIntLiteral(this: Printer, node: t.BigIntLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.word(raw);\n    return;\n  }\n  this.word(node.value + \"n\");\n}\n\n// Hack pipe operator\nconst validTopicTokenSet = new Set<string | undefined>([\n  \"^^\",\n  \"@@\",\n  \"^\",\n  \"%\",\n  \"#\",\n]);\nexport function TopicReference(this: Printer) {\n  const { topicToken } = this.format;\n\n  if (validTopicTokenSet.has(topicToken)) {\n    this.token(topicToken!);\n  } else {\n    const givenTopicTokenJSON = JSON.stringify(topicToken);\n    const validTopics = Array.from(validTopicTokenSet, v => JSON.stringify(v));\n    throw new Error(\n      `The \"topicToken\" generator option must be one of ` +\n        `${validTopics.join(\", \")} (${givenTopicTokenJSON} received instead).`,\n    );\n  }\n}\n\n// Smart-mix pipe operator\nexport function PipelineTopicExpression(\n  this: Printer,\n  node: t.PipelineTopicExpression,\n) {\n  this.print(node.expression);\n}\n\nexport function PipelineBareFunction(\n  this: Printer,\n  node: t.PipelineBareFunction,\n) {\n  this.print(node.callee);\n}\n\nexport function PipelinePrimaryTopicReference(this: Printer) {\n  this.token(\"#\");\n}\n\n// discard binding\nexport function VoidPattern(this: Printer) {\n  this.word(\"void\");\n}\n","import type Printer from \"../printer.ts\";\nimport { isDeclareExportDeclaration, isStatement } from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { ExportAllDeclaration } from \"./modules.ts\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function AnyTypeAnnotation(this: Printer) {\n  this.word(\"any\");\n}\n\nexport function ArrayTypeAnnotation(\n  this: Printer,\n  node: t.ArrayTypeAnnotation,\n) {\n  this.print(node.elementType, true);\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function BooleanTypeAnnotation(this: Printer) {\n  this.word(\"boolean\");\n}\n\nexport function BooleanLiteralTypeAnnotation(\n  this: Printer,\n  node: t.BooleanLiteralTypeAnnotation,\n) {\n  this.word(node.value ? \"true\" : \"false\");\n}\n\nexport function NullLiteralTypeAnnotation(this: Printer) {\n  this.word(\"null\");\n}\n\nexport function DeclareClass(\n  this: Printer,\n  node: t.DeclareClass,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"class\");\n  this.space();\n  this._interfaceish(node);\n}\n\nexport function DeclareFunction(\n  this: Printer,\n  node: t.DeclareFunction,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"function\");\n  this.space();\n  this.print(node.id);\n\n  // Skip TypeAnnotation printing method as the FunctionTypeAnnotation will print `(): `\n  this.print(node.id.typeAnnotation?.typeAnnotation);\n\n  if (node.predicate) {\n    this.space();\n    this.print(node.predicate);\n  }\n\n  this.semicolon();\n}\n\nexport function InferredPredicate(this: Printer) {\n  this.token(\"%\");\n  this.word(\"checks\");\n}\n\nexport function DeclaredPredicate(this: Printer, node: t.DeclaredPredicate) {\n  this.token(\"%\");\n  this.word(\"checks\");\n  this.token(\"(\");\n  this.print(node.value);\n  this.token(\")\");\n}\n\nexport function DeclareInterface(this: Printer, node: t.DeclareInterface) {\n  this.word(\"declare\");\n  this.space();\n  this.InterfaceDeclaration(node);\n}\n\nexport function DeclareModule(this: Printer, node: t.DeclareModule) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.space();\n  this.print(node.id);\n  this.space();\n  this.print(node.body);\n}\n\nexport function DeclareModuleExports(\n  this: Printer,\n  node: t.DeclareModuleExports,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"module\");\n  this.token(\".\");\n  this.word(\"exports\");\n  this.print(node.typeAnnotation);\n}\n\nexport function DeclareTypeAlias(this: Printer, node: t.DeclareTypeAlias) {\n  this.word(\"declare\");\n  this.space();\n  this.TypeAlias(node);\n}\n\nexport function DeclareOpaqueType(\n  this: Printer,\n  node: t.DeclareOpaqueType,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.OpaqueType(node);\n}\n\nexport function DeclareVariable(\n  this: Printer,\n  node: t.DeclareVariable,\n  parent: t.Node,\n) {\n  if (!isDeclareExportDeclaration(parent)) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"var\");\n  this.space();\n  this.print(node.id);\n  this.print(node.id.typeAnnotation);\n  this.semicolon();\n}\n\nexport function DeclareExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  this.word(\"export\");\n  this.space();\n  if (node.default) {\n    this.word(\"default\");\n    this.space();\n  }\n\n  FlowExportDeclaration.call(this, node);\n}\n\nexport function DeclareExportAllDeclaration(\n  this: Printer,\n  node: t.DeclareExportAllDeclaration,\n) {\n  this.word(\"declare\");\n  this.space();\n  ExportAllDeclaration.call(this, node);\n}\n\nexport function EnumDeclaration(this: Printer, node: t.EnumDeclaration) {\n  const { id, body } = node;\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.print(body);\n}\n\nfunction enumExplicitType(\n  context: Printer,\n  name: string,\n  hasExplicitType: boolean,\n) {\n  if (hasExplicitType) {\n    context.space();\n    context.word(\"of\");\n    context.space();\n    context.word(name);\n  }\n  context.space();\n}\n\nfunction enumBody(context: Printer, node: t.EnumBody) {\n  const { members } = node;\n  context.token(\"{\");\n  context.indent();\n  context.newline();\n  for (const member of members) {\n    context.print(member);\n    context.newline();\n  }\n  if (node.hasUnknownMembers) {\n    context.token(\"...\");\n    context.newline();\n  }\n  context.dedent();\n  context.token(\"}\");\n}\n\nexport function EnumBooleanBody(this: Printer, node: t.EnumBooleanBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"boolean\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumNumberBody(this: Printer, node: t.EnumNumberBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"number\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumStringBody(this: Printer, node: t.EnumStringBody) {\n  const { explicitType } = node;\n  enumExplicitType(this, \"string\", explicitType);\n  enumBody(this, node);\n}\n\nexport function EnumSymbolBody(this: Printer, node: t.EnumSymbolBody) {\n  enumExplicitType(this, \"symbol\", true);\n  enumBody(this, node);\n}\n\nexport function EnumDefaultedMember(\n  this: Printer,\n  node: t.EnumDefaultedMember,\n) {\n  const { id } = node;\n  this.print(id);\n  this.token(\",\");\n}\n\nfunction enumInitializedMember(\n  context: Printer,\n  node: t.EnumBooleanMember | t.EnumNumberMember | t.EnumStringMember,\n) {\n  context.print(node.id);\n  context.space();\n  context.token(\"=\");\n  context.space();\n  context.print(node.init);\n  context.token(\",\");\n}\n\nexport function EnumBooleanMember(this: Printer, node: t.EnumBooleanMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumNumberMember(this: Printer, node: t.EnumNumberMember) {\n  enumInitializedMember(this, node);\n}\n\nexport function EnumStringMember(this: Printer, node: t.EnumStringMember) {\n  enumInitializedMember(this, node);\n}\n\nfunction FlowExportDeclaration(\n  this: Printer,\n  node: t.DeclareExportDeclaration,\n) {\n  if (node.declaration) {\n    const declar = node.declaration;\n    this.print(declar);\n    if (!isStatement(declar)) this.semicolon();\n  } else {\n    this.token(\"{\");\n    if (node.specifiers!.length) {\n      this.space();\n      this.printList(node.specifiers);\n      this.space();\n    }\n    this.token(\"}\");\n\n    if (node.source) {\n      this.space();\n      this.word(\"from\");\n      this.space();\n      this.print(node.source);\n    }\n\n    this.semicolon();\n  }\n}\n\nexport function ExistsTypeAnnotation(this: Printer) {\n  this.token(\"*\");\n}\n\nexport function FunctionTypeAnnotation(\n  this: Printer,\n  node: t.FunctionTypeAnnotation,\n  parent?: t.Node,\n) {\n  this.print(node.typeParameters);\n  this.token(\"(\");\n\n  if (node.this) {\n    this.word(\"this\");\n    this.token(\":\");\n    this.space();\n    this.print(node.this.typeAnnotation);\n    if (node.params.length || node.rest) {\n      this.token(\",\");\n      this.space();\n    }\n  }\n\n  this.printList(node.params);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.token(\",\");\n      this.space();\n    }\n    this.token(\"...\");\n    this.print(node.rest);\n  }\n\n  this.token(\")\");\n\n  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying\n\n  const type = parent?.type;\n  if (\n    type != null &&\n    (type === \"ObjectTypeCallProperty\" ||\n      type === \"ObjectTypeInternalSlot\" ||\n      type === \"DeclareFunction\" ||\n      (type === \"ObjectTypeProperty\" && parent.method))\n  ) {\n    this.token(\":\");\n  } else {\n    this.space();\n    this.token(\"=>\");\n  }\n\n  this.space();\n  this.print(node.returnType);\n}\n\nexport function FunctionTypeParam(this: Printer, node: t.FunctionTypeParam) {\n  this.print(node.name);\n  if (node.optional) this.token(\"?\");\n  if (node.name) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function InterfaceExtends(this: Printer, node: t.InterfaceExtends) {\n  this.print(node.id);\n  this.print(node.typeParameters, true);\n}\n\nexport {\n  InterfaceExtends as ClassImplements,\n  InterfaceExtends as GenericTypeAnnotation,\n};\n\nexport function _interfaceish(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface | t.DeclareClass,\n) {\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  if (node.type === \"DeclareClass\") {\n    if (node.mixins?.length) {\n      this.space();\n      this.word(\"mixins\");\n      this.space();\n      this.printList(node.mixins);\n    }\n    if (node.implements?.length) {\n      this.space();\n      this.word(\"implements\");\n      this.space();\n      this.printList(node.implements);\n    }\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function _variance(\n  this: Printer,\n  node:\n    | t.TypeParameter\n    | t.ObjectTypeIndexer\n    | t.ObjectTypeProperty\n    | t.ClassProperty\n    | t.ClassPrivateProperty\n    | t.ClassAccessorProperty,\n) {\n  const kind = node.variance?.kind;\n  if (kind != null) {\n    if (kind === \"plus\") {\n      this.token(\"+\");\n    } else if (kind === \"minus\") {\n      this.token(\"-\");\n    }\n  }\n}\n\nexport function InterfaceDeclaration(\n  this: Printer,\n  node: t.InterfaceDeclaration | t.DeclareInterface,\n) {\n  this.word(\"interface\");\n  this.space();\n  this._interfaceish(node);\n}\n\nfunction andSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"&\", false, occurrenceCount);\n  this.space();\n}\n\nexport function InterfaceTypeAnnotation(\n  this: Printer,\n  node: t.InterfaceTypeAnnotation,\n) {\n  this.word(\"interface\");\n  if (node.extends?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(node.extends);\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function IntersectionTypeAnnotation(\n  this: Printer,\n  node: t.IntersectionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, andSeparator);\n}\n\nexport function MixedTypeAnnotation(this: Printer) {\n  this.word(\"mixed\");\n}\n\nexport function EmptyTypeAnnotation(this: Printer) {\n  this.word(\"empty\");\n}\n\nexport function NullableTypeAnnotation(\n  this: Printer,\n  node: t.NullableTypeAnnotation,\n) {\n  this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport {\n  NumericLiteral as NumberLiteralTypeAnnotation,\n  StringLiteral as StringLiteralTypeAnnotation,\n} from \"./types.ts\";\n\nexport function NumberTypeAnnotation(this: Printer) {\n  this.word(\"number\");\n}\n\nexport function StringTypeAnnotation(this: Printer) {\n  this.word(\"string\");\n}\n\nexport function ThisTypeAnnotation(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TupleTypeAnnotation(\n  this: Printer,\n  node: t.TupleTypeAnnotation,\n) {\n  this.token(\"[\");\n  this.printList(node.types);\n  this.token(\"]\");\n}\n\nexport function TypeofTypeAnnotation(\n  this: Printer,\n  node: t.TypeofTypeAnnotation,\n) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function TypeAlias(\n  this: Printer,\n  node: t.TypeAlias | t.DeclareTypeAlias,\n) {\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n  this.semicolon();\n}\n\nexport function TypeAnnotation(\n  this: Printer,\n  node: t.TypeAnnotation,\n  parent: t.Node,\n) {\n  this.token(\":\");\n  this.space();\n  if (parent.type === \"ArrowFunctionExpression\") {\n    this.tokenContext |= TokenContext.arrowFlowReturnType;\n  } else if (\n    // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n    node.optional\n  ) {\n    this.token(\"?\");\n  }\n  this.print(node.typeAnnotation);\n}\n\nexport function TypeParameterInstantiation(\n  this: Printer,\n  node: t.TypeParameterInstantiation,\n): void {\n  this.token(\"<\");\n  this.printList(node.params);\n  this.token(\">\");\n}\n\nexport { TypeParameterInstantiation as TypeParameterDeclaration };\n\nexport function TypeParameter(this: Printer, node: t.TypeParameter) {\n  this._variance(node);\n\n  this.word(node.name);\n\n  if (node.bound) {\n    this.print(node.bound);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function OpaqueType(\n  this: Printer,\n  node: t.OpaqueType | t.DeclareOpaqueType,\n) {\n  this.word(\"opaque\");\n  this.space();\n  this.word(\"type\");\n  this.space();\n  this.print(node.id);\n  this.print(node.typeParameters);\n  if (node.supertype) {\n    this.token(\":\");\n    this.space();\n    this.print(node.supertype);\n  }\n\n  if (node.impltype) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.impltype);\n  }\n  this.semicolon();\n}\n\nexport function ObjectTypeAnnotation(\n  this: Printer,\n  node: t.ObjectTypeAnnotation,\n) {\n  if (node.exact) {\n    this.token(\"{|\");\n  } else {\n    this.token(\"{\");\n  }\n\n  // TODO: remove the array fallbacks and instead enforce the types to require an array\n  const props = [\n    ...node.properties,\n    ...(node.callProperties || []),\n    ...(node.indexers || []),\n    ...(node.internalSlots || []),\n  ];\n\n  if (props.length) {\n    this.newline();\n\n    this.space();\n\n    this.printJoin(props, true, true, undefined, undefined, () => {\n      if (props.length !== 1 || node.inexact) {\n        this.token(\",\");\n        this.space();\n      }\n    });\n\n    this.space();\n  }\n\n  if (node.inexact) {\n    this.indent();\n    this.token(\"...\");\n    if (props.length) {\n      this.newline();\n    }\n    this.dedent();\n  }\n\n  if (node.exact) {\n    this.token(\"|}\");\n  } else {\n    this.token(\"}\");\n  }\n}\n\nexport function ObjectTypeInternalSlot(\n  this: Printer,\n  node: t.ObjectTypeInternalSlot,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.token(\"[\");\n  this.token(\"[\");\n  this.print(node.id);\n  this.token(\"]\");\n  this.token(\"]\");\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeCallProperty(\n  this: Printer,\n  node: t.ObjectTypeCallProperty,\n) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeIndexer(this: Printer, node: t.ObjectTypeIndexer) {\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  this._variance(node);\n  this.token(\"[\");\n  if (node.id) {\n    this.print(node.id);\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.key);\n  this.token(\"]\");\n  this.token(\":\");\n  this.space();\n  this.print(node.value);\n}\n\nexport function ObjectTypeProperty(this: Printer, node: t.ObjectTypeProperty) {\n  if (node.proto) {\n    this.word(\"proto\");\n    this.space();\n  }\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (node.kind === \"get\" || node.kind === \"set\") {\n    this.word(node.kind);\n    this.space();\n  }\n  this._variance(node);\n  this.print(node.key);\n  if (node.optional) this.token(\"?\");\n  if (!node.method) {\n    this.token(\":\");\n    this.space();\n  }\n  this.print(node.value);\n}\n\nexport function ObjectTypeSpreadProperty(\n  this: Printer,\n  node: t.ObjectTypeSpreadProperty,\n) {\n  this.token(\"...\");\n  this.print(node.argument);\n}\n\nexport function QualifiedTypeIdentifier(\n  this: Printer,\n  node: t.QualifiedTypeIdentifier,\n) {\n  this.print(node.qualification);\n  this.token(\".\");\n  this.print(node.id);\n}\n\nexport function SymbolTypeAnnotation(this: Printer) {\n  this.word(\"symbol\");\n}\n\nfunction orSeparator(this: Printer, occurrenceCount: number) {\n  this.space();\n  this.token(\"|\", false, occurrenceCount);\n  this.space();\n}\n\nexport function UnionTypeAnnotation(\n  this: Printer,\n  node: t.UnionTypeAnnotation,\n) {\n  this.printJoin(node.types, undefined, undefined, orSeparator);\n}\n\nexport function TypeCastExpression(this: Printer, node: t.TypeCastExpression) {\n  this.token(\"(\");\n  this.print(node.expression);\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function Variance(this: Printer, node: t.Variance) {\n  if (node.kind === \"plus\") {\n    this.token(\"+\");\n  } else {\n    this.token(\"-\");\n  }\n}\n\nexport function VoidTypeAnnotation(this: Printer) {\n  this.word(\"void\");\n}\n\nexport function IndexedAccessType(this: Printer, node: t.IndexedAccessType) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function OptionalIndexedAccessType(\n  this: Printer,\n  node: t.OptionalIndexedAccessType,\n) {\n  this.print(node.objectType);\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function File(this: Printer, node: t.File) {\n  if (node.program) {\n    // Print this here to ensure that Program node 'leadingComments' still\n    // get printed after the hashbang.\n    this.print(node.program.interpreter);\n  }\n\n  this.print(node.program);\n}\n\nexport function Program(this: Printer, node: t.Program) {\n  // An empty Program doesn't have any inner tokens, so\n  // we must explicitly print its inner comments.\n  this.noIndentInnerCommentsHere();\n  this.printInnerComments();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, undefined, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body);\n}\n\nexport function BlockStatement(this: Printer, node: t.BlockStatement) {\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n\n  const directivesLen = node.directives?.length;\n  if (directivesLen) {\n    const newline = node.body.length ? 2 : 1;\n    this.printSequence(node.directives, true, newline);\n    if (!node.directives[directivesLen - 1].trailingComments?.length) {\n      this.newline(newline);\n    }\n  }\n\n  this.printSequence(node.body, true);\n\n  exit();\n  this.rightBrace(node);\n}\n\nexport function Directive(this: Printer, node: t.Directive) {\n  this.print(node.value);\n  this.semicolon();\n}\n\n// These regexes match an even number of \\ followed by a quote\nconst unescapedSingleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*'/;\nconst unescapedDoubleQuoteRE = /(?:^|[^\\\\])(?:\\\\\\\\)*\"/;\n\nexport function DirectiveLiteral(this: Printer, node: t.DirectiveLiteral) {\n  const raw = this.getPossibleRaw(node);\n  if (!this.format.minified && raw !== undefined) {\n    this.token(raw);\n    return;\n  }\n\n  const { value } = node;\n\n  // NOTE: In directives we can't change escapings,\n  // because they change the behavior.\n  // e.g. \"us\\x65 strict\" (\\x65 is e) is not a \"use strict\" directive.\n\n  if (!unescapedDoubleQuoteRE.test(value)) {\n    this.token(`\"${value}\"`);\n  } else if (!unescapedSingleQuoteRE.test(value)) {\n    this.token(`'${value}'`);\n  } else {\n    throw new Error(\n      \"Malformed AST: it is not possible to print a directive containing\" +\n        \" both unescaped single and double quotes.\",\n    );\n  }\n}\n\nexport function InterpreterDirective(\n  this: Printer,\n  node: t.InterpreterDirective,\n) {\n  this.token(`#!${node.value}`);\n  this.newline(1, true);\n}\n\nexport function Placeholder(this: Printer, node: t.Placeholder) {\n  this.token(\"%%\");\n  this.print(node.name);\n  this.token(\"%%\");\n\n  if (node.expectedNode === \"Statement\") {\n    this.semicolon();\n  }\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function JSXAttribute(this: Printer, node: t.JSXAttribute) {\n  this.print(node.name);\n  if (node.value) {\n    this.token(\"=\");\n    this.print(node.value);\n  }\n}\n\nexport function JSXIdentifier(this: Printer, node: t.JSXIdentifier) {\n  this.word(node.name);\n}\n\nexport function JSXNamespacedName(this: Printer, node: t.JSXNamespacedName) {\n  this.print(node.namespace);\n  this.token(\":\");\n  this.print(node.name);\n}\n\nexport function JSXMemberExpression(\n  this: Printer,\n  node: t.JSXMemberExpression,\n) {\n  this.print(node.object);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function JSXSpreadAttribute(this: Printer, node: t.JSXSpreadAttribute) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.argument);\n  this.rightBrace(node);\n}\n\nexport function JSXExpressionContainer(\n  this: Printer,\n  node: t.JSXExpressionContainer,\n) {\n  this.token(\"{\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXSpreadChild(this: Printer, node: t.JSXSpreadChild) {\n  this.token(\"{\");\n  this.token(\"...\");\n  this.print(node.expression);\n  this.rightBrace(node);\n}\n\nexport function JSXText(this: Printer, node: t.JSXText) {\n  const raw = this.getPossibleRaw(node);\n\n  if (raw !== undefined) {\n    this.token(raw, true);\n  } else {\n    this.token(node.value, true);\n  }\n}\n\nexport function JSXElement(this: Printer, node: t.JSXElement) {\n  const open = node.openingElement;\n  this.print(open);\n  if (open.selfClosing) return;\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingElement);\n}\n\nfunction spaceSeparator(this: Printer) {\n  this.space();\n}\n\nexport function JSXOpeningElement(this: Printer, node: t.JSXOpeningElement) {\n  this.token(\"<\");\n  this.print(node.name);\n\n  this.print(node.typeArguments);\n\n  if (node.attributes.length > 0) {\n    this.space();\n    this.printJoin(node.attributes, undefined, undefined, spaceSeparator);\n  }\n  if (node.selfClosing) {\n    this.space();\n    this.token(\"/\");\n  }\n  this.token(\">\");\n}\n\nexport function JSXClosingElement(this: Printer, node: t.JSXClosingElement) {\n  this.token(\"<\");\n  this.token(\"/\");\n  this.print(node.name);\n  this.token(\">\");\n}\n\nexport function JSXEmptyExpression(this: Printer) {\n  // This node is empty, so forcefully print its inner comments.\n  this.printInnerComments();\n}\n\nexport function JSXFragment(this: Printer, node: t.JSXFragment) {\n  this.print(node.openingFragment);\n\n  this.indent();\n  for (const child of node.children) {\n    this.print(child);\n  }\n  this.dedent();\n\n  this.print(node.closingFragment);\n}\n\nexport function JSXOpeningFragment(this: Printer) {\n  this.token(\"<\");\n  this.token(\">\");\n}\n\nexport function JSXClosingFragment(this: Printer) {\n  this.token(\"</\");\n  this.token(\">\");\n}\n","import type Printer from \"../printer.ts\";\nimport type * as t from \"@babel/types\";\n\nexport function TSTypeAnnotation(\n  this: Printer,\n  node: t.TSTypeAnnotation,\n  parent: t.Node,\n) {\n  // TODO(@nicolo-ribaudo): investigate not including => in the range\n  // of the return type of an arrow function type\n  this.token(\n    (parent.type === \"TSFunctionType\" || parent.type === \"TSConstructorType\") &&\n      parent.returnType === node\n      ? \"=>\"\n      : \":\",\n  );\n  this.space();\n  // @ts-expect-error todo(flow->ts) can this be removed? `.optional` looks to be not existing property\n  if (node.optional) this.token(\"?\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSTypeParameterInstantiation(\n  this: Printer,\n  node: t.TSTypeParameterInstantiation,\n  parent: t.Node,\n): void {\n  this.token(\"<\");\n\n  let printTrailingSeparator: boolean | null =\n    parent.type === \"ArrowFunctionExpression\" && node.params.length === 1;\n  if (this.tokenMap && node.start != null && node.end != null) {\n    // Only force the trailing comma for pre-existing nodes if they\n    // already had a comma (either because they were multi-param, or\n    // because they had a trailing comma)\n    printTrailingSeparator &&= !!this.tokenMap.find(node, t =>\n      this.tokenMap!.matchesOriginal(t, \",\"),\n    );\n    // Preserve the trailing comma if it was there before\n    printTrailingSeparator ||= this.shouldPrintTrailingComma(\">\");\n  }\n\n  this.printList(node.params, printTrailingSeparator);\n  this.token(\">\");\n}\n\nexport { TSTypeParameterInstantiation as TSTypeParameterDeclaration };\n\nexport function TSTypeParameter(this: Printer, node: t.TSTypeParameter) {\n  if (node.const) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word((node.name as unknown as t.Identifier).name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint);\n  }\n\n  if (node.default) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(node.default);\n  }\n}\n\nexport function TSParameterProperty(\n  this: Printer,\n  node: t.TSParameterProperty,\n) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nexport function TSDeclareFunction(\n  this: Printer,\n  node: t.TSDeclareFunction,\n  parent: t.ParentMaps[\"TSDeclareFunction\"],\n) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this._functionHead(node, parent);\n  this.semicolon();\n}\n\nexport function TSDeclareMethod(this: Printer, node: t.TSDeclareMethod) {\n  this._classMethodHead(node);\n  this.semicolon();\n}\n\nexport function TSQualifiedName(this: Printer, node: t.TSQualifiedName) {\n  this.print(node.left);\n  this.token(\".\");\n  this.print(node.right);\n}\n\nexport function TSCallSignatureDeclaration(\n  this: Printer,\n  node: t.TSCallSignatureDeclaration,\n) {\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nfunction maybePrintTrailingCommaOrSemicolon(printer: Printer, node: t.Node) {\n  if (!printer.tokenMap || !node.start || !node.end) {\n    printer.semicolon();\n    return;\n  }\n\n  if (printer.tokenMap.endMatches(node, \",\")) {\n    printer.token(\",\");\n  } else if (printer.tokenMap.endMatches(node, \";\")) {\n    printer.semicolon();\n  }\n}\n\nexport function TSConstructSignatureDeclaration(\n  this: Printer,\n  node: t.TSConstructSignatureDeclaration,\n) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSPropertySignature(\n  this: Printer,\n  node: t.TSPropertySignature,\n) {\n  const { readonly } = node;\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function tsPrintPropertyOrMethodName(\n  this: Printer,\n  node: t.TSPropertySignature | t.TSMethodSignature,\n) {\n  if (node.computed) {\n    this.token(\"[\");\n  }\n  this.print(node.key);\n  if (node.computed) {\n    this.token(\"]\");\n  }\n  if (node.optional) {\n    this.token(\"?\");\n  }\n}\n\nexport function TSMethodSignature(this: Printer, node: t.TSMethodSignature) {\n  const { kind } = node;\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSIndexSignature(this: Printer, node: t.TSIndexSignature) {\n  const { readonly, static: isStatic } = node;\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n  this.token(\"[\");\n  this._parameters(node.parameters, \"]\");\n  this.print(node.typeAnnotation);\n  maybePrintTrailingCommaOrSemicolon(this, node);\n}\n\nexport function TSAnyKeyword(this: Printer) {\n  this.word(\"any\");\n}\nexport function TSBigIntKeyword(this: Printer) {\n  this.word(\"bigint\");\n}\nexport function TSUnknownKeyword(this: Printer) {\n  this.word(\"unknown\");\n}\nexport function TSNumberKeyword(this: Printer) {\n  this.word(\"number\");\n}\nexport function TSObjectKeyword(this: Printer) {\n  this.word(\"object\");\n}\nexport function TSBooleanKeyword(this: Printer) {\n  this.word(\"boolean\");\n}\nexport function TSStringKeyword(this: Printer) {\n  this.word(\"string\");\n}\nexport function TSSymbolKeyword(this: Printer) {\n  this.word(\"symbol\");\n}\nexport function TSVoidKeyword(this: Printer) {\n  this.word(\"void\");\n}\nexport function TSUndefinedKeyword(this: Printer) {\n  this.word(\"undefined\");\n}\nexport function TSNullKeyword(this: Printer) {\n  this.word(\"null\");\n}\nexport function TSNeverKeyword(this: Printer) {\n  this.word(\"never\");\n}\nexport function TSIntrinsicKeyword(this: Printer) {\n  this.word(\"intrinsic\");\n}\n\nexport function TSThisType(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function TSFunctionType(this: Printer, node: t.TSFunctionType) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function TSConstructorType(this: Printer, node: t.TSConstructorType) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nexport function tsPrintFunctionOrConstructorType(\n  this: Printer,\n  node: t.TSFunctionType | t.TSConstructorType,\n) {\n  const { typeParameters } = node;\n  const parameters = node.params;\n\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  this.space();\n  const returnType = node.returnType;\n\n  this.print(returnType);\n}\n\nexport function TSTypeReference(this: Printer, node: t.TSTypeReference) {\n  const typeArguments = node.typeArguments;\n\n  this.print(node.typeName, !!typeArguments);\n  this.print(typeArguments);\n}\n\nexport function TSTypePredicate(this: Printer, node: t.TSTypePredicate) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n  this.print(node.parameterName);\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nexport function TSTypeQuery(this: Printer, node: t.TSTypeQuery) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  const typeArguments = node.typeArguments;\n\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\n\nexport function TSTypeLiteral(this: Printer, node: t.TSTypeLiteral) {\n  printBraced(this, node, () => this.printJoin(node.members, true, true));\n}\n\nexport function TSArrayType(this: Printer, node: t.TSArrayType) {\n  this.print(node.elementType, true);\n\n  this.token(\"[\");\n  this.token(\"]\");\n}\n\nexport function TSTupleType(this: Printer, node: t.TSTupleType) {\n  this.token(\"[\");\n  this.printList(node.elementTypes, this.shouldPrintTrailingComma(\"]\"));\n  this.token(\"]\");\n}\n\nexport function TSOptionalType(this: Printer, node: t.TSOptionalType) {\n  this.print(node.typeAnnotation);\n  this.token(\"?\");\n}\n\nexport function TSRestType(this: Printer, node: t.TSRestType) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation);\n}\n\nexport function TSNamedTupleMember(this: Printer, node: t.TSNamedTupleMember) {\n  this.print(node.label);\n  if (node.optional) this.token(\"?\");\n  this.token(\":\");\n  this.space();\n  this.print(node.elementType);\n}\n\nexport function TSUnionType(this: Printer, node: t.TSUnionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nexport function TSIntersectionType(this: Printer, node: t.TSIntersectionType) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(\n  printer: Printer,\n  node: t.TSUnionType | t.TSIntersectionType,\n  sep: \"|\" | \"&\",\n) {\n  let hasLeadingToken = 0;\n  if (printer.tokenMap?.startMatches(node, sep)) {\n    hasLeadingToken = 1;\n    printer.token(sep);\n  }\n\n  printer.printJoin(node.types, undefined, undefined, function (i) {\n    this.space();\n    this.token(sep, undefined, i + hasLeadingToken);\n    this.space();\n  });\n}\n\nexport function TSConditionalType(this: Printer, node: t.TSConditionalType) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.falseType);\n}\n\nexport function TSInferType(this: Printer, node: t.TSInferType) {\n  this.word(\"infer\");\n  this.print(node.typeParameter);\n}\n\nexport function TSParenthesizedType(\n  this: Printer,\n  node: t.TSParenthesizedType,\n) {\n  this.token(\"(\");\n  this.print(node.typeAnnotation);\n  this.token(\")\");\n}\n\nexport function TSTypeOperator(this: Printer, node: t.TSTypeOperator) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation);\n}\n\nexport function TSIndexedAccessType(\n  this: Printer,\n  node: t.TSIndexedAccessType,\n) {\n  this.print(node.objectType, true);\n  this.token(\"[\");\n  this.print(node.indexType);\n  this.token(\"]\");\n}\n\nexport function TSMappedType(this: Printer, node: t.TSMappedType) {\n  const { nameType, optional, readonly, typeAnnotation } = node;\n  this.token(\"{\");\n  const exit = this.enterDelimited();\n  this.space();\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.token(\"[\");\n\n  this.word(node.key.name);\n\n  this.space();\n  this.word(\"in\");\n  this.space();\n\n  this.print(node.constraint);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType);\n  }\n\n  this.token(\"]\");\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.token(\"?\");\n  }\n\n  if (typeAnnotation) {\n    this.token(\":\");\n    this.space();\n    this.print(typeAnnotation);\n  }\n  this.space();\n  exit();\n  this.token(\"}\");\n}\n\nfunction tokenIfPlusMinus(self: Printer, tok: true | \"+\" | \"-\") {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nexport function TSTemplateLiteralType(\n  this: Printer,\n  node: t.TSTemplateLiteralType,\n) {\n  this._printTemplate(node, node.types);\n}\n\nexport function TSLiteralType(this: Printer, node: t.TSLiteralType) {\n  this.print(node.literal);\n}\n\nexport function TSClassImplements(\n  this: Printer,\n  // TODO(Babel 8): Just use t.TSClassImplements\n  node: t.Node & {\n    expression: t.TSEntityName;\n    typeArguments?: t.TSTypeParameterInstantiation;\n  },\n) {\n  this.print(node.expression);\n  this.print(node.typeArguments);\n}\n\nexport { TSClassImplements as TSInterfaceHeritage };\n\nexport function TSInterfaceDeclaration(\n  this: Printer,\n  node: t.TSInterfaceDeclaration,\n) {\n  const { declare, id, typeParameters, extends: extendz, body } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"interface\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  if (extendz?.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz);\n  }\n  this.space();\n  this.print(body);\n}\n\nexport function TSInterfaceBody(this: Printer, node: t.TSInterfaceBody) {\n  printBraced(this, node, () => this.printJoin(node.body, true, true));\n}\n\nexport function TSTypeAliasDeclaration(\n  this: Printer,\n  node: t.TSTypeAliasDeclaration,\n) {\n  const { declare, id, typeParameters, typeAnnotation } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  this.word(\"type\");\n  this.space();\n  this.print(id);\n  this.print(typeParameters);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(typeAnnotation);\n  this.semicolon();\n}\n\nfunction TSTypeExpression(\n  this: Printer,\n  node: t.TSAsExpression | t.TSSatisfiesExpression,\n) {\n  const { type, expression, typeAnnotation } = node;\n  this.print(expression, true);\n  this.space();\n  this.word(type === \"TSAsExpression\" ? \"as\" : \"satisfies\");\n  this.space();\n  this.print(typeAnnotation);\n}\n\nexport {\n  TSTypeExpression as TSAsExpression,\n  TSTypeExpression as TSSatisfiesExpression,\n};\n\nexport function TSTypeAssertion(this: Printer, node: t.TSTypeAssertion) {\n  const { typeAnnotation, expression } = node;\n  this.token(\"<\");\n  this.print(typeAnnotation);\n  this.token(\">\");\n  this.space();\n  this.print(expression);\n}\n\nexport function TSInstantiationExpression(\n  this: Printer,\n  node: t.TSInstantiationExpression,\n) {\n  this.print(node.expression);\n\n  this.print(node.typeArguments);\n}\n\nexport function TSEnumDeclaration(this: Printer, node: t.TSEnumDeclaration) {\n  const { declare, const: isConst, id } = node;\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n  this.word(\"enum\");\n  this.space();\n  this.print(id);\n  this.space();\n\n  this.print(node.body);\n}\n\nexport function TSEnumBody(this: Printer, node: t.TSEnumBody) {\n  printBraced(this, node, () =>\n    this.printList(\n      node.members,\n      this.shouldPrintTrailingComma(\"}\") ?? false,\n      true,\n      true,\n    ),\n  );\n}\n\nexport function TSEnumMember(this: Printer, node: t.TSEnumMember) {\n  const { id, initializer } = node;\n  this.print(id);\n  if (initializer) {\n    this.space();\n    this.token(\"=\");\n    this.space();\n    this.print(initializer);\n  }\n}\n\nexport function TSModuleDeclaration(\n  this: Printer,\n  node: t.TSModuleDeclaration,\n) {\n  const { declare, kind } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (kind !== \"global\") {\n    this.word(kind);\n    this.space();\n  }\n\n  this.print(node.id);\n  if (!node.body) {\n    this.semicolon();\n    return;\n  }\n  this.space();\n  this.print(node.body);\n}\n\nexport function TSModuleBlock(this: Printer, node: t.TSModuleBlock) {\n  printBraced(this, node, () => this.printSequence(node.body, true));\n}\n\nexport function TSImportType(this: Printer, node: t.TSImportType) {\n  const { qualifier, options } = node;\n  this.word(\"import\");\n  this.token(\"(\");\n  this.print(node.source);\n  if (options) {\n    this.token(\",\");\n    this.print(options);\n  }\n  this.token(\")\");\n  if (qualifier) {\n    this.token(\".\");\n    this.print(qualifier);\n  }\n  const typeArguments = node.typeArguments;\n\n  if (typeArguments) {\n    this.print(typeArguments);\n  }\n}\n\nexport function TSImportEqualsDeclaration(\n  this: Printer,\n  node: t.TSImportEqualsDeclaration,\n) {\n  const { id, moduleReference } = node;\n\n  this.word(\"import\");\n  this.space();\n  this.print(id);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(moduleReference);\n  this.semicolon();\n}\n\nexport function TSExternalModuleReference(\n  this: Printer,\n  node: t.TSExternalModuleReference,\n) {\n  this.token(\"require(\");\n  this.print(node.expression);\n  this.token(\")\");\n}\n\nexport function TSNonNullExpression(\n  this: Printer,\n  node: t.TSNonNullExpression,\n) {\n  this.print(node.expression);\n  this.token(\"!\");\n}\n\nexport function TSExportAssignment(this: Printer, node: t.TSExportAssignment) {\n  this.word(\"export\");\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function TSNamespaceExportDeclaration(\n  this: Printer,\n  node: t.TSNamespaceExportDeclaration,\n) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id);\n  this.semicolon();\n}\n\nexport function tsPrintSignatureDeclarationBase(this: Printer, node: any) {\n  const { typeParameters } = node;\n  const parameters = node.params;\n  this.print(typeParameters);\n  this.token(\"(\");\n  this._parameters(parameters, \")\");\n  const returnType = node.returnType;\n  this.print(returnType);\n}\n\nexport function tsPrintClassMemberModifiers(\n  this: Printer,\n  node:\n    | t.ClassProperty\n    | t.ClassAccessorProperty\n    | t.ClassPrivateProperty\n    | t.ClassMethod\n    | t.ClassPrivateMethod\n    | t.TSDeclareMethod,\n) {\n  const isPrivateField = node.type === \"ClassPrivateProperty\";\n  const isPublicField =\n    node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n  printModifiersList(this, node, [\n    isPublicField && node.declare && \"declare\",\n    !isPrivateField && node.accessibility,\n  ]);\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n  printModifiersList(this, node, [\n    !isPrivateField && node.abstract && \"abstract\",\n    !isPrivateField && node.override && \"override\",\n    (isPublicField || isPrivateField) && node.readonly && \"readonly\",\n  ]);\n}\n\nfunction printBraced(printer: Printer, node: t.Node, cb: () => void) {\n  printer.token(\"{\");\n  const exit = printer.enterDelimited();\n  cb();\n  exit();\n  printer.rightBrace(node);\n}\n\nfunction printModifiersList(\n  printer: Printer,\n  node: t.Node,\n  modifiers: (string | false | null | undefined)[],\n) {\n  const modifiersSet = new Set<string>();\n  for (const modifier of modifiers) {\n    if (modifier) modifiersSet.add(modifier);\n  }\n\n  printer.tokenMap?.find(node, tok => {\n    if (modifiersSet.has(tok.value)) {\n      printer.token(tok.value);\n      printer.space();\n      modifiersSet.delete(tok.value);\n      return modifiersSet.size === 0;\n    }\n    return false;\n  });\n\n  for (const modifier of modifiersSet) {\n    printer.word(modifier);\n    printer.space();\n  }\n}\n","import Buffer, { type Pos } from \"./buffer.ts\";\nimport type { Loc } from \"./buffer.ts\";\nimport * as n from \"./node/index.ts\";\nimport type * as t from \"@babel/types\";\nimport {\n  isExpression,\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumMember,\n} from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport { TokenMap } from \"./token-map.ts\";\nimport type { GeneratorOptions } from \"./index.ts\";\nimport * as generatorFunctions from \"./generators/index.ts\";\nimport type SourceMap from \"./source-map.ts\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\nimport type { Token } from \"@babel/parser\";\n\n// We inline this package\n// eslint-disable-next-line import/no-extraneous-dependencies\nimport * as charCodes from \"charcodes\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\\n\\r\\u2028\\u2029]|\\*\\//;\n\nfunction commentIsNewline(c: t.Comment) {\n  return c.type === \"CommentLine\" || HAS_NEWLINE.test(c.value);\n}\n\nconst { needsParens } = n;\n\nimport { TokenContext } from \"./node/index.ts\";\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  preserveFormat: boolean | undefined;\n  retainLines: boolean | undefined;\n  retainFunctionParens: boolean | undefined;\n  comments: boolean | undefined;\n  auxiliaryCommentBefore: string | undefined;\n  auxiliaryCommentAfter: string | undefined;\n  compact: boolean | \"auto\" | undefined;\n  minified: boolean | undefined;\n  concise: boolean | undefined;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  /**\n   * @deprecated Removed in Babel 8, syntax type is always 'hash'\n   */\n  recordAndTupleSyntaxType?: GeneratorOptions[\"recordAndTupleSyntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodiesâ€™ topic references.\n   */\n  topicToken?: GeneratorOptions[\"topicToken\"];\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   * @deprecated Removed in Babel 8.\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface AddNewlinesOptions {\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer, occurrenceCount: number, last: boolean) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n  printTrailingSeparator?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass Printer {\n  constructor(\n    format: Format,\n    map: SourceMap | null,\n    tokens: Token[] | null = null,\n    originalCode: string | null = null,\n  ) {\n    this.format = format;\n\n    this._tokens = tokens;\n    this._originalCode = originalCode;\n\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap || null;\n\n    this._buf = new Buffer(map, format.indent.style[0]);\n  }\n  declare _inputMap: TraceMap | null;\n\n  declare format: Format;\n\n  enterForStatementInit() {\n    this.tokenContext |=\n      TokenContext.forInitHead | TokenContext.forInOrInitHeadAccumulate;\n    return () => (this.tokenContext = TokenContext.normal);\n  }\n\n  enterForXStatementInit(isForOf: boolean) {\n    if (isForOf) {\n      this.tokenContext |= TokenContext.forOfHead;\n      return null;\n    } else {\n      this.tokenContext |=\n        TokenContext.forInHead | TokenContext.forInOrInitHeadAccumulate;\n      return () => (this.tokenContext = TokenContext.normal);\n    }\n  }\n\n  enterDelimited() {\n    const oldTokenContext = this.tokenContext;\n    const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n    if (\n      !(oldTokenContext & TokenContext.forInOrInitHeadAccumulate) &&\n      oldNoLineTerminatorAfterNode === null\n    ) {\n      return () => {};\n    }\n    this._noLineTerminatorAfterNode = null;\n    this.tokenContext = TokenContext.normal;\n    return () => {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n      this.tokenContext = oldTokenContext;\n    };\n  }\n\n  tokenContext: number = TokenContext.normal;\n\n  _tokens: Token[] | null = null;\n  _originalCode: string | null = null;\n\n  declare _buf: Buffer;\n  _currentNode: t.Node | null = null;\n  _indent: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _noLineTerminator: boolean = false;\n  _noLineTerminatorAfterNode: t.Node | null = null;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _endsWithDiv = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n  tokenMap: TokenMap | null = null;\n\n  _boundGetRawIdentifier = this._getRawIdentifier.bind(this);\n\n  generate(ast: t.Node) {\n    if (this.format.preserveFormat) {\n      this.tokenMap = new TokenMap(ast, this._tokens!, this._originalCode!);\n    }\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    const { format } = this;\n    if (format.preserveFormat || format.compact || format.concise) {\n      return;\n    }\n\n    this._indent--;\n  }\n\n  /**\n   * If the next token is on the same line, we must first print a semicolon.\n   * This option is only used in `preserveFormat` node, for semicolons that\n   * might have omitted due to them being absent in the original code (thanks\n   * to ASI).\n   *\n   * We need both *NextToken and *NextNode because we only want to insert the\n   * semicolon when the next token starts a new node, and not in cases like\n   * foo} (where } is not starting a new node). So we first set *NextNode, and\n   * then the print() method will move it to *NextToken.\n   */\n  _printSemicolonBeforeNextNode: number = -1;\n  _printSemicolonBeforeNextToken: number = -1;\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n      this._noLineTerminator = false;\n      return;\n    }\n    if (this.tokenMap) {\n      const node = this._currentNode!;\n      if (node.start != null && node.end != null) {\n        if (!this.tokenMap.endMatches(node, \";\")) {\n          // no semicolon\n          this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();\n          return;\n        }\n        const indexes = this.tokenMap.getIndexes(this._currentNode!)!;\n        this._catchUpTo(this._tokens![indexes[indexes.length - 1]].loc.start);\n      }\n    }\n    this._queue(charCodes.semicolon);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    const { format } = this;\n    if (format.compact || format.preserveFormat) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (this._endsWithDiv && str.charCodeAt(0) === charCodes.slash)\n    ) {\n      this._space();\n    }\n    this._append(str, false);\n\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string, number?: number): void {\n    // const NON_DECIMAL_LITERAL = /^0[box]/;\n    function isNonDecimalLiteral(str: string) {\n      if (str.length > 2 && str.charCodeAt(0) === charCodes.digit0) {\n        const secondChar = str.charCodeAt(1);\n        return (\n          secondChar === charCodes.lowercaseB ||\n          secondChar === charCodes.lowercaseO ||\n          secondChar === charCodes.lowercaseX\n        );\n      }\n      return false;\n    }\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(number) &&\n      !isNonDecimalLiteral(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   *\n   * @param {string} str The string to append.\n   * @param {boolean} [maybeNewline=false] Wether `str` might potentially\n   *    contain a line terminator or not.\n   * @param {number} [occurrenceCount=0] The occurrence count of this token in\n   *    the current node. This is used when printing in `preserveFormat` mode,\n   *    to know which token we should map to (for example, to disambiguate the\n   *    commas in an array literal).\n   */\n  token(str: string, maybeNewline = false, occurrenceCount = 0): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    this._maybePrintInnerComments(str, occurrenceCount);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str, occurrenceCount);\n\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark && // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (str === \"--\" || // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo)) || // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number): void {\n    this.tokenContext &= TokenContext.forInOrInitHeadAccumulatePassThroughMask;\n\n    const str = String.fromCharCode(char);\n    this._maybePrintInnerComments(str);\n\n    this._maybeAddAuxComment();\n\n    if (this.tokenMap) this._catchUpToCurrentToken(str);\n\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number | undefined {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | null | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | null | undefined,\n    columnOffset: number,\n  ): void {\n    if (!loc || this.format.preserveFormat) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, columnOffset);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _catchUpToCurrentToken(str: string, occurrenceCount: number = 0): void {\n    // Assert: this.tokenMap\n\n    const token = this.tokenMap!.findMatching(\n      this._currentNode!,\n      str,\n      occurrenceCount,\n    );\n    if (token) this._catchUpTo(token.loc.start);\n\n    if (\n      this._printSemicolonBeforeNextToken !== -1 &&\n      this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()\n    ) {\n      this._buf.appendChar(charCodes.semicolon);\n      this._endsWithWord = false;\n      this._endsWithInteger = false;\n      this._endsWithDiv = false;\n    }\n    this._printSemicolonBeforeNextToken = -1;\n    this._printSemicolonBeforeNextNode = -1;\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    // callers are expected to then set these to `true` when needed\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n    this._endsWithDiv = false;\n  }\n\n  _queue(char: number) {\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    const { format } = this;\n    if (!format.preserveFormat) {\n      if (format.retainLines && loc?.[prop]) {\n        this.catchUp(loc[prop].line);\n      }\n      return;\n    }\n\n    // catch up to this nodes newline if we're behind\n    const pos = loc?.[prop];\n    if (pos != null) this._catchUpTo(pos);\n  }\n\n  _catchUpTo({ line, column, index }: Pos) {\n    const count = line - this._buf.getCurrentLine();\n    if (count > 0 && this._noLineTerminator) {\n      // We cannot inject new lines when _noLineTemrinator is set\n      // to `true`, or we would generate invalid code.\n      return;\n    }\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n\n    const spacesCount =\n      count > 0 ? column : column - this._buf.getCurrentColumn();\n    if (spacesCount > 0) {\n      const spaces = this._originalCode\n        ? this._originalCode\n            .slice(index - spacesCount, index)\n            // https://tc39.es/ecma262/#sec-white-space\n            .replace(/[^\\t\\v\\f\\uFEFF\\p{Space_Separator}]/gu, \" \")\n        : \" \".repeat(spacesCount);\n      this._append(spaces, false);\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    this._noLineTerminator = true;\n    this.print(node);\n  }\n\n  print(\n    node: t.Node | null | undefined,\n    noLineTerminatorAfter: boolean = false,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          // renamed\n          t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    const parent = this._currentNode;\n    this._currentNode = node;\n\n    if (this.tokenMap) {\n      this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;\n    }\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == null;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    const parenthesized = node.extra?.parenthesized as boolean | undefined;\n    let shouldPrintParens =\n      (parenthesized && format.preserveFormat) ||\n      (parenthesized &&\n        format.retainFunctionParens &&\n        nodeType === \"FunctionExpression\") ||\n      needsParens(\n        node,\n        parent,\n        this.tokenContext,\n        format.preserveFormat ? this._boundGetRawIdentifier : undefined,\n      );\n\n    if (\n      !shouldPrintParens &&\n      parenthesized &&\n      node.leadingComments?.length &&\n      node.leadingComments[0].type === \"CommentBlock\"\n    ) {\n      const parentType = parent?.type;\n      switch (parentType) {\n        case \"ExpressionStatement\":\n        case \"VariableDeclarator\":\n        case \"AssignmentExpression\":\n        case \"ReturnStatement\":\n          break;\n        case \"CallExpression\":\n        case \"OptionalCallExpression\":\n        case \"NewExpression\":\n          if (parent.callee !== node) break;\n        // falls through\n        default:\n          shouldPrintParens = true;\n      }\n    }\n\n    let indentParenthesized = false;\n    if (\n      !shouldPrintParens &&\n      this._noLineTerminator &&\n      (node.leadingComments?.some(commentIsNewline) ||\n        (this.format.retainLines &&\n          node.loc &&\n          node.loc.start.line > this._buf.getCurrentLine()))\n    ) {\n      shouldPrintParens = true;\n      indentParenthesized = true;\n    }\n\n    let oldNoLineTerminatorAfterNode;\n    let oldTokenContext;\n    if (!shouldPrintParens) {\n      noLineTerminatorAfter ||=\n        !!parent &&\n        this._noLineTerminatorAfterNode === parent &&\n        n.isLastChild(parent, node);\n      if (noLineTerminatorAfter) {\n        if (node.trailingComments?.some(commentIsNewline)) {\n          if (isExpression(node)) shouldPrintParens = true;\n        } else {\n          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n          this._noLineTerminatorAfterNode = node;\n        }\n      }\n    }\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      if (indentParenthesized) this.indent();\n      this._endsWithInnerRaw = false;\n      if (this.tokenContext & TokenContext.forInOrInitHeadAccumulate) {\n        oldTokenContext = this.tokenContext;\n        this.tokenContext = TokenContext.normal;\n      }\n      oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;\n      this._noLineTerminatorAfterNode = null;\n    }\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(\n      loc,\n      // @ts-expect-error Expected 1 arguments, but got 3.\n      printMethod.bind(this, node, parent),\n    );\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      if (indentParenthesized) {\n        this.dedent();\n        this.newline();\n      }\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n      if (oldTokenContext) this.tokenContext = oldTokenContext;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    // end\n    this._currentNode = parent;\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    if (oldNoLineTerminatorAfterNode !== undefined) {\n      this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;\n    }\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra?.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: t.Node[] | undefined | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintJoinOptions[\"separator\"] | null,\n    printTrailingSeparator?: boolean | null,\n    iterator?: PrintJoinOptions[\"iterator\"] | null,\n    trailingCommentsLineOffset?: number,\n  ) {\n    if (!nodes?.length) return;\n\n    if (indent == null && this.format.retainLines) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      nextNodeStartLine: 0,\n    };\n\n    const boundSeparator = separator?.bind(this);\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, undefined, trailingCommentsLineOffset || 0);\n\n      iterator?.(node, i);\n\n      if (boundSeparator != null) {\n        if (i < len - 1) boundSeparator(i, false);\n        else if (printTrailingSeparator) boundSeparator(i, true);\n      }\n\n      if (statement) {\n        if (!node.trailingComments?.length) {\n          this._lastCommentLine = 0;\n        }\n\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node);\n  }\n\n  _printTrailingComments(\n    node: t.Node,\n    parent?: t.Node | null,\n    lineOffset?: number,\n  ) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node | null) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments(\n    nextTokenStr: string,\n    nextTokenOccurrenceCount?: number,\n  ) {\n    if (this._endsWithInnerRaw) {\n      this.printInnerComments(\n        this.tokenMap?.findMatching(\n          this._currentNode!,\n          nextTokenStr,\n          nextTokenOccurrenceCount,\n        ),\n      );\n    }\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments(nextToken?: Token | null) {\n    const node = this._currentNode!;\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(\n      COMMENT_TYPE.INNER,\n      comments,\n      node,\n      undefined,\n      undefined,\n      nextToken,\n    );\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    indent?: boolean,\n    trailingCommentsLineOffset?: number,\n  ) {\n    this.printJoin(\n      nodes,\n      true,\n      indent ?? false,\n      undefined,\n      undefined,\n      undefined,\n      trailingCommentsLineOffset,\n    );\n  }\n\n  printList(\n    items: t.Node[] | null | undefined,\n    printTrailingSeparator?: boolean | null,\n    statement?: boolean,\n    indent?: boolean,\n    separator?: PrintListOptions[\"separator\"],\n    iterator?: PrintListOptions[\"iterator\"],\n  ) {\n    this.printJoin(\n      items,\n      statement,\n      indent,\n      separator ?? commaSeparator,\n      printTrailingSeparator,\n      iterator,\n    );\n  }\n\n  shouldPrintTrailingComma(listEnd: string): boolean | null {\n    if (!this.tokenMap) return null;\n\n    const listEndIndex = this.tokenMap.findLastIndex(\n      this._currentNode!,\n      token => this.tokenMap!.matchesOriginal(token, listEnd),\n    );\n    if (listEndIndex <= 0) return null;\n    return this.tokenMap.matchesOriginal(this._tokens![listEndIndex - 1], \",\");\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    const format = this.format;\n\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (format.retainLines || format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(\n    comment: t.Comment,\n    nextToken?: Token | null,\n  ): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment.value)\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    if (nextToken && this.tokenMap) {\n      const commentTok = this.tokenMap.find(\n        this._currentNode!,\n        token => token.value === comment.value,\n      );\n      if (commentTok && commentTok.start > nextToken.start) {\n        return PRINT_COMMENT_HINT.DEFER;\n      }\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace &&\n      lastCharCode !== charCodes.leftParenthesis\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        if (this.format.concise) {\n          val = val.replace(/\\n(?!$)/g, `\\n`);\n        } else {\n          let indentSize = this.format.retainLines\n            ? 0\n            : this._buf.getCurrentColumn();\n\n          if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n            indentSize += this._getIndent();\n          }\n\n          val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n        }\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid converting a / operator into a line comment by appending /* to it\n    if (this._endsWithDiv) this._space();\n\n    if (this.tokenMap) {\n      const { _printSemicolonBeforeNextToken, _printSemicolonBeforeNextNode } =\n        this;\n      this._printSemicolonBeforeNextToken = -1;\n      this._printSemicolonBeforeNextNode = -1;\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n      this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;\n      this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;\n    } else {\n      this.source(\"start\", comment.loc);\n      this._append(val, isBlockComment);\n    }\n\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node | null,\n    lineOffset: number = 0,\n    nextToken?: Token | null,\n  ) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc!.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc!.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const maybeNewline = this._noLineTerminator\n      ? function () {}\n      : this.newline.bind(this);\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment, nextToken);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine !== commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(\n              Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n            );\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumMember(node);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent, { body: node }))\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n                ? COMMENT_SKIP_NEWLINE.TRAILING\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\ntype GeneratorFunctions = typeof generatorFunctions;\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type, @typescript-eslint/no-unsafe-declaration-merging\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer, occurrenceCount: number, last: boolean) {\n  this.token(\",\", false, occurrenceCount);\n  if (!last) this.space();\n}\n","import SourceMap from \"./source-map.ts\";\nimport Printer from \"./printer.ts\";\nimport type * as t from \"@babel/types\";\nimport type { Opts as jsescOptions } from \"jsesc\";\nimport type { Format } from \"./printer.ts\";\nimport type {\n  EncodedSourceMap,\n  DecodedSourceMap,\n  Mapping,\n} from \"@jridgewell/gen-mapping\";\n\n/**\n * Normalize generator options, setting defaults.\n *\n * - Detects code indentation.\n * - If `opts.compact = \"auto\"` and the code is over 500KB, `compact` will be set to `true`.\n */\n\nfunction normalizeOptions(\n  code: string | Record<string, string> | undefined,\n  opts: GeneratorOptions,\n  ast: t.Node,\n): Format {\n  if (opts.experimental_preserveFormat) {\n    if (typeof code !== \"string\") {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string\",\n      );\n    }\n    if (!opts.retainLines) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires `retainLines` to be set to `true`\",\n      );\n    }\n    if (opts.compact && opts.compact !== \"auto\") {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `compact` option\",\n      );\n    }\n    if (opts.minified) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `minified` option\",\n      );\n    }\n    if (opts.jsescOption) {\n      throw new Error(\n        \"`experimental_preserveFormat` is not compatible with the `jsescOption` option\",\n      );\n    }\n    if (!Array.isArray((ast as any).tokens)) {\n      throw new Error(\n        \"`experimental_preserveFormat` requires the AST to have attached the token of the input code. Make sure to enable the `tokens: true` parser option.\",\n      );\n    }\n  }\n\n  const format: Format = {\n    auxiliaryCommentBefore: opts.auxiliaryCommentBefore,\n    auxiliaryCommentAfter: opts.auxiliaryCommentAfter,\n    // @ts-expect-error define it later\n    shouldPrintComment: opts.shouldPrintComment,\n    preserveFormat: opts.experimental_preserveFormat,\n    retainLines: opts.retainLines,\n    retainFunctionParens: opts.retainFunctionParens,\n    comments: opts.comments == null || opts.comments,\n    compact: opts.compact,\n    minified: opts.minified,\n    concise: opts.concise,\n    indent: {\n      adjustMultilineComment: true,\n      style: \"  \",\n    },\n    jsescOption: {\n      quotes: \"double\",\n      wrap: true,\n      minimal: true,\n      ...opts.jsescOption,\n    },\n    topicToken: opts.topicToken,\n  };\n\n  if (format.minified) {\n    format.compact = true;\n\n    format.shouldPrintComment =\n      format.shouldPrintComment || (() => format.comments);\n  } else {\n    format.shouldPrintComment =\n      format.shouldPrintComment ||\n      (value =>\n        format.comments ||\n        value.includes(\"@license\") ||\n        value.includes(\"@preserve\"));\n  }\n\n  if (format.compact === \"auto\") {\n    format.compact = typeof code === \"string\" && code.length > 500_000; // 500KB\n\n    if (format.compact) {\n      console.error(\n        \"[BABEL] Note: The code generator has deoptimised the styling of \" +\n          `${opts.filename} as it exceeds the max of ${\"500KB\"}.`,\n      );\n    }\n  }\n\n  if (format.compact || format.preserveFormat) {\n    format.indent.adjustMultilineComment = false;\n  }\n\n  const { auxiliaryCommentBefore, auxiliaryCommentAfter, shouldPrintComment } =\n    format;\n\n  if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {\n    format.auxiliaryCommentBefore = undefined;\n  }\n  if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {\n    format.auxiliaryCommentAfter = undefined;\n  }\n\n  return format;\n}\n\nexport interface GeneratorOptions {\n  /**\n   * Optional string to add as a block comment at the start of the output file.\n   */\n  auxiliaryCommentBefore?: string;\n\n  /**\n   * Optional string to add as a block comment at the end of the output file.\n   */\n  auxiliaryCommentAfter?: string;\n\n  /**\n   * Function that takes a comment (as a string) and returns true if the comment should be included in the output.\n   * By default, comments are included if `opts.comments` is `true` or if `opts.minified` is `false` and the comment\n   * contains `@preserve` or `@license`.\n   */\n  shouldPrintComment?(comment: string): boolean;\n\n  /**\n   * Preserve the input code format while printing the transformed code.\n   * This is experimental, and may have breaking changes in future\n   * patch releases. It will be removed in a future minor release,\n   * when it will graduate to stable.\n   */\n  experimental_preserveFormat?: boolean;\n\n  /**\n   * Attempt to use the same line numbers in the output code as in the source code (helps preserve stack traces).\n   * Defaults to `false`.\n   */\n  retainLines?: boolean;\n\n  /**\n   * Retain parens around function expressions (could be used to change engine parsing behavior)\n   * Defaults to `false`.\n   */\n  retainFunctionParens?: boolean;\n\n  /**\n   * Should comments be included in output? Defaults to `true`.\n   */\n  comments?: boolean;\n\n  /**\n   * Set to true to avoid adding whitespace for formatting. Defaults to the value of `opts.minified`.\n   */\n  compact?: boolean | \"auto\";\n\n  /**\n   * Should the output be minified. Defaults to `false`.\n   */\n  minified?: boolean;\n\n  /**\n   * Set to true to reduce whitespace (but not as much as opts.compact). Defaults to `false`.\n   */\n  concise?: boolean;\n\n  /**\n   * Used in warning messages\n   */\n  filename?: string;\n\n  /**\n   * Enable generating source maps. Defaults to `false`.\n   */\n  sourceMaps?: boolean;\n\n  inputSourceMap?: any;\n\n  /**\n   * A root for all relative URLs in the source map.\n   */\n  sourceRoot?: string;\n\n  /**\n   * The filename for the source code (i.e. the code in the `code` argument).\n   * This will only be used if `code` is a string.\n   */\n  sourceFileName?: string;\n\n  /**\n   * Set to true to run jsesc with \"json\": true to print \"\\u00A9\" vs. \"Â©\";\n   * @deprecated use `jsescOptions: { json: true }` instead\n   */\n  jsonCompatibleStrings?: boolean;\n\n  /**\n   * Set to true to enable support for experimental decorators syntax before\n   * module exports. If not specified, decorators will be printed in the same\n   * position as they were in the input source code.\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n\n  /**\n   * Options for outputting jsesc representation.\n   */\n  jsescOption?: jsescOptions;\n\n  /**\n   * For use with the recordAndTuple token.\n   * @deprecated It will be removed in Babel 8.\n   */\n  recordAndTupleSyntaxType?: \"bar\" | \"hash\";\n\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodiesâ€™ topic references.\n   */\n  topicToken?: \"%\" | \"#\" | \"@@\" | \"^^\" | \"^\";\n\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   * @deprecated Removed in Babel 8.\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n}\n\nexport interface GeneratorResult {\n  code: string;\n  map: EncodedSourceMap | null;\n  decodedMap: DecodedSourceMap | undefined;\n  rawMappings: Mapping[] | undefined;\n}\n\n/**\n * Turns an AST into code, maintaining sourcemaps, user preferences, and valid output.\n * @param ast - the abstract syntax tree from which to generate output code.\n * @param opts - used for specifying options for code generation.\n * @param code - the original source code, used for source maps.\n * @returns - an object containing the output code and source map.\n */\nexport function generate(\n  ast: t.Node,\n  opts: GeneratorOptions = {},\n  code?: string | Record<string, string>,\n): GeneratorResult {\n  const format = normalizeOptions(code, opts, ast);\n  const map = opts.sourceMaps ? new SourceMap(opts, code) : null;\n\n  const printer = new Printer(\n    format,\n    map,\n    (ast as any).tokens,\n    typeof code === \"string\" ? code : null,\n  );\n\n  return printer.generate(ast);\n}\n\nexport default generate;\n"],"names":["SourceMap","_map","_rawMappings","_sourceFileName","_lastGenLine","_lastSourceLine","_lastSourceColumn","_inputMap","constructor","opts","code","map","GenMapping","sourceRoot","sourceFileName","replace","undefined","inputSourceMap","TraceMap","resolvedSources","length","i","setSourceContent","sourcesContent","Object","keys","get","toEncodedMap","getDecoded","toDecodedMap","getRawMappings","allMappings","mark","generated","line","column","identifierName","identifierNamePos","filename","originalMapping","originalPositionFor","name","originalIdentifierMapping","source","maybeAddMapping","original","Buffer","indentChar","_indentChar","_fastIndentations","push","repeat","_allocQueue","_buf","_str","_appendCount","_last","_queue","_queueCursor","_canMarkIdName","_position","_sourcePosition","queue","char","_pushQueue","cursor","item","_popQueue","Error","_flush","result","trimRight","decodedMap","__mergedMap","resultMap","value","defineProperty","writable","rawMappings","mappings","append","str","maybeNewline","_append","appendChar","_appendChar","sourcePosition","queueIndentation","queueCursor","sourcePos","fastIndentation","String","fromCharCode","_mark","len","position","charCodeAt","indexOf","last","removeTrailingNewline","removeLastSemicolon","getLastChar","getNewlineCount","count","endsWithCharAndNewline","lastCp","hasContent","exactSource","loc","cb","prop","_normalizePosition","sourceWithOffset","columnOffset","pos","target","Math","max","getCurrentColumn","lastIndex","getCurrentLine","FLIPPED_ALIAS_KEYS","isArrayExpression","isAssignmentExpression","isBinary","isBlockStatement","isCallExpression","isFunction","isIdentifier","isLiteral","isMemberExpression","isObjectExpression","isOptionalCallExpression","isOptionalMemberExpression","isStringLiteral","_t","crawlInternal","node","state","object","computed","property","left","right","hasCall","callee","hasFunction","hasHelper","isHelper","crawl","isType","nodes","AssignmentExpression","SwitchCase","parent","consequent","cases","LogicalExpression","Literal","CallExpression","OptionalCallExpression","VariableDeclaration","declarations","declar","enabled","id","init","IfStatement","ObjectProperty","ObjectTypeProperty","ObjectMethod","properties","ObjectTypeCallProperty","callProperties","ObjectTypeIndexer","indexers","ObjectTypeInternalSlot","internalSlots","forEach","type","amounts","concat","ret","isArrayTypeAnnotation","isBinaryExpression","isForOfStatement","isIndexedAccessType","isObjectPattern","isYieldExpression","isStatement","PRECEDENCE","Map","getBinaryPrecedence","nodeType","operator","isTSTypeExpression","isClassExtendsClause","parentType","superClass","hasPostfixPart","tag","NullableTypeAnnotation","FunctionTypeAnnotation","tokenContext","Boolean","TokenContext","arrowFlowReturnType","UpdateExpression","needsParenBeforeExpressionBrace","expressionStatement","arrowBody","ObjectExpression","DoExpression","async","Binary","parentPos","nodePos","UnionTypeAnnotation","OptionalIndexedAccessType","objectType","TSAsExpression","TSConditionalType","types","checkType","extendsType","TSUnionType","TSIntersectionType","TSInferType","typeParameter","constraint","TSTypeOperator","TSInstantiationExpression","typeArguments","TSFunctionType","BinaryExpression","forInOrInitHeadAccumulate","SequenceExpression","YieldExpression","test","ClassExpression","exportDefault","UnaryLike","FunctionExpression","ConditionalExpression","OptionalMemberExpression","Identifier","getRawIdentifier","extra","parenthesized","rightType","isFollowedByBracket","optional","forInitHead","forInHead","forOfHead","await","VISITOR_KEYS","isDecorator","isExpressionStatement","isNewExpression","isParenthesizedExpression","normal","forInOrInitHeadAccumulatePassThroughMask","expandAliases","obj","add","func","fn","set","stack","aliases","alias","expandedParens","parens","expandedWhitespaceNodes","whitespace","isOrHasCallExpression","needsWhitespace","expression","flag","needsWhitespaceBefore","needsWhitespaceAfter","needsParens","isDecoratorMemberExpression","isLastChild","child","visitorKeys","val","Array","isArray","j","traverseFast","TokenMap","_tokens","_source","_nodesToTokenIndexes","_nodesOccurrencesCountCache","_tokensCache","ast","tokens","indexes","_getTokensIndexesOfNode","clear","has","getIndexes","find","condition","k","index","tok","findLastIndex","findMatching","occurrenceCount","cache","matchesOriginal","token","end","start","startsWith","startMatches","endMatches","first","_findTokensOfNode","low","children","childrenIterator","declaration","next","childTok","high","cached","_findFirstTokenOfNode","_findLastTokenOfNode","mid","quasis","expressions","key","TaggedTemplateExpression","print","quasi","TemplateElement","_printTemplate","substitutions","partRaw","raw","TemplateLiteral","isPattern","UnaryExpression","word","space","argument","body","ParenthesizedExpression","exit","enterDelimited","rightParens","prefix","alternate","NewExpression","format","minified","arguments","tokenMap","printList","shouldPrintTrailingComma","ThisExpression","Super","_shouldPrintDecoratorsBeforeExport","Decorator","newline","TypeError","Import","AwaitExpression","delegate","EmptyStatement","semicolon","ExpressionStatement","AssignmentPattern","typeAnnotation","_endsWithDiv","BindExpression","MemberExpression","MetaProperty","meta","PrivateName","V8IntrinsicIdentifier","ModuleExpression","indent","directives","dedent","rightBrace","isFor","isForStatement","isIfStatement","isVoidPattern","WithStatement","printBlock","needsBlock","getLastStatement","printAndIndentOnComments","endsWith","statement","ForStatement","enterForStatementInit","update","WhileStatement","ForXStatement","isForOf","noIndentInnerCommentsHere","enterForXStatementInit","ForInStatement","ForOfStatement","DoWhileStatement","printStatementAfterKeyword","printer","printTerminatorless","BreakStatement","label","ContinueStatement","ReturnStatement","ThrowStatement","LabeledStatement","TryStatement","block","handlers","handler","finalizer","CatchClause","param","SwitchStatement","discriminant","printSequence","DebuggerStatement","declare","kind","hasInits","VariableDeclarator","definite","isExportDefaultDeclaration","isExportNamedDeclaration","ClassDeclaration","inExport","printJoin","decorators","abstract","typeParameters","superTypeArguments","implements","ClassBody","separator","classBodyEmptySemicolonsPrinter","nextLocIndex","advanceNextLocIndex","ClassProperty","static","preserveFormat","endLine","catchUp","tsPrintClassMemberModifiers","_variance","ClassAccessorProperty","ClassPrivateProperty","ClassMethod","_classMethodHead","ClassPrivateMethod","_methodHead","StaticBlock","_params","idNode","parentNode","nameInfo","_getFuncIdName","call","sourceIdentifierName","_parameters","params","noLineTerminator","returnType","_noLineTerminator","parameters","endToken","trailingComma","paramLength","_param","parameter","generator","_predicate","noLineTerminatorAfter","predicate","_functionHead","_endsWithInnerRaw","ArrowFunctionExpression","_shouldPrintArrowParamsParens","printInnerComments","firstParam","leadingComments","trailingComments","arrowToken","retainLines","isClassDeclaration","isExportDefaultSpecifier","isExportNamespaceSpecifier","isImportDefaultSpecifier","isImportNamespaceSpecifier","ImportSpecifier","importKind","imported","local","ImportDefaultSpecifier","ExportDefaultSpecifier","exported","ExportSpecifier","exportKind","ExportNamespaceSpecifier","_printAttributes","hasPreviousBrace","attributes","ExportAllDeclaration","maybePrintDecoratorsBeforeExport","ExportNamedDeclaration","specifiers","slice","hasSpecial","shift","hasBrace","ExportDefaultDeclaration","ImportDeclaration","isTypeKind","module","phase","hasSpecifiers","ImportAttribute","ImportNamespaceSpecifier","ImportExpression","options","isAssignmentPattern","lastRawIdentNode","lastRawIdentResult","_getRawIdentifier","_originalCode","ArgumentPlaceholder","RestElement","props","shorthand","ArrayExpression","elems","elements","elem","RegExpLiteral","pattern","flags","BooleanLiteral","NullLiteral","NumericLiteral","getPossibleRaw","jsescOption","numbers","number","jsesc","StringLiteral","BigIntLiteral","validTopicTokenSet","Set","TopicReference","topicToken","givenTopicTokenJSON","JSON","stringify","validTopics","from","v","join","PipelineTopicExpression","PipelineBareFunction","PipelinePrimaryTopicReference","VoidPattern","isDeclareExportDeclaration","AnyTypeAnnotation","ArrayTypeAnnotation","elementType","BooleanTypeAnnotation","BooleanLiteralTypeAnnotation","NullLiteralTypeAnnotation","DeclareClass","_interfaceish","DeclareFunction","InferredPredicate","DeclaredPredicate","DeclareInterface","InterfaceDeclaration","DeclareModule","DeclareModuleExports","DeclareTypeAlias","TypeAlias","DeclareOpaqueType","OpaqueType","DeclareVariable","DeclareExportDeclaration","default","FlowExportDeclaration","DeclareExportAllDeclaration","EnumDeclaration","enumExplicitType","context","hasExplicitType","enumBody","members","member","hasUnknownMembers","EnumBooleanBody","explicitType","EnumNumberBody","EnumStringBody","EnumSymbolBody","EnumDefaultedMember","enumInitializedMember","EnumBooleanMember","EnumNumberMember","EnumStringMember","ExistsTypeAnnotation","this","rest","method","FunctionTypeParam","InterfaceExtends","extends","mixins","variance","andSeparator","InterfaceTypeAnnotation","IntersectionTypeAnnotation","MixedTypeAnnotation","EmptyTypeAnnotation","NumberTypeAnnotation","StringTypeAnnotation","ThisTypeAnnotation","TupleTypeAnnotation","TypeofTypeAnnotation","TypeAnnotation","TypeParameterInstantiation","TypeParameter","bound","supertype","impltype","ObjectTypeAnnotation","exact","inexact","proto","ObjectTypeSpreadProperty","QualifiedTypeIdentifier","qualification","SymbolTypeAnnotation","orSeparator","TypeCastExpression","Variance","VoidTypeAnnotation","IndexedAccessType","indexType","File","program","interpreter","Program","directivesLen","BlockStatement","Directive","unescapedSingleQuoteRE","unescapedDoubleQuoteRE","DirectiveLiteral","InterpreterDirective","Placeholder","expectedNode","JSXAttribute","JSXIdentifier","JSXNamespacedName","namespace","JSXMemberExpression","JSXSpreadAttribute","JSXExpressionContainer","JSXSpreadChild","JSXText","JSXElement","open","openingElement","selfClosing","closingElement","spaceSeparator","JSXOpeningElement","JSXClosingElement","JSXEmptyExpression","JSXFragment","openingFragment","closingFragment","JSXOpeningFragment","JSXClosingFragment","TSTypeAnnotation","TSTypeParameterInstantiation","printTrailingSeparator","t","TSTypeParameter","const","in","out","TSParameterProperty","accessibility","readonly","TSDeclareFunction","TSDeclareMethod","TSQualifiedName","TSCallSignatureDeclaration","tsPrintSignatureDeclarationBase","maybePrintTrailingCommaOrSemicolon","TSConstructSignatureDeclaration","TSPropertySignature","tsPrintPropertyOrMethodName","TSMethodSignature","TSIndexSignature","isStatic","TSAnyKeyword","TSBigIntKeyword","TSUnknownKeyword","TSNumberKeyword","TSObjectKeyword","TSBooleanKeyword","TSStringKeyword","TSSymbolKeyword","TSVoidKeyword","TSUndefinedKeyword","TSNullKeyword","TSNeverKeyword","TSIntrinsicKeyword","TSThisType","tsPrintFunctionOrConstructorType","TSConstructorType","TSTypeReference","typeName","TSTypePredicate","asserts","parameterName","TSTypeQuery","exprName","TSTypeLiteral","printBraced","TSArrayType","TSTupleType","elementTypes","TSOptionalType","TSRestType","TSNamedTupleMember","tsPrintUnionOrIntersectionType","sep","hasLeadingToken","trueType","falseType","TSParenthesizedType","TSIndexedAccessType","TSMappedType","nameType","tokenIfPlusMinus","self","TSTemplateLiteralType","TSLiteralType","literal","TSClassImplements","TSInterfaceDeclaration","extendz","TSInterfaceBody","TSTypeAliasDeclaration","TSTypeExpression","TSTypeAssertion","TSEnumDeclaration","isConst","TSEnumBody","TSEnumMember","initializer","TSModuleDeclaration","TSModuleBlock","TSImportType","qualifier","TSImportEqualsDeclaration","moduleReference","TSExternalModuleReference","TSNonNullExpression","TSExportAssignment","TSNamespaceExportDeclaration","isPrivateField","isPublicField","printModifiersList","override","modifiers","modifiersSet","modifier","delete","size","isExpression","isClassBody","isTSInterfaceBody","isTSEnumMember","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","HAS_NEWLINE","HAS_NEWLINE_OR_BlOCK_COMMENT_END","commentIsNewline","c","n","Printer","originalCode","_indentRepeat","style","oldTokenContext","oldNoLineTerminatorAfterNode","_noLineTerminatorAfterNode","_currentNode","_indent","_insideAux","_printAuxAfterOnNextUserNode","_printedComments","_endsWithInteger","_endsWithWord","_lastCommentLine","_indentInnerComments","_boundGetRawIdentifier","bind","generate","_maybeAddAuxComment","compact","concise","_printSemicolonBeforeNextNode","_printSemicolonBeforeNextToken","force","_catchUpTo","_space","_maybePrintInnerComments","_catchUpToCurrentToken","isNonDecimalLiteral","secondChar","Number","isInteger","lastChar","strFirst","tokenChar","_newline","_catchUp","_maybeIndent","firstChar","_getIndent","_shouldIndent","spacesCount","spaces","trailingCommentsLineOffset","oldConcise","_compact","printMethod","ReferenceError","oldInAux","shouldPrintParens","retainFunctionParens","indentParenthesized","some","_printLeadingComments","_printTrailingComments","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","rawValue","iterator","startLine","newlineOpts","nextNodeStartLine","boundSeparator","_printNewline","nextNode","lineOffset","innerComments","_printComments","comments","nextTokenStr","nextTokenOccurrenceCount","nextToken","hasSpace","printedCommentsCount","items","commaSeparator","listEnd","listEndIndex","newLine","lastCommentLine","offset","_shouldPrintComment","ignore","commentTok","shouldPrintComment","skipNewLines","isBlockComment","printNewLines","lastCharCode","adjustMultilineComment","newlineRegex","RegExp","indentSize","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","min","singleLine","shouldSkipNewline","assign","prototype","generatorFunctions","normalizeOptions","experimental_preserveFormat","quotes","wrap","minimal","includes","console","error","sourceMaps"],"mappings":"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"}